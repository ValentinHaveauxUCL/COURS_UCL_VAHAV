{"version":3,"sources":["webpack:///webpack/bootstrap 851348b69bb444f7fca2","webpack:///external \"path\"","webpack:///./app/node_modules/graceful-fs/graceful-fs.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/index.js","webpack:///external \"util\"","webpack:///external \"fs\"","webpack:///external \"electron\"","webpack:///external \"os\"","webpack:///external \"stream\"","webpack:///./app/node_modules/winston/lib/winston/common.js","webpack:///./app/node_modules/winston/lib/winston.js","webpack:///external \"events\"","webpack:///./app/node_modules/colors/lib/colors.js","webpack:///./app/node_modules/winston/lib/winston/transports/transport.js","webpack:///./app/node_modules/source-map/lib/util.js","webpack:///./app/node_modules/fs-extra/lib/remove/index.js","webpack:///./app/node_modules/event-kit/lib/event-kit.js","webpack:///./app/src/main-process/log.ts","webpack:///./app/node_modules/winston/lib/winston/config.js","webpack:///./app/src/lib/file-system.ts","webpack:///./app/node_modules/fs-extra/lib/mkdirs/mkdirs.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js","webpack:///./app/node_modules/fs-extra/lib/json/jsonfile.js","webpack:///./app/node_modules/event-kit/lib/disposable.js","webpack:///./app/node_modules/async/lib/async.js","webpack:///external \"zlib\"","webpack:///./app/node_modules/winston/lib/winston/exception.js","webpack:///./app/src/lib/logging/get-log-path.ts","webpack:///./app/node_modules/fs-extra/lib/index.js","webpack:///./app/node_modules/graceful-fs/fs.js","webpack:///external \"assert\"","webpack:///./app/node_modules/fs-extra/lib/copy/ncp.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/win32.js","webpack:///./app/node_modules/fs-extra/lib/copy-sync/index.js","webpack:///./app/node_modules/jsonfile/index.js","webpack:///./app/node_modules/fs-extra/lib/json/output-json-sync.js","webpack:///./app/node_modules/fs-extra/lib/json/output-json.js","webpack:///./app/src/lib/logging/format-error.ts","webpack:///./app/src/lib/source-map-support.ts","webpack:///./app/node_modules/source-map/lib/source-map-generator.js","webpack:///./app/node_modules/source-map/lib/base64-vlq.js","webpack:///./app/node_modules/source-map/lib/array-set.js","webpack:///./app/src/lib/window-state.ts","webpack:///./app/src/lib/fatal-error.ts","webpack:///./app/src/main-process/now.ts","webpack:///./app/src/main-process/menu/index.ts","webpack:///./app/src/main-process/menu/ensure-item-ids.ts","webpack:///./app/src/main-process/shell.ts","webpack:///external \"url\"","webpack:///external \"child_process\"","webpack:///./app/src/main-process/main.ts","webpack:///./app/src/lib/logging/main/install.ts","webpack:///./app/node_modules/winston/package.json","webpack:///./app/node_modules/winston/lib/winston/transports.js","webpack:///./app/node_modules/winston/lib/winston/transports/console.js","webpack:///external \"crypto\"","webpack:///./app/node_modules/cycle/cycle.js","webpack:///external \"string_decoder\"","webpack:///./app/node_modules/colors/safe.js","webpack:///./app/node_modules/colors/lib/styles.js","webpack:///./app/node_modules/colors/lib/system/supports-colors.js","webpack:///./app/node_modules/colors/lib","webpack:///./app/node_modules/colors/lib/custom/trap.js","webpack:///./app/node_modules/colors/lib/custom/zalgo.js","webpack:///./app/node_modules/colors/lib/maps/america.js","webpack:///./app/node_modules/colors/lib/maps/zebra.js","webpack:///./app/node_modules/colors/lib/maps/rainbow.js","webpack:///./app/node_modules/colors/lib/maps/random.js","webpack:///./app/node_modules/winston/lib/winston/config/cli-config.js","webpack:///./app/node_modules/winston/lib/winston/config/npm-config.js","webpack:///./app/node_modules/winston/lib/winston/config/syslog-config.js","webpack:///./app/node_modules/winston/lib/winston/transports/file.js","webpack:///./app/node_modules/isstream/isstream.js","webpack:///./app/node_modules/winston/lib/winston/transports/http.js","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///./app/node_modules/winston/lib/winston/transports/memory.js","webpack:///./app/node_modules/stack-trace/lib/stack-trace.js","webpack:///./app/node_modules/winston/lib/winston/container.js","webpack:///./app/node_modules/winston/lib/winston/logger.js","webpack:///./app/node_modules/fs-extra/lib/util/assign.js","webpack:///./app/node_modules/graceful-fs/polyfills.js","webpack:///external \"constants\"","webpack:///./app/node_modules/graceful-fs/legacy-streams.js","webpack:///./app/node_modules/fs-extra/lib/copy/index.js","webpack:///./app/node_modules/fs-extra/lib/copy/copy.js","webpack:///./app/node_modules/fs-extra/lib/util/utimes.js","webpack:///./app/node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack:///./app/node_modules/fs-extra/lib/copy-sync/copy-file-sync.js","webpack:///./app/node_modules/fs-extra/lib/remove/rimraf.js","webpack:///./app/node_modules/fs-extra/lib/json/index.js","webpack:///./app/node_modules/fs-extra/lib/move/index.js","webpack:///./app/node_modules/fs-extra/lib/move-sync/index.js","webpack:///./app/node_modules/fs-extra/lib/empty/index.js","webpack:///./app/node_modules/fs-extra/lib/ensure/index.js","webpack:///./app/node_modules/fs-extra/lib/ensure/file.js","webpack:///./app/node_modules/fs-extra/lib/ensure/link.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink-type.js","webpack:///./app/node_modules/fs-extra/lib/output/index.js","webpack:///./app/node_modules/event-kit/lib/emitter.js","webpack:///./app/node_modules/event-kit/lib/composite-disposable.js","webpack:///./app/src/lib/tailer.ts","webpack:///./app/node_modules/byline/lib/byline.js","webpack:///external \"timers\"","webpack:///./app/node_modules/winston-daily-rotate-file/index.js","webpack:///./app/src/lib/logging/format-log-message.ts","webpack:///./app/node_modules/file-uri-to-path/index.js","webpack:///./app/node_modules/source-map-support/source-map-support.js","webpack:///./app/node_modules/source-map/source-map.js","webpack:///./app/node_modules/source-map/lib/base64.js","webpack:///./app/node_modules/source-map/lib/mapping-list.js","webpack:///./app/node_modules/source-map/lib/source-map-consumer.js","webpack:///./app/node_modules/source-map/lib/binary-search.js","webpack:///./app/node_modules/source-map/lib/quick-sort.js","webpack:///./app/node_modules/source-map/lib/source-node.js","webpack:///external \"module\"","webpack:///./app/src/main-process/app-window.ts","webpack:///./app/src/models/app-menu.ts","webpack:///./app/node_modules/electron-window-state/index.js","webpack:///./app/node_modules/mkdirp/index.js","webpack:///./app/node_modules/deep-equal/index.js","webpack:///./app/node_modules/deep-equal/lib/keys.js","webpack:///./app/node_modules/deep-equal/lib/is_arguments.js","webpack:///./app/src/main-process/menu/build-default-menu.ts","webpack:///./app/src/main-process/menu/find-menu-item.ts","webpack:///./app/src/main-process/menu/crash-menu.ts","webpack:///./app/src/lib/shell.ts","webpack:///./app/src/lib/parse-app-url.ts","webpack:///./app/src/lib/sanitize-branch.ts","webpack:///./app/src/main-process/squirrel-updater.ts","webpack:///./app/src/main-process/exception-reporting.ts","webpack:///./app/src/main-process/show-uncaught-exception.ts","webpack:///./app/src/main-process/crash-window.ts"],"names":[],"mappings":"0BACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,2BC7DA,kB,yBCuDA,aAEA,cAkGA,UACA,UAEA,aAkBA,OACA,4CAEA,yCACA,UAEA,aAiBA,OACA,4CAEA,yCACA,UAEA,oBAwBA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,CA7LA,OACA,gBACA,mBACA,oBACA,8BA6JA,OACA,WAEA,IA/JA,+BAgKA,OACA,WAEA,UAlKA,WACA,wBACA,kBAMA,yBACA,wBACA,wBAEA,WACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,QAaA,UACA,YACA,2BACA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,UAEA,iBACA,4BACA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,WACA,aACA,uBACA,OACA,UACA,qBAIA,MAFA,UAIA,kBAGA,MACA,QAEA,8BACA,wBAEA,OACA,mCACA,WAEA,IACA,GAZA,IAcA,uCAKA,OACA,SACA,eACA,WAEA,SACA,uCACA,uBAEA,eAeA,OACA,0CAEA,MACA,aAEA,iBAEA,eACA,YACA,YAEA,OACA,EAEA,UA7BA,wCACA,uBAEA,eAkCA,OACA,0CAEA,MACA,iBAEA,eACA,YAEA,UACA,EAEA,IA7CA,eAEA,sBAoDA,KAqBA,SApBA,SAsBA,aACA,yBACA,MACA,QAEA,YACA,SAEA,kCACA,sBAEA,KArQA,QACA,OACA,QACA,MAEA,UAKA,EAHA,WAEA,IAEA,sBACA,iDACA,kBACA,wBACA,yCACA,oBACA,QAEA,4CACA,iCACA,CACA,0BACA,EACA,GAEA,cACA,iBACA,0CAMA,MACA,gBACA,mBAAiC,qBACjC,8BAEA,IAEA,IACA,mCACA,UACA,GAAE,WAEF,oBACA,uBAAyC,kBAGzC,iBACA,WAEA,MADA,OACE,gCCrDF,UACA,UACA,iBAEA,aACA,iBACA,gBACA,oBACA,kBCRA,kB,qBCAA,kB,mBCAA,kB,yBCAA,kB,mBCAA,kB,0BCMA,CAEA,QACA,OACA,QACA,QACA,WACA,qBACA,WAUA,IACA,2BACA,CAEA,KA8BA,4CA7BA,OACA,KAGA,qBACA,SACA,yDAOA,mDAGA,OACA,4BAIA,gHAEA,6CACA,kBACA,UACA,EAEA,IAOA,EACA,4BACA,iBACA,MACA,sBAAyB,UAAiB,MAE1C,GAOA,EACA,mBAIA,OAEA,kBAGA,OAOA,SAPY,WACZ,0DACA,MACA,IAEA,sBAGA,SAEA,wBACA,wBAGA,kBACA,sBACA,sBAEA,iBACA,wBAEA,GACA,wBAGA,+BAIA,+CALA,KAMA,QAiBA,EACA,iBACA,OACA,iCACA,YACA,4BACA,+BACA,6DACA,eAEA,yBADA,OAMA,OACA,8BACA,YAAc,CAEd,uBACA,aAOA,0BACA,sBACA,cAEA,aAMA,wCACA,wBACA,YAAc,CAGd,uBACA,aACA,2BAEA,KAAwB,kBACxB,SAA0B,sBACN,eAEpB,6BAEA,OACA,cACA,0BACA,iBAGA,oBACA,8BACA,mBAGA,0BACA,SACA,GAEA,OACA,iCAGA,2CACA,oBACA,mBAEA,WACA,EAKA,IACA,wCACA,qBAGA,4BAEA,2DACA,sBACA,SAGA,uBACA,gBACA,+BACA,0BACA,4CACA,WAEA,kBACA,uCACA,YAGA,OACA,sBAEA,cACA,2BACA,0CACO,yBACP,uDACO,cACP,MACA,iCACA,4CACA,0BACA,6BACA,wBACA,oCAKA,SACA,eACA,eACA,eAGA,gCAEA,MACA,eAKA,aACA,UAEA,wBACA,sCACA,EAOA,EACA,kBACA,8CACA,MAKA,EACA,iBACA,2CACA,GAKA,EACA,sBACA,mBACA,aAQA,EACA,yBAEA,IACA,yBAEA,YACA,yBAGA,YACA,WAEA,OACA,aAEA,YACA,WAGA,SACA,8BAGA,uBACA,uDAGA,oBACA,YACA,YAEA,SAAiB,EAAY,QAC7B,2BACA,SAEA,2BAA8C,OAAO,IACrD,qBACA,cACA,OAIA,SACA,GACA,0BACA,iBAGA,0BAGA,UACA,OAEA,KAEA,CACA,QAOA,EACA,wBACA,qBACA,cACA,UACA,QACA,KACA,IAEA,SACA,sBAGA,QACA,gCACA,GACA,oBACA,cACA,QAEA,yCAGA,aAIA,YAFA,kBAMA,4BACA,UACA,iBAIA,8CACA,CAEA,KAQA,SAJA,YAFA,kBAGA,aAKA,kCAEA,aAKA,eAHA,WAIA,MAEA,IAGA,wCAGA,gBAGA,UAIc,sBAHd,kBACA,IAEA,EAAqB,IACrB,wBAEA,kBAKA,oBAHA,OAMA,aAEA,KAEA,KACA,GACA,EACA,GAMA,OACA,SAOA,EACA,gCACA,OACA,0BAEA,6EACA,sCACA,kBAEA,UAEA,MADA,UACG,gBACH,wBCxeA,CAEA,GAIA,KACA,gBAIA,QACA,eAIA,IACA,WACA,cACA,gBACA,kCACA,kBACA,eACA,qBAIA,UACA,4BACA,sBACA,kBAaA,UACA,gBASA,UACA,mBACA,8BAMA,WAeA,6BAdA,CACA,MACA,QACA,SACA,MACA,SACA,QACA,UACA,aACA,SACA,MACA,mBACA,qBACA,YAEA,oBACA,gBACA,qBACA,UACA,CAOA,GACA,gBACA,CAWA,SAVA,iDACA,iCACA,wCAEA,qBACA,+BACA,iCAGA,eAOA,EACA,uBACA,iBACA,YACA,YAKA,EACA,gCACA,eACA,UACA,KACA,iBACA,GAEA,qDACA,iBACA,OACA,EAMA,IACA,sFACA,2BACA,eACA,OACA,KACA,iBACA,CACA,MAEA,GAMA,GACA,kCACA,eACA,OACA,cACA,+BAEA,kBACC,iBCnKD,kB,0BC4BA,CAiCA,aACA,mBACA,kBACA,UACA,EAKA,SAFA,YACA,aAGA,CAgBA,YACA,OACA,cACA,0BACA,SACA,cAAmB,EAAa,IAChC,WAIA,oBACA,GAGA,wBAEA,YACA,SACA,SACA,6CAGA,MACA,SAEA,aACA,QACA,oBACA,iBACA,UACA,QACA,CAEA,MA3FA,SACA,YAEA,YAEA,iBACA,8BAEA,kBAEA,IACA,4CACA,eAEA,iCACA,oCACA,KAGA,6BACA,yBACA,KAEA,IACA,mCACA,IACA,uCAEA,wCACA,qBAcA,OACA,GAUA,gBATA,uCACA,uCACA,UACA,eACA,uBACA,UAEA,EACA,IAGA,mBAA4C,KAqC5C,sBACA,IACA,sBACA,2GACA,QACA,aACA,SAAK,SACL,CAEA,eADA,QAGA,KAEA,OAcA,mBACA,eACA,eACA,cACA,GAEA,EAWA,YAVA,cACA,UAEA,IACA,UACA,qBACA,mBACA,qBACA,sBAGA,iBACA,iBACA,YACA,UACA,CACA,MAEA,IArCA,UACA,OACA,GAQA,yCAPA,MACA,eACA,UACA,IAEA,EACA,K,oBC7IA,CAEA,QACA,QAQA,4BACA,qBAEA,WACA,iBACA,sBACA,+BACA,sBAOA,uBAEA,8BACA,6DACA,+CACA,mCAIA,EACA,eAOA,cACA,mCACA,CACA,QAMA,EACA,sCAMA,CA4BA,YAzBA,2BAGA,oBAGA,sBACA,MACA,8CAIA,oCACA,YACA,4CAKA,wBAGA,kBAEA,QASA,EACA,qCACA,CACA,QAUA,EACA,wCACA,aASA,KACA,sBACA,6BACA,WAEA,IAEA,OAfA,KAEA,cACA,OAGA,mBAUA,sBACA,oDAAyD,CACzD,mBCtHA,CAeA,aACA,SAEA,kBAGA,UACA,UACA,UACA,UACA,UAEA,IAPA,KAUA,aACA,OACA,GAiBA,SAhBA,qBAEA,QACA,OACA,iBAEA,OACA,YAEA,QACA,gBAEA,QACA,YAEA,QAeA,aACA,IACA,OACA,UACA,OACA,KAEA,aACA,IACA,aAEA,wBACA,sBAA8C,IAAQ,KACtD,MACA,KACA,mBACK,GACL,SACK,IACL,MAIA,mBACA,OAEA,eACA,GAIA,sBAEA,KACA,iBAIA,UACA,OAGA,QA+GA,aACA,CACA,QAUA,CAmBA,aACA,IACA,GAGA,iBAEA,UACA,IAGA,YACA,wBACA,wBACA,yBACA,yBACA,yBACA,yBACA,yBACA,wBACA,uBAGA,qBAA2B,GAAQ,KACnC,OACA,qBAIA,SACA,QASA,CAsEA,eACA,OACA,OAGA,EACA,IAGA,GACA,CAKA,CAzWA,SATA,eACA,IACA,aACG,SACH,qBAEA,+BAEA,8BAGA,MACA,mFAeA,aAsBA,EAYA,cA4CA,EAiBA,YA0CA,OAzCA,aACA,CACA,WAEA,KACA,WAEA,WACA,OAEA,sBAIA,WAEA,6BAEA,QAGA,aACA,SAIA,2BACA,cACA,OAGA,WAEA,2CAGA,mBACA,OAGA,SAGA,wBACA,8BACA,QAOA,EAiCA,WAhCA,aACA,CACA,WAGA,uBAMA,cACA,0BACA,oBACA,KACA,IAMA,sBACA,aACA,qBAGA,SACA,GAGA,iDACA,IAGA,gBACA,qBACA,cACA,gBAAC,IAsBD,kBAPA,WACA,OACA,MAIA,SAUA,oBAPA,WACA,OACA,cAIA,MAuEA,EAUA,2BAtCA,eACA,kBACA,aAIA,0BACA,aAIA,8BACA,eAIA,kCACA,gBAIA,6BACA,cAIA,cACA,WAwCA,sCA5BA,eACA,yBACA,oBAIA,6BACA,gBAIA,yBACA,OAIA,4BACA,aAIA,8BACA,eAIA,cACA,WA+CA,sCA5BA,aACA,yBACA,oBAIA,6BACA,gBAIA,wBACA,QAIA,6BACA,aAIA,+BACA,eAIA,iBACA,6BC/ZA,aAEA,cAWA,UACA,CACA,OAPA,aACA,UACA,mDACA,IAKA,WAZA,WACA,kBACA,oCCNA,WACA,aAEA,oBAEA,4BAEA,IAAC,4CCSwC,aACvC,CAAa,KACI,GAAwB,WAAzC,YACM,aAAK,GACZ,SAWE,CACoC,aACrC,MAAgB,MAAc,GAAW,WAAgB,gBAC/C,CAEQ,WACZ,oBACO,oBACJ,cAEF,iBACG,OAGV,aAAmB,KAAc,GAAW,WAAQ,QAC7C,CAAkD,MAGlD,mBAAU,UACL,YAGN,QAAQ,EACf,IAaD,YAKe,kBAAc,SAAoC,OAC7D,MAAkB,GAAG,EAErB,wBAA2B,iBACpB,KAAC,IACJ,IACE,MAAY,GAAoB,EACzB,MACR,KAAY,QACL,CAEV,IAAE,IACI,MAAM,KACJ,CAEZ,IAAE,EAGH,KAUE,kDApGH,UACA,OAEA,OAEA,QAAkD,IAE3C,EAKJ,KACH,KAAiB,GAEgD,GAyCjE,GAAiB,GAUd,KAmCH,EAqBC,IArByD,mBACxD,IACE,MAAY,GAAG,KACf,cAAiB,SAAuB,OAChC,CAAe,MAAO,KAElB,GAGR,KAEJ,GACF,EAAC,GAAc,QASjB,CAAC,mBCpHD,CAmDA,aACA,4CAEA,GAOA,4BANA,kBACA,UAAmB,MAAiB,OACpC,cAEA,KACA,KA1DA,QAEA,IACA,aAEA,GACA,sBAEA,uBACA,CACA,QAEA,wBACA,yBAEA,QACA,sBACA,0BAAgD,OAAO,IACvD,QAGA,qCACA,sBACA,SAAmB,MAAqB,OACxC,QAEA,SACA,MAEA,UAGA,SACA,QAIA,EACA,YACA,YACA,WAIA,IACA,0BACA,0BACA,4GCvDA,UACA,QACA,OACA,OACA,QAEA,KAAY,EAAU,EAOnB,KACH,EAkBG,cAlBgD,WAC3C,WAAY,SAAuB,OACrC,GAAoB,QACjB,KAAI,GACC,QADM,KAAK,SAKrB,UAEJ,KAAC,IASD,EAmBG,UAjBQ,aACT,EAAiE,GAE3D,WAAY,SAAuB,OACrC,GAA8B,gBAAK,KAE3B,GAGR,KAEJ,GACF,EAAC,IAMD,EAmBG,gBAnByC,WACpC,WAAY,SAAyB,OACzC,MAAa,GAAO,EAAK,KAAG,EAAW,SAAW,IAChD,OAAgB,UAAiB,OAC9B,CACK,KACF,SACJ,MAAc,GAAO,EACd,UAEX,IACF,CACF,EAAC,IAQD,EA4BG,WA1ByB,aAE1B,MAAY,GAAG,GAAI,GACnB,UAAgB,IAAyB,gBAAO,KACxC,CAAQ,KAAG,GAAO,OAAiB,KACpC,KAAW,EAId,eAAU,GAAS,EACjB,WAEN,KAAE,EAEI,YAEA,WAAK,GAAU,WAAC,IACV,GACJ,YAEV,MAAC,IAOD,EAUC,WAVsC,WAC/B,WAAY,SAA0B,KACxC,GAAU,OAAe,KAEhB,GAEA,MAGb,KACF,EAAC,qBChHD,aAQA,mBACA,CACA,sBACA,MACG,SACH,wBAAY,CASZ,iBACA,eAEA,MACA,0BAEA,eAEA,sBACA,MAEA,4BACA,IACA,YACA,OAEA,iBACA,UACA,mCACA,8BACA,GACA,OACA,UACA,GAKA,MACA,wBAGA,qBACA,SACA,OAGA,IACA,GA1DA,UACA,OACA,WAEA,sCAwDA,6BC9DA,aAQA,iBACA,IACA,uBAAY,CAGZ,iBACA,eAQA,MACA,0BAEA,eAEA,UAEA,cACA,GACA,iBACA,IAAG,SACH,UACA,UACA,6BACA,cACA,gBACA,SAKA,MACA,WACA,MACA,KACA,WAAS,SACT,CACA,OACA,qBAGA,SAEA,CACA,SAtDA,UACA,OACA,WAEA,sCAoDA,6BC1DA,aAEA,cAEA,UAEA,YACA,oBACA,wBACA,4BACA,yBACA,sBACA,0BACA,8BACA,qBACA,gBCfA,WACA,IAEA,yBACA,cAYA,MACA,gBAEA,CAYA,mBAzBA,sCACA,OACA,4CAOA,gCAKA,MACA,gBACA,YACA,6CAEA,qCAEA,KAEA,GAIA,GAAC,6BCjCD,MAOA,aAEA,cA0BA,IACA,uBACA,sBACA,gCACA,eACA,UACA,CAIA,OAnCA,gBAGA,IAEA,oCACA,OAEA,uCACA,OAGA,OAGA,KACA,cAGA,8BACA,CAEA,SADA,SAGA,yBAaA,qCACA,OACA,4BAEA,iBACA,YACA,MAEA,OACA,SAEA,SAEA,iBACA,YACA,MACA,SAEA,SACA,cAEA,UACA,QAEA,mBACA,CAIA,0BAHA,GACA,UACA,IAGA,iBACA,mBACA,GACA,OACA,EAEA,4BACA,OACA,UACA,UACA,qBAGA,QACA,QAEA,iBACA,MACA,SACA,MAGA,WACA,WAEA,eAEA,SACA,cAEA,KACA,QAOA,EACA,EACA,oCAGA,mDAEA,6BAgBA,qCAEA,CACA,IAGA,IAIA,mCAxBA,CACA,IACA,mBAGA,iCACA,cACA,EACA,mBAIA,gCAaA,cAUA,IACA,KAGA,SACA,OACA,QAGA,IACA,MAnBA,QACA,aAEA,WACA,iBACA,KACA,KACA,EAaA,cAEA,iCACA,MACA,QACA,aAEA,WACA,cACA,mBAEA,IACA,KAGA,SACA,OACA,OAGA,IAGA,IACA,EACA,EACA,GACA,oBAGA,wCACA,OACA,kBACA,QACA,mBAEA,2BAEA,uBACA,MACA,gBACA,WAEA,WACA,IACA,IAEA,eACA,SACA,aAGA,mBACA,WACA,KACA,sBAEA,IACA,KAGA,SACA,KACA,OACA,OAGA,IAGA,IAEA,EACA,IACA,CAIA,sCACA,iBACA,uBACA,SAEA,iCAGA,qBAEA,IACA,kBAEA,OACA,EACA,SAGA,MACA,EACA,GAbA,GAeA,kDACA,iBACA,QACA,SACA,UACA,SAEA,WACA,cACA,IACA,QACA,yBAEA,IACA,kBAGA,OACA,EACA,OAIA,UAGA,YAIA,IACA,GACA,IACA,EACA,GAIA,kDACA,CACA,WAEA,mBAEA,uBACA,iBACA,QACA,SACA,cACA,WAEA,WACA,IACA,IAEA,eACA,IACA,WAGA,oBACA,IACA,KACA,YACA,uBAEA,IACA,kBAGA,OACA,KACA,EACA,KAGA,IAGA,IACA,EACA,CACA,IACA,CAGA,eACA,kBACA,SACA,wCACA,UACA,CACA,iBACA,kBACA,SACA,sCACA,UACA,CACA,eACA,kBACA,SACA,8CACA,UACA,CAGA,qBACA,uBACA,QAAoB,QACpB,QACA,GACA,oBACA,sBACA,CACA,IACA,EACS,OACT,OACA,oBACA,wBACA,KACA,SACA,IACA,EAAa,aACb,CACA,MACA,EACA,CACA,QACA,iBACA,iCACA,OACA,YAEA,mBACA,OACA,OAIA,4BACA,6BACA,oBACA,CACA,IACA,IACA,EAAS,aACT,CACA,MACA,EAEA,aAEA,iBAEA,sCACA,sBACA,CACA,QAAS,GACT,YACA,eAEA,YAEA,mCACA,OACA,sBACA,QAAoB,QACpB,QACA,oBACA,sBAEA,MAEA,QACA,GACA,EAAS,YACT,yBACA,kBACA,KAAa,cACb,UACA,KACA,GACA,EACA,WACA,oBAEA,gBACA,wBAEA,oCACA,OACA,sBACA,QAAoB,QACpB,QACA,oBACA,sBAEA,MAEA,QACA,GACA,EAAS,YACT,yBACA,kBACA,KAAa,cACb,UACA,KACA,GACA,EACA,WACA,oBAEA,4BACA,kBACA,gBAEA,IACA,KAGA,KAEA,GACA,EAAS,YACT,CACA,GACA,EACA,WACA,oBAEA,2BACA,uBACA,gBAEA,KACA,MAEA,KACA,GACA,EAAS,YACT,CACA,KACA,EAEA,UAEA,4BACA,uBACA,gBAEA,KACA,MAEA,KACA,GACA,EAAS,YACT,CACA,KACA,EAEA,UAEA,8BACA,sBACA,kBAEA,GAGA,aAAoC,QAEpC,YACA,EAAS,eACT,CACA,WAGA,mCACA,sBACA,6BACA,CACA,cACA,UACA,KAEA,GACA,EAEA,sBACA,GACA,WACA,SACA,UACA,SAGA,WAEA,KACA,gBACA,GACA,UACA,eACA,WAA2B,MAAsB,UACjD,KACA,SAIA,uBAHA,EAIA,cACA,CACA,4BACA,CACA,GACA,EAEA,cACA,OACA,IAEA,KAEA,MACA,OACA,CAEA,kBACA,yBACA,mBACA,mBACA,MACA,kBAEA,MACA,OACA,qBACA,MACA,IACA,GACA,OAEA,OACA,GAEA,KACA,UAEA,eACA,qCAEA,OACA,OACA,OACA,UACA,uBAEA,2CACA,2BAEA,0BACA,iBACA,yBACA,aACA,iBAAiB,UACjB,iBACA,KACA,eAEA,YACA,iBACA,CACA,MACA,gBAEA,QACA,EACA,IACA,CACA,EAEA,yBACA,OACA,IAEA,GACA,uBACA,IACA,IAGA,kBACA,0BACA,wBACA,mBACA,gBACA,UAA8D,MAC9D,UACA,IACA,CAEA,qBAEA,6BACA,cACA,kBACA,OACA,EAEA,WACA,KAEA,2BACA,MACA,WACA,iBACA,mEACA,KACA,OACA,aAEA,sBACA,mBACA,CACA,kBACA,WAEA,QACA,mBACA,OAEA,gBAGA,QAEA,iCACA,SACA,OACA,EACA,CACA,CACA,MACA,cAEA,uBACA,MACA,KACA,0BAEA,iBACA,mBACA,GACA,kBAEA,WACA,SAEA,EAEA,SACA,OACA,4BACA,iBACA,mBACA,GACA,kBAEA,IACA,OACA,IACA,EAAa,aACb,CACA,MACA,EACA,CAEA,0BACA,GAAmB,kBACnB,UAEA,iCACA,GAAmB,eACnB,UAEA,wBACA,MACA,KACA,gCAEA,iBACA,mBACA,GACA,kBAEA,WACA,SAEA,EAEA,SACA,OACA,kCACA,iBACA,mBACA,GACA,kBAEA,IACA,OACA,IACA,EAAa,aACb,CACA,MACA,EACA,CAEA,wBACA,kBACA,iBACA,UACA,wBAEA,aACA,MACA,EAIA,wBAHA,4BACA,IACA,GAEA,WACA,EAEA,qBACA,mBACA,oBACA,UACA,sBAEA,YACA,CAEA,yBACA,OACA,oBACA,kBACA,eACA,IACA,IACA,EAAS,aACT,CACA,MACA,EACA,WACA,oBAEA,6BACA,CACA,iBAEA,UAEA,YACA,aAGA,GAEA,GAEA,4BACA,cACA,CACA,WAEA,wBACA,WACA,UAGA,gBAEA,GACA,EAEA,yBACA,CACA,IAUA,iBARA,UAEA,YACA,YAGA,EAIA,2BACA,cACA,CACA,WAEA,wBACA,WACA,QAKA,MAFA,cAGA,EAEA,uBACA,oBAOA,UACA,YAEA,YACA,SAEA,KAEA,sCACA,GACA,SAEA,OAEA,uBACA,OACA,CACA,uCAIA,gBAEA,mBAGA,wCACA,eAEA,6BACA,QACA,EAEA,IAvCA,aAEA,UACA,sBAEA,sCAmCA,IACA,OACA,GACA,wBACA,WACA,WACA,KACA,WACA,4BACA,CACA,WACA,iBACA,SACA,aACA,EACA,uBACA,CACA,WACA,oBACA,+CACA,eACA,iBACA,sBAEA,WACA,kBACA,IACA,IACA,6BAEA,oBACA,wBAEA,UACA,SACA,IACA,SACA,OACA,CACA,mBACA,gBACA,MACA,oBACA,CACA,QACA,iBACA,OACA,qBACA,kBACA,QACA,WACA,UACA,mBACA,WACA,UACA,mDAGA,UAA+B,EAAkB,KACjD,qBAEA,SAEA,GACA,QAEA,+BAEA,gBACA,qBACA,QAEA,kBACA,YACA,aACA,IACA,kBACA,GACA,aAEA,QAGA,EACA,QAEA,oBACA,UACA,YAEA,YACA,SAEA,KAEA,sCACA,GACA,SAEA,OAEA,uBACA,OACA,CACA,OACA,2CAGA,sCAEA,qCACA,eAEA,6BACA,QACA,EAGA,SAGA,WAQA,6BAPA,CACA,UAGA,WAEA,SAGA,uBACA,IACA,QAEA,KACA,CACA,QACA,oBACA,WACA,WACA,KACA,6BACA,CACA,SAEA,oBACA,QACA,CACA,uCAEA,SACA,0BACA,cAEA,WACA,oBACA,QACA,sBACA,CACA,UACA,aAKA,8BAJA,eACA,kBAIA,4BACA,kBAEA,yBACA,UACA,IAEA,cACA,QACA,mBACA,CAEA,WACA,yBACA,GACA,2BAEA,OAEA,GACA,GACA,GACA,mBACA,UACA,MACA,oBACA,CACA,QAEA,GACA,QAEA,mBACA,mBACA,mBACA,qCACA,mBACA,GAEA,wCACA,eAGA,SACA,2BACA,CACA,aAGA,GACA,IACA,CACA,UACA,eAKA,8BACA,OACA,KACA,mBACA,CACA,QACA,kBACA,SACA,eACA,gBACA,QACA,4BACA,cACA,KAEA,GACA,YAGA,cACA,qCACA,QACA,iBACA,WACA,sBAAiD,OAAO,IACxD,oBAEA,UAEA,KACA,EAGA,SAFA,SACA,cAGA,yBACA,kBACA,oCACA,UACA,CAEA,yBACA,WACA,KAAuB,EAAW,IAClC,MAEA,iBACA,UAEA,+BACA,WACA,KAAuB,EAAW,IAClC,MAEA,iBACA,gBAEA,kBACA,OACA,2BACA,OACA,SACA,eACA,kCACA,+BACA,iBACA,iBACA,GACA,MACA,IACA,eACA,eACA,UACA,EACA,CAEA,sBACA,sDACA,WAEA,qBACA,iBACA,OACA,SACA,eACA,8BACA,oBACA,KAEA,IACA,wBACA,mBACA,kBACA,OAEA,CAEA,QACA,cACA,uBAEA,4BACA,cACA,MACA,CACA,WAEA,MACA,OACA,CACA,IACA,CACA,GAGA,2BACA,UAIA,4BACA,CACA,QAAS,8BAOT,YAAC,kBClwCD,kB,wBCMA,CAEA,QACA,OAEA,QAEA,wBACA,OACA,iBACA,qBACA,sBACA,oBACA,yCAEA,QAEA,2BACA,OACA,aACA,wCACA,yCACA,iBACA,uBACA,yBACA,qBACA,yBAEA,gBAEA,sBACA,OACA,WACA,mBAEA,WAEA,sBACA,sBACA,8BACA,OACA,UACA,yBACA,yBACA,yBACA,yBACA,yBAEA,WACA,mFCvDA,UACA,OAA8B,GAE9B,GAAoB,GAAsB,KAE1C,EAOC,oBAPD,UACK,IAAmB,GACpB,MAAc,GAAG,EAAG,IAAQ,QACZ,cAAO,EAAc,OACtC,OAEK,CACP,2BCZD,aAEA,UAEA,MACA,OAEA,GACA,4BACA,MACA,IAAC,GAED,UAEA,WACA,WACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WAEA,EAEA,UACA,WACA,iCACA,WACA,gBACA,GACA,QACC,IAED,sCCpCA,aAEA,WAEA,UAEA,WACA,cACA,mBAEA,wBACA,cAAgB,aAEhB,oCAEA,MAKA,wDAJA,kCACA,8BAEA,sBCnBA,kB,0BCAA,CAEA,QACA,OACA,WAqOA,UAnOA,iBAEA,cA2BA,CAEA,GADA,qBAEA,yBACA,+EACA,cAEO,gBACP,uBACA,aAIA,aACA,KAEA,cACA,kBACA,MACA,qBACA,YAGA,YACA,CACA,cACA,aACA,cACA,MAGA,cACA,oBACO,kDACP,gBACO,OAEP,iBAEA,WACA,EAEA,cACA,sCACA,wBAEA,GAGA,uBACA,CACA,MAEA,mBAEA,oBAGA,GACA,EAEA,gBACA,4BACA,8BAAoD,QAEpD,YACA,gBAGA,aAEA,+BACA,GACA,OAGA,4BACA,6BACA,UAEA,wDACA,UACA,KACA,GAEA,GAEA,IACA,EACA,EAEA,gBACA,uBACA,UACA,KACA,GACA,EAEA,cACA,sCACA,wBAEA,UAEA,gBACA,KACA,EAEA,gBACA,6BACA,UAGA,sCACA,UACA,cACA,KACA,EACA,EAEA,cACA,0BACA,UACA,2BACA,KACA,UACA,GACA,IACA,EAEA,cACA,SACA,uCACA,UACA,SACA,OACA,EAEA,gBAEA,SAEA,6BAEA,UAEA,sCACA,UAGA,cAEA,cACA,MAEA,kBACA,CACA,MACA,GACA,EACA,EAEA,gBACA,0BACA,UACA,KACA,GACA,EAEA,gBACA,sBAEA,4BACA,MAEA,MACA,KACA,EAEA,cAEA,QACA,iBACA,MAEA,IAEA,cACA,OACA,IACA,UACA,MACA,oBAGA,KACA,KA9NA,MAGA,kBACA,UACA,iBAEA,iBACA,WACA,cAEA,2BACA,sBACA,cACA,iBACA,qBAEA,qBACA,IACA,IAEA,EAEA,KAEA,uBClCA,aAKA,aACA,4CACA,kBACA,GACA,IAIA,CAXA,UAEA,iBAiBA,UACA,CACA,cACA,iBATA,WACA,SACA,0BACA,MACA,2BCnBA,UACA,YACA,sBCmHA,aAEA,CAGA,yCAFA,+BACA,KAGA,CA5HA,MACA,GACA,KACA,EAAC,SACD,KACA,GA+HA,UAPA,QACA,KACA,SAxHA,eACA,CACA,UACA,MAGA,IACA,wBAGA,kBACA,WAEA,MAEA,KACA,4BACG,kBACH,mBAGA,oCACA,YAEA,QAEA,QACA,MACA,4BACA,KAAK,SAEL,8BACA,QAEA,aAEA,KAEA,GACA,OACA,IAiFA,aA/EA,aACA,MACA,GACA,wBAGA,qBAEA,MAEA,KACA,4BACG,kBACH,mBAGA,gBACA,oBAEA,QACA,uBACA,QAAG,SACH,CACA,KAGA,yBAFA,qBAIA,KACA,GAmDA,UAjDA,iBACA,CACA,UACA,MAEA,SACA,WAEA,4BACA,SACA,2BACA,YAEA,SACA,MACA,yCACA,IAAG,SACH,iBACA,KAEA,GACA,oBA6BA,cA3BA,eACA,MACA,WAEA,4BACA,SACA,2BACA,YAEA,wCAEA,cACA,wCCnHA,aAEA,UACA,OACA,OACA,WAYA,UAVA,eACA,WAEA,aACA,iBAGA,gBACA,uCCfA,aAEA,UACA,OACA,OACA,WAoBA,UAlBA,iBACA,CACA,uBACA,MAGA,cAEA,sBACA,SAEA,mCACA,OACA,YAGA,qGCvBA,UAKG,IACH,EAUC,YAVuD,aACjD,UAAG,EAEL,yBAAM,EACD,MAAS,EAAQ,SAAU,EAAQ,QAAQ,EAAM,MAEjD,OACF,EAAQ,SAAU,EAAK,SAAU,EACjC,aAAQ,EAAK,SAAU,EAC7B,OACD,kCCCwC,aAGpC,IAAC,CAAwB,EAAK,KAAK,KAAU,EACxC,mBAIL,MAAO,EAAW,WACb,eAIR,WAAa,GAAe,IAqBzB,OAAC,GAAG,EAIP,iBAEE,MAAS,GAAK,EAAkB,eAC1B,cAAC,CAAK,IAAM,EAAe,YAClC,OAAc,QAGjB,CAAC,CAGD,CAemE,eACpD,UAKP,SAAM,EAAS,EAAI,IAAU,KAAoB,iBAAK,KAC7D,GAEuD,CA4BZ,aAC1C,IAAU,GAAgB,EAUvB,mBAAM,EAAM,OAAO,IACd,aAAgB,EAIhB,UAIT,OAJe,EAGR,K,kDAxIR,UACA,OAEA,GAAmB,EAAmC,EACtD,KAAsB,EAAU,EAWhC,KAA6B,EAAG,CAAc,cAAY,WAkDvC,EAAG,GAKnB,SACH,GAQG,GAWH,EAiBG,iBAjBH,UACkB,GAAQ,QACX,aACa,OAExB,4BAEF,2BAAc,GAGgB,QAAW,EACjC,oBACT,qBAMD,EAQuD,sBARL,WAC1C,OACA,MAAO,EACJ,aAAO,EACT,cAER,uBC7GD,CAeA,aAEA,OAEA,iCACA,+CACA,sCACA,mCACA,kBACA,qBACA,4BACA,KAxBA,QACA,QACA,YACA,kBASA,YAcA,qBAMA,EACA,EACA,yBACA,SACA,mBACA,QACA,KAEA,eAiCA,gCAhCA,OACA,WACA,QACA,uBAIA,kBACA,4BACA,OACA,kCAGA,oBACA,QACA,sBAGA,gBACA,wBAIA,SACA,aACA,gCACA,SACA,oBACA,WAEA,qBACA,IAYA,EACA,YACA,sBACA,kBACA,qCACA,4BACA,0BAEA,WACA,sBAGA,0BACA,UACA,sBACA,sBAIA,QACA,UACA,oBACA,oBAIA,2BACA,iBACA,uBACA,+BACA,+BACA,OACA,SAEA,QAIA,EACA,YACA,8BACA,IACA,KACA,2CAGA,gBAGA,aAOA,kDACA,gBACA,sEAGA,cAXA,uDAEA,+BACK,kBAyBL,EACA,YACA,8BACA,IAEA,gBACA,IACA,sBACA,OACA,wFAGA,gEACA,IACA,YAEA,YACA,cAIA,qBACA,QAGA,gDACA,uCAEA,6BACA,QACA,sBAEA,iBAEA,4BACA,OACA,8BAEA,SACA,kCAEA,0BACA,wBACA,OACA,wBAGA,MAEA,SACA,kBACA,UAGA,eACA,gBACA,UAGA,MAAK,EACL,WACA,gBAGA,sCACA,SACA,oBACA,UACA,cAEA,WACA,cAEA,oBAEA,sBAAK,EACL,KAYA,EACA,YACA,iBACA,iBACA,qBACA,wBACA,qBAIA,sBACA,6BACA,wBACA,uBAMA,mEACA,CACA,YACA,SACA,WAGA,SAKA,EACA,YACA,6BACA,WACA,IACA,IACA,IACA,IACA,IACA,IACA,oBAMA,kBAA0C,OAL1C,EACA,EACA,EAEA,EACmD,QACnD,MACA,OAEA,KACA,wBACA,IACA,sBACA,IAIA,gBACA,iDACA,IAEA,YACA,GAGA,eAEA,uBAEA,gBACA,2CACA,oBACA,KAGA,+BAEA,sBAEA,gBAEA,sBAEA,eACA,uCACA,kBACA,KAIA,MACA,IAEA,CACA,UAEA,YACA,qCACA,yBACA,UACA,uBAEA,MACA,cAEA,uBACA,gEACA,yBACA,oBACA,IAAK,EACL,KAIA,EACA,YACA,iBACA,OACA,cACA,+BACA,4BACA,wBAEA,sBAWA,MAVA,gCAEA,OACA,2CAEA,kBACA,6EAGA,cAKA,EACA,YACA,mBACA,4BACA,WAEA,uCChXA,CAiCA,aACA,OACA,aACA,SACA,CAOA,CACA,aACA,UAEA,QADA,SAEA,CAEA,IAIA,CArDA,QAcA,OAGA,IAGA,SAGA,EAOA,IAwBA,oBACA,OACA,KAIA,KAFA,EAGA,KACA,IACA,OAGA,MAEA,WACG,gBAEH,KACA,QAKA,EACA,wBACA,SACA,SACA,IACA,IAEA,IACA,IACA,qBAGA,yEACA,OACA,0DAGA,SACA,KACA,QACA,KACA,IAEA,kBACA,OACA,wBCtIA,CAWA,YACA,aACA,2BACA,KAIA,CAhBA,QACA,uBAOA,eASA,yBACA,WACA,cAAsC,OAAS,IAC/C,UAEA,QACA,QAOA,EACA,2BACA,8CACA,MAMA,EACA,6BACA,SACA,6BACA,sBACA,QACA,oBAGA,iBAEA,UAMA,EACA,2BACA,SACA,kCACA,OAMA,EACA,+BACA,SACA,8BACA,oBAEA,8BACA,uBAMA,EACA,0BACA,wBACA,mBAEA,0BACA,2BAMA,EACA,8BACA,oBACA,SAEA,yCC/CoB,eAEZ,GAAY,YAAK,KAAC,EACzB,yB,uCA3DwE,WAC5D,EAAsB,uBAAyB,uBAS5D,EAiBG,eAjB0D,WACxD,OAAO,GACF,eACF,cAAW,EACT,cACF,YAAW,EACT,cACG,YAAO,EACV,YAIT,SAFS,UAQV,EAyBG,iCAxB6B,WAExB,GAAG,GAAoB,oBAAE,IACF,IAQvB,kBAAG,GAAoB,oBAAE,IAAiC,IAE1D,aAAG,GAAW,WAAE,IAAiC,IACjD,gBAAG,GAAW,WAAE,IAAiC,IACjD,gBAAG,GAAa,aAAE,IAAiC,IACnD,aAAG,GAAU,UAAE,IAAiC,IAChD,aAAG,GAAO,OAAE,IAAiC,IAC7C,aAAG,GAAO,OAAE,IAAiC,IACpD,8EChDqB,WACtB,EAgBG,WAhBmC,WACpC,MAAM,IACP,WAeD,EAEC,YAFoD,aACnD,MAAM,IACP,6ECdE,WACH,EAGC,IAHD,UACE,MAAU,GAAU,QACd,eAAK,OAAU,GAAO,EAC7B,qJCVD,IAAoC,MACpC,IAAiC,KACjC,IAAgC,MAGhC,IAA4B,kCCLoC,aACxD,OAAS,GAAG,IAAY,EAAM,OAAY,EAAK,MACtD,SAYE,CAE2D,aACtD,EAAM,IACL,EAAG,GAAiB,KAEvB,KAAC,KAAuB,QAC1B,IAAW,GACX,EAAM,EAAO,EAGV,MAGD,GACO,KAAS,QAAmB,OAAY,KAC/C,EAAC,SAAe,EAGd,aACG,OAEJ,OAAK,EAAS,QACf,MAAqB,GAAO,EAGf,QAAgB,IAAM,EAEvC,KACF,CAAC,mDA5BD,EA4BC,+FC3CD,UACA,QAUG,GACH,EAYC,kBAZ6C,WAC7B,CACb,MAAkB,KAAa,OACrB,CACA,oBACD,QAGT,eAAK,MACD,eAGP,gBCxBD,kB,oBCAA,kB,+CCqC6C,aAChC,CAGC,WACA,YAGZ,WAAmB,GACnB,KACD,2BA4BgC,aAC/B,MAAY,GAAG,EACN,iBAAO,KAGR,GACA,UAEV,gBAAC,GA2QD,YACE,MAAY,GAAG,GAAI,GAeb,YAAQ,QAAC,IACH,GAIV,OAEI,KAAU,UAAC,IACT,GACA,SAAsB,sBACb,CACL,yBAAQ,EACC,2BAAQ,EAG3B,yBACY,OACR,SAAC,KACD,QAEJ,IAEI,KAEI,OACX,GAKE,CAC+B,aAElB,KAGR,WAGP,I,kDArZD,EAAoC,IAEpC,UACA,OAEA,OACA,SACA,QACA,SACA,SACA,SAIA,QACA,QACA,QACA,SAIA,QACA,QAAiE,KAEjE,EAAkB,mBAElB,GAAc,GAAyB,KAEvC,KAAgB,GAAG,EAAK,MAExB,GACA,MAAa,EAIb,KAAgB,EAAgC,GAczC,QAAG,GAAoB,oBAAe,KACtC,GAAG,EAER,2BACuB,eACvB,OAEF,GAiBC,MAYD,GAKqB,cAAM,IAAmB,mBAAwB,KAG7D,KAAW,EACF,iBAGT,UAAC,CAAW,EACH,eAGF,SAGT,SACW,CADN,GAAO,UACI,EAEnB,GAGA,QAAG,IAIJ,QAAC,EAAkB,mBACpB,YACD,8BAED,EAAG,IAAG,GAAwB,wBAAE,IAC9B,GAAG,IAAG,GAAW,WAAa,OACvB,GAEO,iBAEhB,IAAE,KAEF,EAAG,IAAG,GAAQ,QAAE,IACX,IAEH,KAES,SAAG,EAEZ,UAAG,IAA2B,2BAK5B,qBAAG,IAA2B,2BAK9B,2BAAG,IAA2B,2BAKlB,cAEd,OAAQ,GAAG,EACX,qBAAI,KAEJ,wBAAO,QAAG,GAC+B,wCAGK,OAEtC,GAAG,EAAgB,iBAAO,EAAO,OAAQ,EAC7C,SAAI,KAEQ,2BAGf,aAED,KAAO,QAAG,GAAa,aAA+C,KACpE,MAAM,CAEM,eAEZ,gBAMF,KAAO,QAAG,GACW,oBACa,GAAE,CAAsB,QACtD,MAAc,GAAG,EACd,sBAAU,KACX,MAAY,GAAG,EAAa,cAAgB,gBAAM,EAClD,QAAe,EAAG,CAAgB,eAAE,IAAQ,GAAQ,OAAO,EACnD,UAAwB,UAAO,EAE3C,OACD,CAED,KAAO,QAAG,GACW,oBAGkC,OAEnD,IAEI,UAAC,KAAoB,QACvB,MAAM,CAAI,KACV,WAAc,EAAG,EAMZ,wBACI,EAAsB,kBACnB,EAAQ,UAAU,EAElB,YAAQ,QAAQ,EACJ,QAGtB,QAAW,WACb,qBACD,GAEE,CACS,QAGf,aAED,KAAO,QAAG,GACc,uBACqC,OACzD,MAAU,GAAG,GAAI,GACjB,KAAe,IAAY,IACnB,UAAK,GAAQ,SACZ,OAAM,EACN,YAAE,IAAW,EAAO,OAAK,KAC1B,iCAAM,EACH,aAAM,EAIb,eAAC,KACC,UAGN,eAAY,GAAG,EAAa,cAAgB,gBAAM,EAC9C,UAAa,QAAE,CAEtB,UAMD,KAAO,QAAG,GAAe,eAAE,IAEb,MAEZ,aAEF,KAAO,QAAG,GACuB,gCAEE,GAC/B,CACa,cAE4C,aAI9C,GAAO,KACR,GAEV,+BAEH,EAED,KAAO,QAAG,GACH,MAC6D,SAChE,GAEH,QAED,KAAO,QAAG,GACY,qBAC0B,OACrB,CAE1B,IAED,KAAO,QAAG,GACW,oBAEc,GAC/B,CAAO,QAA6D,WAEpE,GAEH,gBAED,KAAO,QAAG,GACO,gBACiB,GAAE,CAA0B,UAC1D,MAAY,GAAG,EAAK,MACf,kBAAO,OAAK,KAAuB,uBAAE,CAE7C,UAED,KAAO,QAAG,GACa,sBACW,GAAE,CAA0B,UACxD,GAAU,OAEL,kBAAO,MAAkC,4BAI3C,YAAM,EACP,gBAEA,uBAAK,MAKf,qBAAE,KAEF,EAAG,IAAG,GAAW,WAAE,IACR,GAAO,KACR,GAEV,MAAE,KAEF,EAAG,IAAG,GAAuB,uBAAkB,OACrC,GAAG,GAAa,aAAa,OAE9B,GACF,qBAAM,KACX,6BACF,GAAE,KAEF,EAAG,IAAG,GACe,oBACmC,eAC5C,CAEC,QAAO,KACR,GAEV,2BACD,oFC5VD,UACA,QAEA,KAAO,EAAgB,OAEtB,EAAI,IACE,CAA+B,UAClC,GAAG,IAAQ,QAAW,UAAG,EAC1B,sBACG,EAA+B,SACjC,GAAG,IAAO,OAAW,UAAG,EACzB,sBACG,EAA+B,SACjC,GAAG,IAAO,OAAW,UAAG,EACzB,sBACI,EAA+B,UAClC,GAAG,IAAQ,QAAW,UAAG,EAE5B,sBAbuB,gBCLxB,WAAkB,SAAW,yPAAgR,qHAA0H,eAAe,yPAAgR,6PAAkQ,6BAA6D,mCAAS,IAAoD,6DAAiB,wFAA0G,4FAAwF,oEAAgF,kBAAY,KAAmB,uKAAqK,4BAAoD,sBAAE,0BAAsD,8DAA4C,UAAipyB,yi2BAAqrD,eAAkE,yDAAY,KAA+B,iC,yBCMpn5B,CAEA,kCACA,CACA,gBACA,4BACA,cACA,OACC,IACD,+BACA,CACA,gBACA,4BACA,cACA,IACC,IACD,+BACA,CACA,gBACA,4BACA,cACA,IACC,IACD,iCACA,CACA,gBACA,4BACA,cACA,MACC,oBC7BD,CAEA,QACA,QACA,OACA,OACA,WAQA,iCACA,QACA,aAEA,eACA,yBACA,gCACA,kEACA,oDACA,8BACA,qBACA,iCACA,kBACA,yCAgBA,OACA,6DACA,CAKA,qBAGA,+EACA,WAEA,IACA,sCACK,sBACL,2BAGA,6DACA,qBACA,mBApCA,+BAEA,SACA,8CACA,8BACA,EASA,EA0BA,EACA,EAIA,cACA,iBASA,UACA,iCACA,SACA,gBAGA,eACA,KAEA,UACA,eACA,mBACA,KACA,QACA,UACA,sBACA,yBACA,yBACA,2BACA,qBACA,eACA,oBACA,oBACA,qBACA,qBACA,2CAGA,uCACA,4CAEA,iCAOA,YACA,YACA,uBCjIA,kB,wBCmBA,CAEA,QAEA,qBACA,CAkBA,mBACA,KAEA,yBAIA,IACA,GACA,EAKA,yBACA,wBACA,yBACA,sBACA,wBACA,iCAMA,OAAuB,MAAoB,UAC3C,KACA,gBAA4B,KAM5B,WACA,UAIA,QACA,4DACA,KAA2B,MAAkB,UAC7C,sBAMA,SAEA,YADA,qCAEA,mBACA,6BAIA,MACA,QACA,CACA,QAAK,IACL,MAGA,wBACA,CAqBA,gBACA,GAEA,uFAwCA,oBAjCA,WAEA,QACA,sBACA,4DAA2B,MAAkB,UAC7C,IACA,QACA,yBACA,2BACA,aAEA,QAKA,UACA,YACA,0BAEA,aACA,2BACA,aAEA,QAOA,MACA,qBCxKA,kB,kCCMA,CACA,YACA,wBCeA,CAEA,SACA,YAEA,MACA,UAEA,WACA,WACA,cACA,iBACA,eACA,cACA,qBAEA,cACA,YACA,cACA,eACA,aACA,gBACA,aACA,cACA,aACA,aAEA,gBACA,cACA,gBACA,iBACA,eACA,kBACA,eACA,gBAGA,gBACA,cACA,gBACA,iBACA,eACA,kBACA,eACA,gBAEA,KAEA,kCACA,OACA,YACA,uBACA,yBACA,GAAC,eCrDD,CAEA,mBAEA,oBACA,KACA,8BACA,+BAGA,gBACA,2BACA,gCAIA,kEAQA,kCAIA,MAIA,+FAKA,MAAC,iBC5DD,aACA,2CACA,OACA,iBAAuC,OAAW,IAClD,YACA,YACA,K,gBCNA,qBACA,OACA,QACA,wCACA,UACA,qDACA,wDACA,6BACA,wDACA,0EACA,aACA,aACA,0DACA,aACA,aACA,wCACA,aACA,0DACA,wDACA,+EACA,sBACA,aACA,wDACA,sCACA,+BACA,sBACA,aACA,wCACA,wCACA,6BACA,sBAEA,WAYA,4BAXA,KACA,2BACA,kCACA,WACA,2BAIA,OACA,kBC1CA,CACA,qBACA,cA0CA,uBACA,YACA,QAEA,cACA,IACA,MAIA,2BAHA,GACA,KACA,IAIA,MAtDA,yBACA,IACA,4BACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,kBAEA,eACA,4BACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCAEA,cACA,4BACA,oCACA,oCACA,2BACA,oCACA,2BAGA,sCACA,OAEA,uBAeA,YACA,EAOA,cANA,QACA,eACA,iBACA,0BACA,iBACA,UAIA,gBACA,QAAgB,gBAChB,KACA,UACA,cACA,WACA,YACA,GACA,UACA,kBACA,aACA,eACA,EACA,MACA,kBACA,aACA,cAIA,qBACA,eACA,kBACA,OAAwB,KAAoB,KAC5C,IACA,sBAKA,UACA,QAEA,CACA,sBCvGA,YAEA,oBACA,qBACA,YACA,kBACA,mBACA,uBACA,yBAEA,SACA,CAAC,qBCXD,YAEA,uBACA,mBACA,U,mBCJA,YAEA,oBACA,sCACA,+BACA,OAGA,oBAEA,WACA,CAAC,qBCXD,YAEA,oBACA,kFACA,6BACA,wDACA,QACA,CAAC,kBCDD,CAEA,QAEA,SACA,OACA,OACA,OACA,OACA,OACA,QACA,SACA,UACA,QACA,QACA,GAEA,SACA,OACA,WACA,cACA,YACA,YACA,cACA,cACA,eACA,aACA,aACA,yBC5BA,CAEA,QAEA,SACA,OACA,OACA,OACA,UACA,QACA,QACA,GAEA,SACA,OACA,WACA,cACA,gBACA,aACA,aACA,yBCpBA,CAEA,QAEA,SACA,OACA,QACA,OACA,QACA,UACA,SACA,OACA,QACA,GAEA,SACA,OACA,YACA,cACA,YACA,cACA,aACA,cACA,cACA,wBCxBA,CAEA,QACA,QACA,OACA,OACA,OACA,QACA,QACA,WACA,kBACA,kBACA,WAQA,uBACA,cAQA,4DACA,IACA,+CAEA,WACA,EAEA,OAdA,eAMA,sBASA,gCACA,yCACA,sBACA,UAEA,kDACA,kCAAuC,OAKvC,4DAEA,aACA,6BACA,0BACA,+BACA,4CACA,QACA,UAMA,gCAGA,+BAGA,mEACA,qBACA,6BACA,qCACA,2BACA,wCACA,4CACA,wBACA,oCACA,yCACA,4BACA,oBACA,iCACA,4CACA,wCAEA,OACA,wBAQA,sBACA,gBACA,eACA,QACA,kBACA,2BACA,gBACA,IAIA,EACA,EAIA,cACA,iBASA,OACA,iCACA,SACA,gBAQA,iCACA,8BAGA,0CAEA,KACA,uBAGA,kBACA,CACA,QACA,UACA,iBACA,mBACA,uBACA,0BACA,2BACA,yBACA,yBACA,qBACA,iBACA,qBACA,+CAGA,kCACA,6BAGA,UAMA,8BAUA,yBAGA,cACA,uBACA,SACA,aAEA,SAjBA,0BACA,YAGA,aAoBA,EACA,gCACA,SACA,gCACA,uCACA,GACA,QAMA,sBAEA,kBACA,2CACA,GACA,QAEA,mCACA,GACA,QACA,SAOA,EACA,+BACA,gBAiDA,IACA,YACA,eACA,IAAK,SAEL,WAEA,UACA,CAEA,cACA,wBACA,MACA,gBAMA,cALA,YAEA,uBAIA,OACA,+BACA,MACA,IACA,GACA,GAEA,CACA,8BACA,QAGA,UACA,OAEA,cACA,CAEA,MAEA,qCACA,8BACA,mBAKA,gBACA,CAhGA,uBACA,MAGA,mCACA,iBACA,oBACA,KACA,KAEA,yBACA,UAGA,iCACA,UACA,YAGA,YACA,oBAEA,QADA,WAGA,0BACA,CAIU,sBAHV,kBACA,IAEA,EAAiB,IACjB,oBACA,UAEA,MAGA,MACA,IAEA,0BACA,IACA,QACA,uBAEA,gBACA,OAEA,EAuDA,EACA,8BACA,gCACA,eACA,KAEA,QACA,CACA,eAGA,OAgBA,2CAdA,CACA,mBAGA,cACA,QACA,iBACA,gBACA,QAAK,SACL,QACA,UACA,CAEA,IAQA,EACA,4BACA,SAMA,cAEA,2DAMA,SACA,WAGA,yEAKA,KACA,IAKA,EACA,4BACA,OAEA,UACA,uBACA,mBAEA,mDACA,QACA,gBACA,SAEA,GAMA,EACA,4BACA,OAKA,yBACA,4CAQA,SACA,OAEA,8BACA,GACA,uBACA,MACA,EAMA,oBAMA,mCACA,QACA,gBACA,SACA,WAxBA,QA8BA,EACA,oCACA,OACA,UAEA,wBACA,cAOA,GACA,oBACA,gBAGA,iBACA,UACA,6CACA,2BACA,yCACA,eACA,cACA,kBAGA,oBAEA,UAMA,6BAOA,mCAIA,GAEA,UACA,kBACA,SAOA,KACA,QACA,GAEA,aACA,eACA,SAEA,oCACA,8CAEA,iBAEA,mBACA,wBACA,EACA,CAEA,gBAhEA,iCAkEA,UACA,oBAKA,UAHA,oCAQA,6BACA,KACA,WAGA,YACA,KACA,EAAG,OACH,aAGA,gCACA,sBACA,6BAIA,kBACA,cAMA,8CALA,OAGA,kCAQA,EACA,+BACA,sBACA,6BAOA,wCACA,2DACA,YACA,GAMA,EACA,sDACA,OAGA,OAFA,WAGA,4CACA,gCAMA,iCACA,SAGA,wBACA,qCACA,+BACA,OACA,YASA,EACA,kDACA,OACA,KAEA,aAGA,kCAAiC,EAAO,IACxC,sBACA,mBACA,6BACA,4BACA,2BAEA,2CAIA,6BACA,UAFA,KAGA,EACA,CAGA,QACA,8CAEA,2BACA,GACA,wBACA,wBAGA,OACA,GAOA,EACA,iCACA,OAEA,2BACA,eAEA,iDACA,MACA,oBACA,SAEA,sBCxqBA,aACA,uBACA,OAGA,aACA,0CACA,kCAGA,aACA,2CACA,kCAfA,WAuBA,YACA,uBACA,uBACA,mBARA,WACA,cACA,uBCpBA,QACA,OACA,OACA,QACA,WACA,eAQA,8BACA,QACA,aAEA,aACA,oBACA,sBACA,wBACA,iBACA,uBACA,gBAEA,WACA,8BAEA,KAEA,eAIA,WACA,iBAOA,OACA,kCACA,MAEA,sBACA,0BACA,GAEA,WACA,cAGA,8BACA,WACA,eACA,8BACA,WACA,eAAc,gBACd,+BACA,uCAGA,UACA,sCACA,OAEA,0BACA,CACA,IAEA,wBACA,GACA,SAEA,KACA,QAEA,sCACA,QASA,EACA,iCACA,OAEA,KACA,uBACA,MAGA,UACA,QACA,iBACA,CACA,QACA,UAKA,eACA,gBACA,cAGA,QACA,gBACA,cAIA,oCACA,WACA,wDAGA,eAIA,iBAEA,eACA,SACA,EAOA,EACA,+BACA,CACA,uBACA,MAGA,UACA,YAEA,oBACA,QACA,QAGA,mBACA,uBACA,qBAGA,eACA,uBACA,qBAGA,qCACA,OACA,wDAGA,qBAEA,SACA,sBACA,QACA,QAAO,SACP,OACA,KAGA,GACA,OACA,EAMA,EACA,8BACA,MAEA,SACA,OACA,MACA,EAEA,EA2CA,2BA1CA,GACA,SAEA,IACA,QACA,SAGA,mBACA,uBACA,qBAGA,eACA,uBACA,qBAGA,aACA,cAEA,0BACA,CAIU,sBAHV,kBACA,IAEA,EAAiB,IACjB,OACA,yBACA,MAAO,SACP,QACA,UAGA,GACA,IAEA,2BACA,QACA,UAEA,mBC9OA,kB,qBCAA,kB,0BCAA,QACA,QACA,OACA,WAQA,gCACA,QACA,aAEA,oBACA,oBAEA,eACA,yBACA,gCACA,kEACA,oDACA,8BACA,yBAEA,UACA,8CACA,8BACA,EAEA,EAIA,EACA,EAIA,cACA,iBASA,SACA,iCACA,SACA,gBAGA,eACA,KAEA,UACA,eACA,mBACA,KACA,QACA,UACA,sBACA,yBACA,2BACA,qBACA,eACA,iBACA,qBACA,+CAGA,+CACA,6BAEA,yBAGA,eACA,YACA,UAEA,gCACA,kBACA,oBACA,mBCxFA,iBACA,aACA,sCAEA,eAEA,WACA,uDACA,CACA,QACA,iCAEA,aACA,MAIA,aAHA,0BAEA,qBAGA,mBACA,OACA,YAGA,SACA,iCAEA,SACA,kBACA,YACA,+CACA,CACA,sBACA,kBACA,cACA,gBACA,kBACA,YAIA,qBACA,sDAIA,YACA,OACA,OACA,OACA,OACA,OAEA,wBACA,kBACA,2BACA,OACA,OACA,KACA,QAGA,KACA,IAGA,KACA,sBACA,OAGA,UACA,gBACA,mCACA,KACA,eACA,WACA,6CACA,KAGA,mBACA,yBACA,qBACA,QACA,EACA,IAEA,mCACA,OACA,kBACA,OACA,MACA,gBAEA,mDAEA,eACA,gBACA,OACA,KACA,CACA,KAEA,cACA,iBACA,aAGA,KACA,0BCxGA,CAEA,QACA,OACA,UAQA,iCACA,cACA,mBACA,gBACA,YACA,0BACA,OACA,QAIA,eAQA,EACA,6CACA,OACA,KAEA,cAKA,iBAAuB,yBACvB,sCAKA,oCAEA,kCACA,sDAGA,sCACA,IAIA,0BAEA,oBACA,8BAGA,0CACA,OACA,6BACA,kBAEA,KACA,2BAEA,+CACA,GACA,UAGA,SACA,UAOA,EACA,2BACA,cACA,UAOA,EACA,6BACA,cAGA,GAIA,0BACA,UACA,WAEA,OATA,gEAUA,CACA,IACA,EAMA,EACA,+BACA,aACA,4BCxHA,CAisBA,aACA,MACA,yBACA,KAMA,CAxsBA,QACA,QACA,OACA,QACA,QACA,OACA,WAEA,SAQA,iCACA,qBACA,WACA,YAIA,EACA,eAQA,cACA,iCACA,OAMA,6CACA,aAGA,aACA,mBACA,eAEA,KACA,4CACA,SACA,QAMA,oBACA,+BACA,UACA,sBAMA,sBACA,yBACA,uBACA,gCACA,mCACA,sCAOA,mCACA,kBAEA,8CACA,oBACA,MACA,KACA,EAEA,KACA,2CAEA,kBASA,EACA,2BACA,cAuBA,GAEA,OACA,iBAEA,UAEA,cA+CA,MACA,YACA,QACA,WAEA,GAEA,eAEA,eAGA,gDAxFA,KAGA,KACA,wBASA,YACA,mCACA,MAKA,QAUA,0CAEA,sCACA,mDAQA,8DACA,SACA,mDACA,0CACA,SAEA,SACmB,OAUnB,eATA,WASoB,GACpB,4BACA,uCACA,yBAA2C,eAC3C,uDAEA,cACA,sCACA,UACA,6CACA,iCACA,EACA,qBAKA,aAcA,sDAGA,0CACA,GACA,UAEA,mCACA,OACA,WACA,mBAEA,SACA,QAEA,KASA,oBACA,OACA,6CACA,GAKA,UAeA,uBAdA,SACA,qCAEA,aACA,YACA,KAGA,iBACA,mBACA,IACA,EAEA,KAEA,IASA,EACA,+BACA,gBAeA,GACA,kBAGA,uCAEA,UAGA,qCACA,QACA,EAMA,CA/BA,uBACA,MAGA,UACA,UACA,KACA,uBACA,GAKA,WA0CA,mCACA,kCAMA,iDACA,UACA,aAAG,qBACH,WACA,KAMA,4BAxCA,kBAMA,OAEA,aAGA,SAGA,OACA,IACA,EAMA,YAmBA,GACA,OACA,GAMA,EACA,8BACA,OACA,UACA,KACA,QACA,GAEA,iBACA,yBACA,uBACA,eACA,gBAEA,SAEA,CAmCA,SAlCA,+BACA,aACA,iBACA,SAKA,+BACA,UACA,aAAG,qBACH,WACA,MAEA,wBACA,SAGA,gBAEA,8BACA,0BACA,sBACA,aACA,QAEA,2BACA,0BACA,sBACA,aACA,UACA,GAEA,IAOA,EACA,4BACA,OAEA,oCACA,SACA,mBACA,SAEA,OAEA,aACA,QAMA,EACA,uCACA,kCACA,aACA,KAEA,0BACA,OACA,eAGA,YAEA,OAEA,kDACA,wBACA,uBACA,OAEA,8BAEA,wBACA,oEACA,0CAEA,iBAMA,EACA,yCACA,OAEA,UACA,yEACA,SACA,uBACA,SAEA,OAEA,0BACA,mDACA,SACA,gBACA,qBAEA,oBAEA,mDACA,sBAEA,mBAQA,EACA,+BACA,WAEA,wBACA,oBAEA,oEACA,4DAGA,sDACA,qCAKA,0CAEA,0BAOA,oCACA,sBAGA,mBACA,IAKA,EACA,4BACA,iDACA,aAAiB,CACjB,QAAG,EACH,KAMA,EACA,8BACA,OACA,yCAGA,cACA,6CAGA,6CACA,iCACA,2CAEA,cACA,SAGA,UACA,qCAEA,UACA,IAWA,EACA,iCACA,cACA,KAWA,EACA,+BACA,oBACA,MAEA,cACA,qBACA,yBAGA,0CACA,sDACA,8CACA,oBAGA,kBACA,SAGA,mBAGA,eACA,KAMA,EACA,iCACA,8BACA,SAOA,EACA,0BACA,aACA,kCACA,0BAEA,wBACA,mEACA,uEAGA,eACA,IAOA,EACA,0CACA,aAmBA,IAKA,KACA,gBACA,kBAEA,GAEA,OA7BA,KACA,SACA,qBACA,wBACA,EAKA,WACA,yCACA,oBAEA,eAiBA,oBASA,uBAzBA,yCACA,kBAEA,WAwBA,oBAJA,GAUA,EACA,4CACA,OAEA,wCACA,UACA,oBAAG,qCACH,4CACA,aAAG,WACH,QAQA,EACA,kCACA,MACA,oBAEA,YAOA,EAWA,4BACA,kCACA,sDACA,8CAEA,2CACA,iBACA,0BCttBA,aAaA,UAZA,UACA,yCACA,YACA,QAOA,sBANA,6BACA,MACA,IACA,EAEA,uBCyIA,aACA,yBACA,GACA,oBAEA,yBAEA,kBAKA,mCACA,sBACA,MACA,KACA,EACA,EACA,EAEA,4BACA,iCAIA,aACA,KACA,KACA,KACA,gBACA,IAAK,QACL,CACA,QACA,GACA,YAAS,UAET,QAEA,YACA,CACA,QACA,EAEA,aACA,kBACA,yCACA,mCAEA,kBAGA,sCACA,sBACA,MACA,KACA,EACA,EACA,EAEA,+BACA,sBACA,WAEA,KADA,KAEA,KACA,mBACA,IAAO,QACP,CACA,QACA,GACA,YAAW,UAEX,QAEA,YACA,CACA,QAGA,+BAA4C,uBAC5C,2BAEA,GAEA,aAEA,yBACA,gCACA,UACA,sBACA,UACA,EACA,IAEA,aAEA,uBACA,IACA,UACA,WAAK,SACL,UACA,OACA,CACA,IAGA,aAEA,2BACA,kCACA,UACA,sBACA,UACA,EACA,IAEA,aAEA,yBACA,IACA,UACA,aAAK,SACL,UACA,OACA,CACA,IAGA,aAIA,uBACA,gCACA,gCAEA,6BACA,4BACA,yBAHA,UAIA,EACA,IAEA,aAIA,qBACA,SACA,UAGA,wBAFA,6BACA,aAEA,GAaA,CACA,aACA,IACA,GAEA,YACA,kBAEA,gCAEA,mDAKA,kBAzUA,QACA,QAEA,cACA,MAEA,kDAEA,sBAEA,CAEA,oBADA,aAEA,GACA,SACA,KAAC,WAED,oBACA,yBACA,GACA,YACA,YAEA,UAEA,WAKA,kBACA,oCACA,2BAIA,OACA,SAQA,iBACA,oBACA,qBAEA,oBACA,oBACA,qBAEA,wBACA,4BACA,6BAEA,4BACA,4BACA,6BAEA,uBACA,kBACA,mBAEA,sBACA,0BACA,2BAGA,aACA,iCACA,YACA,WACA,0BAEA,KACA,mCACA,YACA,WACA,0BAYA,GACA,kCAAuC,uBACvC,YACA,QACA,qBACA,OACA,wBACA,4BACA,8BACA,qBACA,IACA,kBAEA,SACA,IACA,EACA,UACA,WAGA,cACA,KACA,GAAM,IAIN,2BAAiC,6BACjC,IACA,8BACA,OACA,eACA,8BACA,MACA,MAEA,uCACA,UACA,CACA,UACA,oBAAI,IAEJ,4BAAyC,2BACzC,WAEA,OACA,UACA,iBAAO,SACP,4BACA,CACA,IACA,QACA,CACA,OAEA,EAAI,IACJ,wBCnJA,kB,8BCAA,kBAEA,UAEA,WACA,gBAMA,+BAEA,mBAEA,YAEA,UACA,eACA,UACA,iBAEA,qBACA,cACA,uBAEA,UAGA,oBACA,gBAA6C,SAAgB,IAC7D,MACA,aAGA,6CAEA,8BACA,0BACA,sBAEA,2CACA,aACO,uCACP,oBAGA,2CACA,oBAGA,sCACA,KAEA,OACA,wEAQA,kBACA,kBAIA,qBACA,YACA,YACA,QACA,mCAhBA,GACA,OAIA,EAaA,gBACA,+BAEA,mBAEA,WACA,eACA,UAEA,uBACA,kBACA,mBACA,sBAEA,OAGA,oBACA,gBAA6C,SAAgB,IAC7D,MACA,aAGA,4BACA,0BACA,sBAEA,6BACA,6BAGA,uCACA,KAEA,MACA,oBAEA,GACA,8BACA,4DACA,mBAEA,QACA,OA/GA,CACA,aAGA,iCCVA,UACA,QACA,sBCFA,aAEA,UACA,OACA,OACA,WA8CA,UA5CA,kBAEA,2DAGA,cAEA,YAJA,MACG,oBAIH,OAGA,yBACA,oCAKA;kEAhBA,iBAiBA,UACA,iBACA,sCAEA,uEACA,YAEA,YACA,wBACA,mBACA,OACA,iBACA,IACA,UAGA,sBACA,OACA,2BACA,OACA,SAGA,aACA,qBCjDA,8BAEA,UACA,OACA,OAEgB,GA4DhB,UACA,CACA,aAhDA,WACA,iFACA,eAGA,6BACA,sFACA,OACA,wBACA,SACA,0BACA,OACA,oBACA,OACA,mBACA,SACA,iBAMA,6BA2BA,iBA9DA,UACA,sFACA,eAGA,6BACA,iCACA,+EACA,eACA,qBACA,aACA,mCAoDA,iBA1BA,WACA,IACA,gCACG,sBACH,8BAEA,gCAEA,wDAmBA,aAjBA,iBAEA,eACA,SACA,+BACA,gBACA,MACA,KACA,EAEA,uBChEA,aAOA,qDAEA,cAGA,gBACA,mBAGA,0CAEA,oDACA,iDACA,mEAEA,gDAAkD,SAGlD,wBACA,oCAIA;kEAtBA,sDAuBA,gBACA,eACA,iBAEA,4BACA,sBACA,uFACG,2CAEH,eACA,iBACA,oBACA,aACA,yBACA,kCAEG,gDACH,oBACA,wBACA,8BACA,MACA,OACA,6BACA,YACA,EAAG,4CACH,WACA,kBACA,gBACA,EAzDA,UACA,OACA,OACA,WAwDA,6BC7DA,aAEA,UAEA,KACA,wBAmCA,UAjCA,eACA,WACA,cACA,iBAEA,wBACA,cACA,OACK,kBACL,sBAAyB,IACpB,uBAGL,6BACA,SACA,kCACA,gBACA,IAEA,EACA,sBACA,uBACA,KAIA,kCAGA,SACA,eACA,+BCtCA,aAQA,aACA,CACA,CACA,SACA,QACA,OACA,QACA,QAEA,wBACA,YACA,QACA,kBACA,IAEA,kCACA,EAEA,iBAGA,CACA,uBACA,MAGA,QACA,kDACA,+DACA,0CACA,uEAEA,oCAEA,sBAWA,0BAGA,MACA,IACA,EAYA,CACA,iBACA,CACA,KACA,OAIA,uCACA,OACA,2BAQA,kBACA,cAGA,gCACA,MACA,IACA,2BAEA,SACA,iBAEA,MAEA,eACA,wBAEA,WACA,OACA,KACA,EACA,GAEA,mBACA,CACA,KACA,OAEA,uCAGA,2BAEA,uBAEA,wBAEA,uBACS,UACT,cAEA,aAEA,WAEA,EACA,GAEA,iBACA,IAEA,GACA,KAEA,sBAGA,WACA,eACA,IAAG,SACH,IACA,kBAEA,OAEA,OAEA,IACA,KACA,WAAG,SACH,IACA,kBAEA,OAEA,OAEA,GACA,cAEA,WAEA,cAEA,mBACA,CACA,KAEA,sBAEA,UAKA,qCACA,8CACA,kBACK,YACL,mBAEA,KAEA,IACA,GAEA,iBACA,CACA,KACA,OAEA,yCACA,YAEA,cACA,OAEA,iBAEA,+BACA,iBAIA,kBACA,UACA,UAGA,YACA,EACA,EAIA,CACA,eACA,IAEA,QACA,GAEA,SACA,kDACA,uCACA,qDAEA,uCACA,KACA,YAAG,SACH,IACA,kBAIA,OAGA,gBAEA,IAEA,MACA,oBAEA,QAEA,aAAG,SACH,IACA,kBACK,UACL,uBACK,aACL,kBAEA,QACA,QACA,EAEA,iBACA,CACA,KAEA,sBAGA,WACA,GACA,YAAG,SACH,IACA,kBACK,UACL,mBACK,sDACL,mBAEA,MACA,EAEA,eACA,CACA,KACA,uCACA,gBACA,eAlSA,UACA,OACA,OAEA,wBAgSA,YACA,0BCvSA,aAEA,cAEA,uBACA,eACA,IACA,uBACA,mBAEA,6BCJA,aAQA,mBACA,aAsBA,kBACA,WAEA,+BACA,6BAGA,2BACA,OACA,YACA,aAMA,aACA,qCACA,KACA,OACA,YACA,aAEA,YAAW,EAIX,0BAIA,YAHA,KAtBA,gBA2BA,8DACA,uBAGA,gBAGA,aAGA,YACA,CAjEA,uBACA,MAGA,+BACA,wBAGA,wBAMA,gBACA,OACA,SAEA,KAEA,CAVA,GAGA,IAsDA,mBACA,UAEA,aAIA,aACA,cAEA,WAGA,aAEA,mBACA,aAiCA,GACA,WACA,eAlCA,SACA,4CAA2C,CAE3C,4BACA,GACA,YACA,2BAKA,0BAEA,oBACA,iBAEA,WAEA,IACA,EAEA,qBACA,GACA,YACA,2BACA,WACA,IAEA,UACA,aAEA,QAKA,mBACA,aAcA,SACA,OACA,SAEA,QACA,SAlBA,CAIA,oBACA,OACA,SAGA,MAGA,IA9IA,UACA,OACA,QACA,WACA,qBAkJA,UACA,CACA,yBChKA,aAQA,iBACA,aAcA,CACA,QACA,UACA,eAAO,SACP,6CACA,uBACA,QACA,aAGA,6BACA,cACA,SAEA,SACA,UACA,gBACA,aAAO,SACP,2DACA,yBAEA,UACA,OAEA,CACA,MAtCA,0BAEA,mBACA,eAEA,WAEA,iCAA8D,iBAAqB,mBAEnF,UACA,YAEA,KA4BA,iBACA,WAEA,qBACA,cAEA,SAEA,SAEA,iBACA,YACA,UAEA,mBAEA,oBACA,SACA,gCACA,gBACA,IAEA,EACA,sBACA,uBACA,KAGA,cACA,eACA,eACA,cAEA,iBACA,aAYA,OACA,UACA,IACA,SAdA,CAIA,iBACA,KAEA,KAGA,GAOA,CACA,eACA,IACA,sBACA,eACA,QACA,mEACA,WAAG,SACH,CACA,QACA,EA9GA,UACA,OACA,WACA,iBACA,6BA4GA,UACA,CACA,6BCpHA,aAOA,eACA,iBACA,qBACA,aAOA,WACA,+BAEA,OACA,SAEA,MAJA,GAKA,YAZA,gCAEA,WAEA,IASA,GAEA,aACA,IACA,MACA,KACA,cAAG,SACH,UACA,aAEA,gBACA,KACA,YACA,aACA,GArCA,UACA,OACA,OACA,WAoCA,UACA,CACA,eACA,eACA,WACA,6BC9CA,aAEA,UACA,QACA,YAEA,UAEA,cACA,4BACA,4BACA,4BAEA,4BACA,4BACA,4BACA,4BAEA,+BACA,kCACA,kCACA,kCACA,oCCtBA,aAMA,eACA,aACA,kBACA,OACA,SAEA,KAEA,iBACA,YACA,eACA,sBACA,OACA,oBACA,OACA,SAGA,MACA,GAEA,aACA,OAEA,yBACA,aACA,iBAGA,gCACA,KAlCA,UACA,OACA,UAkCA,UACA,CACA,aAEA,iBACA,aACA,mCC5CA,aAMA,iBACA,gBACA,YACA,OACA,YAEA,MAEA,YACA,SACA,0BACA,CACA,gDACA,cAGA,eACA,sBACA,OACA,uBACA,OACA,SAGA,SAEA,IAEA,eACA,WACA,cAEA,UACA,GACA,YAAG,SACH,CAEA,0CADA,eAGA,WACA,eACA,yBACA,iBAEA,gBACA,gBAjDA,UACA,OACA,UAiDA,UACA,CACA,aAEA,iBACA,aACA,mCC3DA,aAgBA,mBACA,GACA,2BAEA,mCACA,SACA,iBACA,SACA,cACA,yBACA,YACA,gBACA,sBACA,SACA,0BACA,OACA,YAGA,kBAGA,MAEA,mBACA,GACA,2BAEA,kCACA,cAEA,eACA,WACA,YACA,mBACA,eACA,yBACA,oBACA,OACA,qBArDA,UACA,OACA,OACA,OACA,WAEA,eACA,QACA,iBAEA,qBACA,QACA,gCA2CA,UACA,CACA,gBAEA,oBACA,gBACA,sCC/DA,aAEA,UACA,OAsBA,GAoEA,UACA,CACA,aApEA,eACA,MACA,+BAEA,4CACA,iBAEA,aACA,CACA,QAGG,eACH,WACA,eACA,4BAEA,cACA,CACA,QAGA,oBAEA,4CACA,iBAEA,aACA,CACA,gBAKA,iBACA,GAkCA,iBAhCA,aACA,IACA,sBACA,QACA,iCACA,yCACA,CACA,QAEA,QAAG,KACH,WACA,eACA,UAEA,OADA,sBAEA,CACA,QAGA,gBACA,iCACA,yCACA,CACA,gBAGA,cACA,qBC3FA,aAEA,aAyBA,UACA,CACA,YAzBA,eACA,UACA,2BACA,4BACA,uBACA,gBACA,wCACA,SAEA,WAiBA,gBAfA,aACA,IAEA,QACA,YACA,KACA,YAAG,SACH,OACA,MACA,iCACA,0BCzBA,aAEA,UACA,OACA,UA6BA,UACA,CACA,WA7BA,iBACA,CACA,uBACA,MAGA,kBACA,sBACA,SAEA,mCACA,OAEA,YAGA,sBAcA,eAZA,WACA,WACA,oBACA,sCAEA,kBACA,sCACA,+BC/BA,WACA,OAEA,MAEA,0BACA,aA+CA,MACA,OAEA,CA+GA,2BA/JA,wCACA,OACA,wDAEA,kDACA,yBACA,kBACA,8DACA,GACA,mDAEA,cACA,CAAO,EACP,MAEA,gCACA,OACA,KAEA,2CACA,eACA,KACA,OACA,KAAO,SACP,KACA,WACA,oBACA,YAAwC,QAAW,IACnD,MACA,YAEA,MACA,QACA,CAEA,eAEA,2BAOA,wCAKA,iCACA,EAEA,gCACA,iCACA,UACA,WAOA,gCACA,IACA,MACA,UAEA,WACA,yBAEA,gCACA,qCAEA,yEAEA,8BAEA,YAGA,UAEA,wBACA,UAEA,kCACA,OACA,QACA,WAEA,mBACA,UACA,UACA,IACA,SACA,SAEA,mCACA,aACA,UAEA,+BACA,aACA,WAGA,0CACA,OACA,WAA+C,OAAW,IAC1D,MACA,KACA,SAGA,QACA,gBAEA,qCAEA,sBACA,CAOA,gCACA,aACA,8CACA,oBAA4C,OAAW,IACvD,MACA,sBAGA,aAEA,sCACA,yBACA,oBAEA,mDACA,OACA,yEACA,GAEA,8CACA,aACA,QACA,qBACA,8BAAsC,QAAW,IACjD,MACA,oCAEA,OACA,QAEA,GAIA,GAAC,+BCzKD,WACA,SAEA,IAEA,2BACA,aAQA,SACA,0BACA,qBAA2C,OAAW,IACtD,MACA,kBAEA,MAEA,CA4CA,mBArDA,0CAUA,MACA,gBACA,gDACA,UACA,SACA,oBAEA,KAOA,4BACA,SACA,WACA,6BAA6C,OAAW,OACxD,IACA,aACA,sBAGA,MAEA,gCACA,MACA,2BAEA,YAEA,mCACA,MACA,SAEA,8BACA,MACA,2BAEA,OAEA,GAIA,iBACA,IACA,cAEA,QACA,oCAEA,qEAEA,CAAC,6FC7ED,UACA,QAUmD,IACnD,EAiFC,OAjFD,KAQE,CAA+B,cALd,MAAO,QAAG,GAAI,GAEvB,aAAK,MA8BL,UAAY,aAAiB,KAChC,CAIC,QAJK,MAIA,KAIP,SAAK,KAAK,KAAK,KAAa,OACzB,CAIH,YAAW,GAAO,KACf,MAIA,IAAM,EAAK,MAAS,EAInB,gBAAM,oBAAa,MAAU,SAAO,EAEpC,YAAgB,YAAO,EAE/B,WAAC,EArDK,OACL,MAOqB,CAAoC,kBAClD,OAAK,MAAQ,QAAG,GACvB,SAKW,QACP,IAAK,KACN,WAAM,IACJ,sDAAmD,KAEvD,IAEA,WAAa,GAAK,EAAM,MAAK,KAAK,KAAM,KACpC,mBAAM,MAAG,CAAS,UAAU,SACjC,EA+BgB,CAAkC,cACjD,MAAY,KAAsB,iBAAK,KAAK,KACrC,CACF,YAAO,EAGR,YAAQ,QAAK,KAClB,SAGU,OACT,MAAW,GAAO,KAEX,YAAQ,QACT,aAAM,MAGf,wBC3ED,CA0BA,eACA,IACA,mBAEA,6BACA,yBAEA,qCACA,SAEA,SADA,SAKA,CAIA,aACA,kBACA,aAIA,uBACA,+BACA,0BACA,wBAGA,+BACA,+BACA,IAEA,yBACA,uCAGA,SACA,GA/DA,QACA,OACA,OAEA,KACA,uBACA,kBACA,iBAEA,EACA,oCAEA,UAEA,OAEA,QAEA,EACA,sCACA,oBACA,2EACA,MAkBA,uBAwBA,0BAEA,sCAEA,MAEA,cACA,cACA,iBACA,aAGA,YAGA,kBAGA,+BAGA,gEACA,cAGA,QACA,2EACA,KAGA,oCACA,sDACA,6BACA,MAEA,uCAEA,iCACA,wBAEA,kCACA,6CAEA,OACA,KAIA,qCAHA,GACA,kBACA,EAGA,CACA,CACA,KAEA,8BACA,sCACA,IAEA,EACA,mCACA,4BACA,0CAEA,eAKA,cAEA,2BC1JA,kB,2BCAA,aAEA,QACA,OACA,OACA,OACA,UACA,iBACA,WACA,OACA,OAEA,2CAQA,8BACA,cAOA,4DACA,IACA,+CAEA,WACA,EAEA,WARA,sBASA,gCACA,yCACA,sBACA,UAEA,kDACA,mCAAuC,MAKvC,4DACG,oBACH,uBACA,0BACA,aACA,wCACA,QACA,UAOA,gCACA,SACA,sBAGA,mEACA,qBACA,qCACA,+BACA,+BACA,yBACA,wBACA,uDACA,iDACA,uDACA,kCACA,uBACA,kCACA,iBACA,6BACA,mCAEA,uBACA,wBAQA,sBACA,gBACA,eACA,QACA,4BACA,OAMA,yCAGA,UACA,WACA,sDACA,wBACA,UAAS,6BACT,OACA,CACA,qDAEA,UAAS,gCACT,iBACA,IAAS,kBACT,UACA,IACA,EAAO,SAEP,CAEA,OACA,EAAG,OAEH,iCACA,kCACA,kCACA,iCACA,mCACA,wCACA,cACA,qDAEA,gBACA,IACA,YAEA,MACA,QAEA,kCAEA,0BACA,kCACA,kCACA,iCACA,mCACA,wCAEA,cACA,0BACA,aACA,oBACA,mBACA,UACA,gBACA,cACA,gBACA,cACA,kBACA,kBAEA,uDACA,uCACA,EACA,EACA,CAIA,EACA,EAKA,cACA,aAIA,kBACA,iBASA,kBACA,iCACA,SACA,gBAQA,iCACA,8BAGA,0CAEA,aACA,CACA,QACA,UACA,iBACA,mBACA,uBACA,0BACA,2BACA,qBACA,qBACA,yBACA,qBACA,qBACA,+CACG,uCAEH,kBAEA,YACA,8BAKA,yBAGA,cACA,cACA,aAOA,SACA,iBAEA,aAOA,EACA,gCAIA,oBAKA,kBACA,2CACA,GACA,QAEA,UACA,eAOA,EACA,+BACA,gBAsDA,IACA,YACA,SACA,MAEA,IAAK,SAEL,WAEA,UACA,CAEA,cACA,wBACA,KAMA,cALA,YAEA,uBAIA,OACA,+BACA,MACA,IACA,GACA,GAEA,GACA,OAEA,cACA,CAIA,MAIA,qCACA,8BACA,mBAKA,gBACA,CArGA,uBACA,MAIA,mCACA,uBACA,wBACA,KACA,KAEA,yBACA,UAGA,iCACA,UACA,YAKA,wCACA,WAEA,0BACA,eACA,OAGU,mBAFV,IAEA,EAAiB,IACjB,oBACA,UAEA,MAGA,MACA,IAEA,0BAEA,IAEA,QACA,uBAGA,gBAEA,OAEA,EAuDA,EACA,8BACA,gCACA,qBACA,SAEA,QACA,CACA,eAGA,OAmBA,2CAlBA,CACA,mBAGA,cACA,QACA,iBACA,gBACA,QAAK,SACL,QACA,UACA,CAEA,KACA,UAGA,UAQA,EACA,4BACA,SAMA,cACG,2DACH,cAMA,uBACA,WAMA,qBACA,IAKA,EACA,4BACA,OAEA,UACA,uBACA,mBAEA,kDACA,QACA,gBACA,SAEA,GAMA,EACA,4BACA,OAMA,qCACA,SACA,OAEA,8BACA,GACA,uBACA,MACA,EAMA,oBAMA,mCACA,QACA,gBACA,SACA,EAMA,EACA,oCACA,OACA,UAEA,wBACA,cAMA,GACA,kDAEA,eACA,gBAGA,iBACA,UACA,6CACA,yCACA,eACA,cACA,kBAEA,oBAEA,UAOA,6BAOA,mCAIA,GAEA,UACA,kBACA,SAQA,KACA,QACA,GAEA,aACA,SACA,cACA,kCACA,SAEA,iBACA,+CAEA,iBACA,UACA,gBACA,CAEA,gBAlEA,iCAoEA,UACA,oBAMA,UAHA,oCAQA,YAGA,gBACA,0CACA,4BACA,4BACA,2BACA,6BACA,kCACA,mBACA,MAGA,sBACA,KACA,EAAG,OACH,WAMA,EACA,gCACA,YACA,eAEA,OAMA,gDACA,oCACA,GACA,SACA,0BACA,WAAS,UAET,SACA,oCACA,OAAS,UAIT,gBACA,CAAG,eAGH,aACA,sDAMA,gEACA,IACA,qDACA,IAAO,SAEP,CAGA,6CACA,EAGA,iCACA,UAKA,EACA,mCACA,YAEA,+BACA,SACA,oDACA,qBAGA,2BAGA,gBACA,WAOA,EACA,iCACA,OAEA,2BACA,eAEA,iDACA,MACA,oBACA,SAEA,GAMA,EACA,0CAEA,2BACA,iLACG,wCACH,sIACG,+BACH,oGACG,+BACH,iEACG,kCACH,gCAGA,OAMA,EACA,gCACA,UAEA,wBACA,IACA,oBACK,iBACL,qBACK,cACL,oBACK,aACL,oBACK,cACL,sBACK,gBACL,mBAEA,QACA,OACA,aACG,iBACH,cACG,cACH,aACG,aACH,aACG,cACH,eACG,gBACH,YAEA,mGCrwBA,UAA4C,IAE5C,EAEC,iBAF8D,aACvD,OAAM,GAAG,EAChB,oCCDD,CAEA,gBAIA,IAEA,EAQA,QAEA,WACA,cACA,UACA,sCACA,uBAGA,mFACA,gBACA,mBACA,qBAMA,4BAGA,UAUA,6BAGA,OACA,4BAGA,eAIA,YAGA,KACA,sBC5BA,YACA,SAEA,eAEA,2HACA,kCAEA,YACA,iDACA,8BAEA,aACA,mBACA,WAAmB,QAAiB,OACpC,IAEA,KADA,UAIA,eACA,KACA,CAEA,CA6BA,eACA,OACA,iBACA,+BACA,iBACA,gCACA,WAEA,aACA,IAEA,MACA,OACA,UACA,uBACA,mBACA,wCAGA,+BACA,kCACA,eACA,KAEA,QAAM,SACN,CAIA,GACA,eAGA,8HACA,eACA,eAEA,GADA,IAOA,CA6BA,aACA,WACA,cAEA,WAEA,yBACA,OACA,gBAKA,YACA,mDACA,aACA,uBACA,WACA,OACA,MACA,CAGA,kBACA,KACA,SAGA,KAGA,aACA,aAOA,0BACA,gBAIA,gBAHA,UACA,SAIA,CACA,QAGA,CACA,aAEA,gDACA,aACA,SACA,UACA,WACA,eAEA,wCACA,4BACA,GAGA,uCAEA,uCAKA,KAOA,CACA,YACA,OAEA,GADA,UAEA,aACG,aACH,QACA,oCACA,kBACA,mBASA,aAEA,yBACA,2BACA,IACA,iBAEA,yBAEA,MACA,CAEA,OACA,UACA,kBACA,YACA,yBACA,sBACA,YAEA,cACA,0BAEA,mBAEA,sBACA,uBAEA,KACA,4CACA,iBAGA,mBAEA,cACA,sBAEA,iBAEA,MACA,KAGA,MAGA,qBADA,OAGA,aACA,OACA,GAKA,+EAJA,sCAA0D,aAAgC,OAAE,EAC5F,IACA,KACA,aAGA,aACA,MACA,WAMA,kCACA,gCACA,SACA,sCAIA,gBACA,cAGA,YACA,CACA,SACA,OAEA,WAMA,SALA,6BAAoC,UAAwB,MAC5D,4BAAsC,UAAsB,IAC5D,8BAAwC,iBAA4B,CACpE,uCAAiD,UAAwB,MACzE,GAIA,qBAEA,4BACA,OACA,+BAAsC,CAAe,QAMrD,MAGA,CACA,eAEA,cACA,KAGA,uBACA,mBACA,IAAG,QACH,GAEA,CACA,aACA,oDACA,YACA,SACA,QACA,QAGA,KAGA,iBACA,mCAIA,WACA,mCACA,GACA,2BACA,wBAEA,GACA,CACA,OACA,MAEA,aACA,OAGA,iBACA,gBAGA,0BACA,oBACA,GAEA,YACA,eAEA,6BACA,4BACA,kCACA,QAEA,iCACA,sBAEA,GAEA,qBACA,UACA,EA/aA,aACA,sBAEA,KACA,GACA,KACA,mBAEA,iBAEA,KAAC,SAED,CAEA,CACA,GACA,MAGA,KAGA,OAGA,SAGA,KAGA,KAGA,wCACA,eA4BA,kBAEA,QACA,OACA,aAGA,YACA,WAEA,UACA,uBACA,mBACA,YACA,uBACA,qBAEA,aAAG,QAEH,mCAGA,eACA,OAGA,GA6CA,WACA,kBACA,OACA,iBAGA,SACA,gBAEA,8BACA,4BACA,WACA,GAEA,QACA,SAIA,cAIA,CACA,MAEA,OAJA,IAIC,GAiRD,iBACA,mBACA,sBACA,sBAEA,qBACA,SAEA,KACA,kBACA,aACA,2EAMA,kEACA,iBACA,gCAGA,eAKA,iBACA,sBACA,qCAGA,eAIA,wCACA,IACA,MACA,KACA,IAAK,SAEL,CACA,mBAEA,WACA,uDACA,OACA,QACA,mBACA,SAEA,uBAEA,sBAIA,aACA,sCAKA,iCACA,WAGA,wBACA,SACA,mCASA,4BACA,MACA,KAEA,IACA,mBCjgBA,CACA,8CACA,6CACA,6CCFA,CAEA,+EAIA,IACA,oBACA,cACA,aAEA,0BACA,+BAKA,EACA,oBACA,OACA,KAGA,KAGA,gBAUA,GAdA,GAkBA,UACA,GAhBA,IAoBA,IAbA,SAcA,GAlBA,GAsBA,IAfA,GAgBA,GAtBA,GA0BA,GACA,GAzBA,GA6BA,IACA,mBC7DA,CAQA,eAEA,SACA,kBACA,kBACA,oBACA,kCACA,MACA,6CAMA,CACA,YACA,aACA,QAEA,uBAAgB,iCAChB,EAOA,CAjCA,QAKA,IA6BA,YACA,6BACA,aACA,YAMA,EACA,2BACA,QACA,eACA,oBAEA,eACA,uBAEA,QAUA,EACA,8BACA,aACA,6BACA,0CAEA,iBACA,QAEA,gCCzEA,CAQA,aACA,IACA,WACA,4CAAsD,WAGtD,MACA,iBAEA,SADA,SAoQA,aACA,IACA,KACA,4CAAsD,WAGtD,uBACA,wBAGA,gCACA,8BACA,oCACA,mBACA,gCAIA,iBACA,yBAGA,6BACA,MAIA,cAKA,0BACA,8BACA,gBAEA,eAMA,iCACA,4BAEA,qBACA,kBACA,sBACA,iBACA,OA6EA,YACA,oBACA,uBACA,cACA,uBACA,yBACA,eACA,IAMA,CAkZA,aACA,IACA,KACA,4CAAsD,WAGtD,uBACA,wBAEA,uBACA,yBAGA,yCACA,kBAEA,YACA,OACA,SAEA,mCACA,MAGA,oBAEA,uEACA,uBACA,qBAEA,iBACA,sBACA,uBAEA,8DAEA,KACA,iBAGA,iBACA,oBAEA,6BAEA,QACA,GA71BA,QACA,QACA,aACA,aACA,uBAaA,2BACA,UACA,gBAIA,EACA,qBA8BA,EAEA,qCACA,uDACA,eACA,aACA,6DAGA,iBACA,mBACC,IAED,oCACA,sDACA,eACA,aACA,4DAGA,iBACA,kBACC,IAED,YACA,qCACA,SACA,gBAAmB,SACnB,OAMA,EACA,YACA,yBACA,iBACA,6CAEA,oBACA,mBAEA,yBACA,oBAiBA,EACA,YACA,2BACA,YAGA,gBACA,EACA,iBACA,uBACA,mBACA,aACA,sBACA,kBACA,MACA,wBAGA,2CACA,4BACA,+CACA,wBACA,cAEA,WACA,CACA,yBACA,gCACA,+BACA,8BACA,wDAEA,MAAK,QACL,aA7BA,KAiDA,EACA,YACA,oCACA,kBAMA,UACA,mBACA,UACA,kDAGA,OACA,8DAEA,8BACA,cAEA,oCAEA,cAEA,UACA,oBACA,kBACA,eACA,mBACA,6BACA,2BACA,YAEA,mCACA,mBAMA,kBACA,yBACA,iCACA,0CACA,kDAGA,iCAGA,sBAMA,eACA,KACA,oBACA,0BACA,iCACA,0CACA,kDAGA,iCAGA,IAEA,CACA,UAEA,EA+BA,oBAoDA,uCACA,YAQA,WACA,EACA,yBACA,uBAEA,2CACA,kDACA,6BACA,kEACA,YACA,qBAOA,sCACA,gCACA,0BAEA,WAAsD,OAAY,QAClE,OACA,OACA,wBACA,kCAEA,kBACA,8BACA,yBACA,gCAEA,iBACA,0BAGA,SAGA,WACA,OAEA,CAGA,gCADA,6BAKA,EACA,qBAIA,EACA,4CACA,eACA,+CACA,4CACA,aAAK,EACL,KAKA,IAeA,YACA,0BACA,WACA,IACA,IACA,IACA,IACA,IACA,MACA,SACA,IACA,KACA,KACA,KACA,WAEA,EACA,QACA,kBACA,IACA,MAEA,UACA,kBAEA,QACA,OACA,QAOA,gBAAyB,IAAc,WAKvC,6BAJA,KAQA,OAFA,aACA,YAES,WACT,OACA,GACA,OACA,kBACA,UACA,OAGA,WACA,6BAGA,6CACA,6BAGA,0CACA,MAGA,uBACA,OAEA,gBAEA,0BACA,QAGA,sBACA,OAEA,6BAGA,uBACA,OAEA,eAEA,wBACA,QAIA,OACA,QACA,mCAEA,OAGA,OACA,0CAEA,4BACA,iCACA,oBAKA,EACA,YACA,aACA,qBAMA,IACA,4BACA,gDAEA,SACA,2BACA,kDAGA,eACA,eAKA,EACA,YACA,6BACA,WAAuB,8BAAwC,WAC/D,WAMA,yDACA,iCAEA,wCACA,yCACA,EACA,QACA,CAGA,uBACA,QACA,CAqBA,EACA,YACA,+BACA,OACA,0BACA,mCAGA,kBAEA,oBACA,mBACA,gBACA,oBACA,wDAGA,+BACA,YAEA,2DACA,2BACA,MACA,2BACA,MACA,sCAGA,wCACA,YACA,0BAEA,OACA,CACA,wCACA,yCACA,MAEA,OACA,CAEA,OACA,QACA,UACA,YACA,UAEA,KAKA,EACA,YACA,kCACA,cAGA,0DACA,6CAA+C,OAAmB,QAClE,EAMA,EACA,YACA,8BACA,UACA,qBAGA,SACA,0CAGA,6BACA,gDAGA,eACA,MACA,uDAKA,8BACA,OACA,gCACA,gDAGA,yBACA,gCACA,wDAEA,OAMA,CACA,WAGA,4BAEA,6BAoBA,EACA,YACA,gCACA,kBACA,aACA,0CAEA,8BACA,aACA,MACA,YACA,gBAGA,sBAEA,iBACA,CACA,iCACA,kCAGA,kBAEA,oBACA,kBACA,eACA,mBACA,+CAGA,+BACA,YAEA,qCACA,aACA,iCACA,0CACA,kDAGA,MAEA,OACA,MACA,YACA,gBAEA,OAEA,EA8CA,yBAiDA,uCACA,YAIA,cACA,qBAIA,EACA,4CACA,eACA,WACA,KAAmB,mBAA2B,OAC9C,cAAqB,uCAA+C,OACpE,sCAGA,YACA,QAiBA,IACA,YACA,+BACA,OACA,0BACA,mCAKA,6BACA,uBACA,yCAKA,2BACA,kCACA,eACA,UAGA,qDASA,QACA,+CACA,YACA,qDACA,gDACA,EACA,UAEA,OAhBA,QACA,UACA,YACA,UAIA,KAcA,EACA,YACA,kCACA,wCACA,mBACA,yBACA,EAMA,EACA,YACA,8BACA,WAAmB,mBAA2B,WAC9C,YAEA,0BACA,uBACA,KAEA,QACA,CACA,WAGA,4BAEA,6BAeA,EACA,YACA,gCACA,WAAmB,qBAA2B,OAC9C,cAIA,cAGA,uEACA,6BACA,OACA,QACA,sCACA,YACA,4CACA,uCACA,EAEA,IACA,QAGA,QACA,MACA,YAEA,KAMA,EACA,YACA,yBACA,0BACA,2BACA,aAAmB,mBAA2B,OAC9C,mBACA,0BACA,qBAAqB,MAA4B,WACjD,OAEA,gCACA,QACA,mDAEA,6BACA,uBAEA,wCACA,kBACA,qBAMA,iBACA,CACA,yBACA,+CACA,qBACA,qDACA,gDACA,EACA,kBACA,8BACA,eAGA,iCACA,QACA,yDAEA,OAGA,8BACA,iEACA,6BAEA,2CCpjCA,CAkBA,uBAUA,wBACA,WACA,eAIA,SAEA,IAEA,MAKA,oBACA,gCAOA,IAEA,MAIA,oBAGA,yBAGA,GAmBA,CAhFA,yBACA,oBAcA,EAkEA,0BACA,IACA,oBAGA,eACA,kBACA,yBACA,WAMA,OACA,UAGA,wBAGA,IACA,wBCpFA,CACA,iBACA,OACA,UACA,KACA,MASA,CACA,eACA,oCACA,KAaA,CACA,mBAKA,QAYA,OACA,WAEA,EACA,mBAQA,KAAmB,IAAO,IAC1B,IACA,kBACA,EAIA,gBACA,aAIA,YACA,WACA,IACA,CASA,CACA,yBACA,kBACA,oBC5GA,CA6BA,qBACA,eACA,uBACA,qBACA,2BACA,2BACA,yBACA,OACA,yBACA,MASA,CA7CA,YACA,uBAIA,MAGA,YAkBA,qBAoBA,EACA,uCAGA,gBAuFA,yBACA,SACO,WACP,OACA,aACA,UACA,qBACA,eAGA,qBACA,MACA,CACA,OA9FA,UACA,qBACA,SAEA,qBACA,SACA,IAGA,QAKA,IAEA,KAgEA,gCA/DA,IAGA,eAEA,kBACA,KACA,MAES,MAIT,SACA,kBAEA,mBAOA,uBALA,uBACA,gBAEA,YACA,IAMA,UACA,qBACA,KAEA,2BACA,SACA,sBACA,kCACA,qBACA,eACA,CACA,GAAK,EAEL,MAGA,oBAGA,kBAIA,mCACA,SACA,oBACA,UACA,cAEA,aAEA,sBAEA,IAuBA,EACA,2BACA,UACA,gCACA,MACA,MAAK,EAEL,oBAEA,oCAIA,sBACA,WAGA,uFACA,KAOA,EACA,+BACA,UACA,8BAAiC,EAAQ,KACzC,iBAGA,oBACA,iCAGA,yBACA,WAGA,uFACA,KAQA,EACA,4BACA,6BAC6C,OAA7C,EAAsD,IACtD,WACA,YACA,OAGA,QACA,YAAoB,aACpB,iBACA,iBACA,iBAIA,MAOA,EACA,4BACA,qBAGA,OAFA,EACA,SAEA,OACA,KAAe,MAAW,EAC1B,gBACA,eAEA,oBACA,kBACA,UACA,OACA,KAQA,EACA,sCACA,0CACA,SACA,QAEA,kBACA,2DAGA,mCAEA,cACA,IAQA,EACA,YACA,8BACA,uBACA,iBAOA,EACA,YACA,8BACA,6BAA+C,OAAS,IACxD,SACA,iCAIA,iDACA,wBAAyC,OAAS,IAClD,gDAEA,MAKA,EACA,+BACA,OACA,GAIA,4BAHA,CACA,IACA,IAMA,EACA,6CACA,OACA,MACA,QACA,SAEA,KACA,SACA,OACA,OACA,OACA,OACA,mCACA,GACA,QACA,iBACA,eACA,wBACA,cACA,YACA,cACA,oBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAGA,WACA,WACA,SACA,WACA,KAEA,uBACA,WACA,QACA,cAGA,YACA,KAEA,sBAA4C,OAAc,IAC1D,MACA,gBAlWA,MAmWA,gBAEA,IACA,SACA,KAEA,sBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAIA,UAGA,QACA,wCACA,GACA,qBAEA,GAAU,aACV,QAEA,4BCtZA,kB,yFCAA,UACA,OACA,QAIA,QACA,SAA2B,IAE3B,GAAqB,GAAmB,KAExC,OAUE,cARQ,MAAO,QAAG,GAAI,GAEd,aAAS,UACT,UAAkB,mBAElB,UAAQ,SACR,SAAS,UAOI,UAAU,EAG7B,WAAsB,KACR,cAAM,KACL,uBAAM,KAGrB,YAAmB,EAChB,GAAkB,EAClB,IAAkB,EACd,QAAkB,EACjB,aAAkB,EAChB,gBAAM,KACL,mBAAM,KACX,UAGW,wBACD,sBAGQ,sBAEA,WAKT,4BAAc,cAKzB,cAAO,OAAG,GAAI,GACF,mBAAO,OAAK,KAE5B,WACA,QAAG,IAAG,GAAc,cAAE,IACZ,CACR,IAEF,KAAO,QAAG,GAAY,YAAkC,KAC9C,CACH,OACL,cAMI,QAAO,OAAG,GAAQ,QAAG,KAEpB,OACD,mBAAI,KAA2B,2BAGrC,SACD,EAEU,OACT,IAAa,GAOT,OAAO,OAAY,YAAK,KAAoB,oBAAE,IAC5C,MAAmB,mBACnB,UAAU,UAEL,OAAG,EACZ,KAEE,QAAO,OAAY,YAAK,KAAkB,kBAAE,IAK1C,SAAU,UAAG,EAEb,aACJ,kBAEE,QAAO,OAAY,YAAG,GAAkB,kBAAE,IACxC,MAAO,OAAY,YAAyB,yBAAE,EAClD,EAEE,QAAO,OAAY,YAAG,GAAgB,gBAAE,IACtC,MAAO,OAAY,YACnB,oBAAO,OACX,MAGF,KAAO,QAAK,KACM,iBACmC,OAC7C,MAEA,0BAEP,kBAEG,QAAO,OAAG,GAAQ,QAAE,IAAU,KAAO,OAAY,YAAK,KACtD,eAAO,OAAG,GAAO,OAAE,IAAU,KAAO,OAAY,YAAK,KAEzD,WAAgC,iCAAK,KAEjC,aAAO,OAAS,kBACtB,SAAC,cAMuB,mBAClB,CAAK,KAIL,qBAAQ,QAAK,KAAW,WAC7B,KAGD,IAA0B,iBAClB,OAAC,CAAC,CAAK,KAAS,UAAI,CAAC,CAAK,KACjC,iBAEa,CAAe,UACvB,MAAO,OAAG,GACf,WAMe,CAAe,YACvB,OAAK,MAAQ,QAAG,GACvB,aAEiB,cACV,OAAK,MAAO,OACnB,aAGe,YACR,OAAK,MAAO,OACnB,WAEa,UACR,MAAO,OACZ,SAEW,QACN,MAAO,OACZ,OAGU,OACL,MAAO,OACZ,MAGmB,CAAgB,gBAC9B,MAEA,YAAO,OAAY,YAAK,KAAa,aAAE,CAC5C,QAGmB,CAAsB,gBACpC,MAEA,YAAO,OAAY,YAAK,KAAa,aAAE,CAC5C,UAG2B,CAAoB,wBAC1C,MAAO,OAAY,YAAK,KAAsB,sBAAE,CACrD,SAGiB,cAChB,MAAa,GAAG,EAAI,KACjB,qBAAS,KACV,MAAU,GAAG,EACT,6BAAO,OAAY,YAAK,KAAW,WAAE,CAE7C,QAAC,CAG0B,CAGd,2BAEP,MAAO,OAAY,YAAK,KAAoB,oBACnC,CACN,cAGT,QAAC,OAEgC,CAEhB,+BAIf,MAAO,GAAG,EACT,SAA2B,2BACtB,KAAO,OACX,CAAa,cAAW,WACxB,IAEJ,CAAC,EAGmB,CAAa,gBAG/B,MAAmB,GACZ,OAAO,EACL,cAAO,EACV,aAAO,EAET,WAAO,OAAY,YAAK,KAC7B,2BAOD,IAAmB,WACX,OAAK,MACZ,SAQD,IAA4B,oBACpB,OAAK,MACZ,kBAEa,UACR,MAAO,OAEd,WA3QD,EA2QC,0CCvJkD,aAC9C,IAAS,EACJ,kBAAS,GAGd,eAAS,EAAM,KAChB,CAEA,KAA+B,GAAa,EAEzC,6BACD,UADkC,cAEhC,MAA4B,GAA4B,EACrD,WACK,QADyB,WAGlC,SAAY,QACJ,SAAM,MAEjB,2CACD,CAEK,OACP,KAQE,CAC+B,aAChC,MAAO,GAAO,EAAM,MACd,iBAAE,GAAI,EAAG,GAChB,IAME,CAC8D,aAI/D,MAAQ,GAAwC,EAC7C,MACD,QAAM,IAAU,oCAAqC,EACvD,KACA,SAAa,GAAW,EACxB,QAAa,EAAW,EACxB,QAAW,EAAW,EACtB,MAAa,EAAW,EACxB,QAAiB,EACjB,KAAe,EAAe,EAAS,EAGhC,cAAS,EACd,UACQ,eACF,CACE,UACC,WACE,QACA,UACI,UAEZ,cACH,iBACQ,kBAAC,CAAI,KAAM,KAAa,YAChC,eACE,eAAU,GAAuB,EAAS,EACpC,iBACF,CACE,UACC,cACE,QACA,UACH,UAEL,OACH,iBACQ,iBACF,CACE,UACC,WACE,QACA,UACI,UACJ,cAER,UACH,iBACQ,cACF,CACE,UACC,QACE,QACA,UACI,UACJ,cAER,UACH,aACQ,cAAC,GAAW,YACR,EACR,+BAAkC,EAG1C,IAAC,KAWE,CACkE,eACnE,MAAW,GAAO,EAAM,MAoBlB,aAAC,CAAI,KAAM,KAAQ,OAC1B,SAOY,aACR,EAAG,GAA2B,KAE7B,KAAC,KAAU,KAAQ,GAClB,QAAI,IAAK,EACT,MACS,aADJ,KAAK,QACI,EAIb,QACP,QAE2E,CAE5D,aAEP,OACmB,UAApB,KAAK,MACkB,aAAvB,KAAK,MACe,UAApB,KAAK,MAGZ,OAFO,KAAK,KASkC,aACvC,OAA0B,WAArB,KAAK,MAAwB,EAAQ,SAAQ,EACzD,yDAtTD,UA8HG,IA2HH,EA2BG,uBAgBH,EAeG,uBACH,EAWG,mBACH,EAkCG,oBAhC6B,aAE9B,MAAwB,GAAY,EAEhC,kBAAC,KACA,WACE,MACG,EAAU,WACV,EAAU,UAER,kBAKN,eACP,OAiBD,OA2Be,OAAqB,YAChC,MAAS,GACM,WAGhB,SADO,MAIR,CAGqC,kBAE/B,MACA,YACA,iBACL,cAKiB,CAAW,cACrB,OAAK,MAAa,aACzB,MAMc,CAAe,WAC5B,MAAY,GACZ,KAII,SAAC,KAAc,KAAQ,MAAW,UACpC,IAGG,MAAC,CAAS,EACA,GACP,QAEJ,MAAU,GAAS,EAAI,IAAS,EAE7B,OAAK,GACK,aADG,KAAK,OACD,EAMpB,SACD,MAED,IAEG,GAAS,EACK,iBAAS,EAAI,IAAS,EAAa,aAGxC,OAAK,KACb,IAAa,EACX,QACC,aAAa,EACN,MAEf,gBAEK,OACP,aAeoB,CACM,iBACF,KAEvB,MAAiB,GAAO,KAAa,aAAI,IAAY,EAElD,OACK,SAGL,SACD,aADa,KAAK,UACZ,IACJ,gEAAoE,EAExE,IAEA,SAAqB,GAAO,KAAU,UAAU,UAC7C,KAAqC,CAKrC,CALK,KAAM,MAAqB,eAKX,CAChB,CADW,WAInB,WAAkB,GAAO,KAAU,UAAM,MAAE,EAAiB,EAEzD,GAAiB,KAElB,MAAkB,GAAc,EAAK,KAAM,MAC/B,UAAK,sBAAiB,EAAK,MACnC,iBACQ,QAAK,KAAY,EAGzB,YAAY,OAAK,KAAmB,OAAM,KACjD,aASoB,CAAY,iBAE5B,IAAC,CAAK,EACD,SAGR,WAAkB,GAAO,KAAU,UAAU,UAAE,KAAK,EAAG,KAAS,EAE7D,OAAkB,CACb,CADQ,WAIhB,WAAkB,GAAO,KAAU,UAAM,MAEnC,WAAY,OAAK,KAAmB,OAAM,KACjD,aAUkB,CAAY,eAC7B,MAAkB,GAAO,KAAU,UAAU,UAAE,KAAK,EAAG,KAAS,EAE7D,OAAkB,CACb,CADQ,WAIhB,WAAkB,GAAO,KAAU,UAAM,MAAE,EAAc,EAEnD,SAAY,OAAK,KAAmB,OAAM,KACjD,aAiBsB,CAAmB,mBACxC,MAAiB,GAAO,KAAa,aAAI,IAAS,EAI/C,OACK,SAGR,WAAqB,GAAO,KAAU,UAAU,UAC7C,KAAqC,CAKrC,CALK,KAAM,MAAqB,eAKX,CAChB,CADW,WAInB,WAAkB,GAAO,KAAU,UAEnC,QAAgB,EAEJ,KAAiB,mBAAkB,MAG3C,qBAAC,GAAK,GAAkB,EAAI,EAAG,EAAe,EAAO,OAC3C,IAAG,sBAAuB,MAMpC,0BAAC,GAAK,GAAkB,EAAI,EAAQ,CAAL,IAAU,IAC3C,MAAU,GACV,KAAe,EAAe,EAAE,EAEhC,GAAkB,EAAO,EAAM,MAAK,KAC9B,KAA+B,aAAvB,KAAK,MAA0B,EAAG,KAAc,EAGlD,IAAG,mBAAY,MAC5B,gBAEK,OAAY,OAAK,KAAmB,OAAM,KACjD,aAewB,CAAY,qBACnC,MAAkB,GAAO,KAAU,UAAU,UAAE,KAAK,EAAG,KAAS,EAI7D,OAAkB,CACb,CADQ,WAIhB,WAAa,GAAO,KACpB,aAAkB,EAAO,KAAU,UAEvB,QAAc,mBAAe,MAKrC,0BAAC,GAAK,GAAe,EAAI,EAAQ,CAAL,IAAU,IACxC,MAAU,GACV,KAAe,EAAe,EAAE,EAEhC,GAAkB,EAAO,EAAM,MAAK,KAC9B,KAA+B,aAAvB,KAAK,MAA0B,EAAG,KAAc,EAGlD,IAAG,mBAAY,MAC5B,gBAEK,OAAY,OAAK,KAAmB,OAAM,KACjD,aAOe,YACR,OAAY,OAAK,KAAK,KAAE,CAAK,KAAM,MAAM,KAElD,eArTD,EAqTC,2BCxpBD,aAEA,QACA,OACA,OACA,QACA,cAEA,qBACA,cAeA,8CACA,cAEA,aACA,8BACA,QACA,QACA,gBACA,wBACA,UAEA,cAoCA,MACA,MAIA,MACA,SACA,YACA,aACA,QACA,YACA,iBAEA,wBACA,+BACA,uDACA,MAAK,UACL,CAEA,cAGA,IAIA,QACA,UACA,cACA,kBAAK,SAEL,CACA,CAEA,aAEA,CACA,kBACA,eAEA,aACA,CACA,GAEA,aAEA,CACA,IACA,GAEA,aAgBA,sBACA,6BACA,UACA,iCACA,4BACA,cAEA,KAGA,uBAzIA,yBACA,SAIA,oBACA,MACA,mCACA,YACA,YAEA,oCAEA,MAXA,EACA,EACA,KAsIA,KACA,eAAG,SAEH,CAGA,kBAtHA,iCACA,iBACA,GAIA,cAHA,8BAKA,+BACA,8BAEA,wCACA,cACA,YAGA,aACA,kBAIA,iCACA,eACA,aAGA,cACA,oBAIA,SACA,CAEA,CAuFA,mBACA,uBACA,4BAGA,QACA,QAAa,UAAgB,CAC7B,SAAa,UAAgB,CAC7B,aAAiB,UAAoB,KACrC,cAAkB,UAAqB,MACvC,mBAAuB,UAA0B,WACjD,oBAAwB,UAA2B,YACnD,EACA,YACA,WAEA,kBAnDA,eACA,eAEA,2BACA,gBAEA,uBACA,iBACA,eACA,gBACA,YACA,GAEA,qBCjIA,mBACA,CACA,sBACA,MAEA,SACA,wBAAgB,CAGhB,iBACA,SAEA,MACA,0BAEA,eAEA,0BACA,MAEA,kCACA,IACA,YACA,OAEA,iBACA,UACA,uCACA,GACA,OACA,UACA,GAKA,MACA,8BAGA,qBACA,SACA,OAGA,IACA,GApDA,QACA,OACA,wBAEA,8BAkDA,wBACA,IACA,uBAAgB,CAGhB,iBACA,SAEA,MACA,0BAEA,eAEA,UAEA,cACA,GACA,iBACA,IACA,SACA,UACA,UACA,eACA,gBACA,SAKA,MACA,WACA,MACA,KACA,WACA,SACA,CACA,OACA,qBAGA,SAEA,CACA,2BCpEA,aACA,kBACA,WAEA,aACA,+BACA,uDAGA,0CAEA,6BAEA,iBACA,OACA,WACA,KAEA,sCAGA,YACA,aAGA,WACA,YACA,QAEA,kBACA,KACA,KAEA,gCACA,eAAe,MAAc,OAC7B,mBAEA,SACA,QACA,IACA,OACA,OACA,IAAG,SACH,CACA,QAGA,gBACA,OAEA,eACA,SAEA,kBAAyB,EAAQ,KACjC,aACA,KAIA,wBAAyB,EAAQ,KACjC,SACA,qBAEA,0BACA,SA7FA,sBACA,UACA,SAEA,gCACA,cAEA,IAGG,uCACH,sBAIG,qCACH,oBAWA,wBAFA,sBCrBA,aACA,OACA,oBACA,QACA,SARA,YACA,6CAEA,wBCIA,aACA,OACA,wDAGA,aACA,OACA,IACA,oBACA,kEACA,yDAEA,cAnBA,sCACA,uCACA,UAAC,IAED,kBAEA,cAKA,8CCiZ6B,aACrB,OAAkB,OAEd,KAAY,YAAK,KAAa,aAAE,CAEtC,WAAO,QAAK,KAAa,aAAE,CAGjC,QAAC,EAgB0D,eACnD,UAAW,OACT,OAAK,EAAqB,KAAW,EAI9C,SAKE,CACmC,aAC9B,OAAkB,OACnB,IAEH,GAEA,YAAM,CAEH,iBAAU,IAAkB,EAClB,SAAc,cACd,KAAK,KAAsB,sBAE3B,MAAc,cAAQ,KAC/B,MAAiB,GACN,IAAkB,EAM7B,OAAiB,EAEjB,OAAmB,EAAc,EAAK,KACnC,KACU,IAAkB,EAAG,GAAkB,IAMpD,KAAa,EAGF,iBACA,mBAAK,KAEpB,wBAEJ,EAAC,C,YAhDkB,qDAtbnB,UACA,OAEA,QACA,QAEA,QACA,QAEA,IAAqC,EAGrC,0BAAoC,EAER,mBAE5B,EA2YG,iBA3YH,SAC0C,IACF,IAEtC,MACA,MAAe,EAAwC,CAAM,KAGnD,eAAK,KACN,OACE,0BAEE,OACA,6BAAM,EACT,iBAEK,WAEF,OACH,uBACS,0BACN,oBAAM,EAEJ,uBAEF,OACH,qCACG,oBAAM,EAEJ,kBAEH,MACG,mBAEA,MACT,CAAM,KAAU,QAChB,CAAM,KAAgB,cACtB,CAAM,KACG,YACT,CAAM,KAKZ,gBAAc,GACP,CAAY,MACV,gBAEE,CAAY,MACf,0BACG,uBAAM,EACA,iCAEJ,iBAEF,CAAY,MACf,gCACS,mCACN,oBAAM,EACZ,yBAEM,CAAY,MACf,4BACS,+BACN,0BAAM,EAqBT,yBAEA,UAAK,KACN,CAAY,MACV,eAAE,CACP,CAAM,KAAQ,OAAmB,MAAqB,QACtD,CAAM,KAAQ,OAAmB,MACxB,UACT,CAAM,KAAO,MAAmB,MAAmB,OACnD,CAAM,KAAQ,OAAmB,MAAqB,QACtD,CAAM,KAAS,QAAmB,MAAuB,SACzD,CAAM,KAAa,YAAmB,MAIlC,mBAAK,KACN,CAAY,MACV,gBAEE,CAAY,MACf,kBACS,2BACN,oBAAM,EACZ,mBAEM,CAAY,MACf,kBACS,2BACN,oBAAM,EACZ,mBAEM,CAAY,MACf,0BACS,mCACN,oBAAM,EACZ,sBAEM,CAAY,MACf,wBACS,iCACN,oBAAM,EAEJ,oBAEF,CAAY,MACb,0BAEG,sBAEF,CAAY,MACN,yBACN,oBAAM,EAAc,EAC1B,QAEM,CAAY,MACN,sBACN,oBAAM,EAAc,EAC1B,KAEM,CAAY,MACN,uBACN,oBAAM,EAAc,EAElB,QAEF,OACH,aAMS,4BACN,kBAAiD,UAErC,MAEhB,QACM,UAAqB,cAC7B,eAEG,IACG,gBAAY,MAGN,sCACQ,IAEd,mBAAiD,UAErC,MAAY,YAKjC,gBAEM,QAAK,KACN,CAAY,MACf,gBACK,sBAED,IACG,OAAY,MACN,mBACN,oBAAM,EACZ,SAEG,IACG,OAAY,MACN,mBACN,0BAAM,EACZ,SAEM,CAAY,MACf,YACG,0BAAM,EAEJ,wBAEL,IACG,4BAAY,MACN,6BACN,0BAAM,EACZ,8BAEM,CACH,WACS,4BACN,eAAM,EACZ,kBAEM,CAAY,MACf,oBACS,qCACN,0BAAM,EACZ,2BAEM,CACH,WACS,mCACN,0BAAM,EAEJ,2BAEF,CAAY,MACf,+BACG,iCAAM,EAKT,kCAAK,KACN,CAAY,MACf,YACK,kBAEE,CAAY,MACf,sBACS,4BACN,0BAAM,EACZ,kBAEM,CAAY,MACf,kBACG,sBAAM,EACZ,kBAEM,CAAY,MACf,kBACG,sBAAM,EAEJ,oBAEF,CAAY,MAGf,gCACG,sBAAM,EACZ,kBAEM,CAAY,MAGf,qCACG,qBAAM,EAEJ,mBAEF,CAAY,MACf,uBACS,6BACN,0BAAM,EACZ,mBAEM,CAAY,MACf,yBACS,kCACN,oBAAM,EAMP,6BAAK,KACP,MACG,iBAAE,CACP,CAAM,KAAc,YACpB,CAAM,KAAU,QAChB,CAAM,KACG,WACT,CAAM,KAKZ,iBAAqB,GACd,CAAY,MACZ,4BACH,GAAK,MAAa,aAErB,gDAED,GAAwB,EACjB,CAAY,MACZ,sCACH,GAAK,MACH,0EAA6D,EAAG,IAEpE,YACD,GAED,GAAoB,EACb,OACA,0BACH,GAAK,MAAa,aAErB,0CAED,GAAkB,EACX,CAAY,MACZ,6BACH,MAAa,GAAG,EAChB,wBAAsB,iBACf,KAAC,IACJ,GACA,uBACI,MAAI,KACR,GAAG,IAAQ,QAAK,EAEtB,QACD,EAED,GAAe,EAwBL,qBAAK,KACP,MACG,OAiBX,cAEM,iBAAC,EAAI,KACZ,sBAsBD,GAIC,GAJD,CAAkB,WAChB,cACA,kBACA,gBACD,QAJiB,MAM8C,KAChE,KAAmB,GAAG,CAAE,EAAK,IAAM,KAAK,IAAM,KAC9C,GAAoB,EAAgB,EAAQ,QAKzC,sCChbS,eAEV,MAAW,GAAO,EACd,UAAC,KAAoB,QAEpB,IAAc,EACT,OAIR,cAAa,GAAO,EACjB,QAAS,KACV,MAAW,GACR,OACK,KAGZ,QAAC,CAEK,OACP,4CAvB2C,WAC5C,EAsBC,iDCDuC,aACtC,IAEG,SAAK,EAAQ,kBAAY,GACtB,SAAC,KAAiB,KAAQ,GAAQ,QACjC,MACS,OAKb,SAAW,GAAQ,EACd,KAGR,cAAQ,GAAgB,EAErB,SAAuB,eAApB,MAIF,eAJ4B,SAMjC,c,kDA7CD,UASG,GACH,EAUC,aAVD,UACE,MAAU,GAAG,EAAI,KAEd,qBAIC,SAAC,KAAkB,KAAQ,GACtB,MAEV,uBCpBqC,aAuCjC,kBACH,MAAW,GAEX,IAAa,KAAc,SAAqB,KAC9C,IAAS,GACT,KAAS,EACT,KAAU,EACV,GAGA,UAAa,GAAG,IACX,CACI,UACD,OAEP,KACM,UAAK,KACF,qBAAC,IAEX,CAAC,GAED,YAAa,GACH,CACH,kBAAE,CAAS,SAAQ,OAAS,QAG9B,WAAe,EAAY,QAAE,CAAO,OAEzC,uBAAa,GAER,KAAG,GAAQ,QAAW,KACrB,CACC,KACL,GAEG,KAAO,OAAG,GAAO,OAAe,KAC5B,GACP,OAEG,KAAG,GAAQ,QAAuB,IACjC,CACG,aAAe,eACnB,UAAQ,EACH,WAAS,OAAgB,UAAS,SAGnC,WAAC,CAAQ,SAEpB,SAAE,EAEF,GAAM,CAAQ,SAAS,SAIf,iBAIT,OAED,YACK,OAAQ,SAAI,IACP,MAAQ,QAAI,IAGd,MACP,WAOE,CAE4C,mBAM7C,MAAkB,GAAG,KAClB,KAIH,WAAS,GAEL,OAAC,KAAU,KAAgB,GAAM,MAAG,EACnC,QAAK,EAAS,SAAM,KACrB,MAAgB,GAAO,EAAM,MAC1B,QACE,CADS,KAAO,SACL,EAAI,IAAa,EAC3B,OACJ,MAAO,GAAa,EACpB,QAAO,EAAa,EAAK,KAEpB,SAGT,OACF,CAEiB,CAClB,KAOE,CACgD,aAC7C,KAAC,KACA,QAAiB,EAIb,iBAAS,OAEnB,KAKE,kDAlKH,UACA,QACA,OASA,GAAsB,EAAG,GAAO,KAAC,CAW9B,wBACH,EAaG,mBAbuD,WAClD,CAAW,MAAI,CAAQ,EAAI,IAClC,KA0ID,EAEC,4BAFD,UACQ,OACP,OAED,KAAqB,GAQlB,eACH,EA6CC,kBA7CD,UAEU,OAAQ,SAAQ,QA2CzB,sFC/ND,UACA,QAAuD,KAyCvD,EAuEC,YAvEsC,WACrC,MAAe,GAAM,EACrB,YAAc,EAAY,EAC1B,SAAa,EAAmB,CAAM,KAAW,UAC9C,UACK,GAGR,cAAgB,GAAW,EACxB,iBACK,OADM,WACL,CAAM,KAAS,QAAM,KAAW,EAAM,MAM/C,WAAc,GAAY,EACvB,YAAU,IACL,CADiB,IAAO,OAKhC,cAAgB,GAAW,EAAO,OAE/B,MAA2B,UAAhB,KACZ,CAGA,KAAY,GAAqB,IAEjC,OAAiB,EAAY,EAE7B,MAAQ,EAAc,EACtB,GAAY,EAAc,EAC1B,OAAc,EAAc,EAEzB,SAAI,KAEF,IAAC,CAAQ,QACJ,QAIL,YAAC,CAAY,YACR,QAET,QAGI,WAAC,EAKA,yBACA,MACD,2BACG,MACJ,SAGN,KAAC,WAEE,OACK,eADM,KAEN,MACA,iCAKT,4FC9GwF,WACzF,KAA2B,GAE4C,8DACvE,EAOgE,oBAPhB,WACxC,OAAK,GACqB,UAAM,KAC5B,QAAO,OAAM,KACb,QAAM,MACjB,KAGD,EAEC,oBAF+C,WACxC,OAAsB,GAC7B,uCCmBI,kBACH,MAAoB,GAAC,CAAY,YACjC,iBACD,KAEI,kBACH,MACA,UACD,KAEI,kBACH,MAAa,GACb,SAAM,GACN,sBACA,WACA,WAAW,GAAG,KACX,KACD,CADO,GAAiB,kBACH,GAAC,CAEzB,SAKE,CACH,YACQ,OAAK,GAAQ,QAAQ,QAAS,SACrC,aAEkE,eACjE,MAAe,GAAO,EAAQ,QAAQ,QAAS,SACzC,YAAK,GAAiB,WAAM,EACnC,UAYE,CACyD,mBAC1D,MAAmB,GACV,IAIT,mCAAmB,EAAyC,uBAC5D,OAAoB,EAAO,EAAa,OAElC,oBAAC,GACR,eAE2D,mBAC1D,MAAmB,GACV,IAIT,kCAAmB,EAEa;;cAChC,SAAoB,EAAO,EAAa,OAElC,gBAAC,GAAoC,cAAE,CAAU,SAAQ,OAAM,KACtE,KAE6D,CAE7B,mBAE/B,MACD,QAImD,aAC5C,OAAoB,GAAC,CAElB,qBACH,KACK,EAAK,KAEjB,OAEI,kBACH,MAEA,UAAW,GAAG,KACd,KAAa,EACb,IAAyB,EAAQ,EAAO,OAAE,KACpC,aACP,MAED,YACQ,OAAoB,GAAC,CAC5B,uBAEI,kBACH,MAAmB,GAAK,EACrB,UAAe,KAChB,MAAyB,GAAO,EACjB,OACJ,UAGX,sBAAY,EAAG,KAAM,GACrB,cAAe,EAA4B,EACvC,CAAY,YAAY,WACxB,CACE,mBACF,KACE,OAAe,GAAC,CAAY,YAErC,WAEiD,CAC7C,kBACH,IACA,QAAgB,GAAU,QACvB,eAAY,KACb,MAAkB,GAAO,EAAK,KAAQ,QAAI,IAAW,WACvC,cAAO,EACP,OACO,oBACb,OAGJ,iBACU,QAGhB,sBAAU,IACI,aACM,mBACJ,eAWf,WAED;;;;OAAY,EAAG,KACf,QAAgB,EAAS,EAAQ,QAAa,aACxC,UAAW,GAAM,MAAM,MAAO,OAAQ,KAAW,EACxD,OAE4B,CAC8B,mBACzD,IACA,QAAgB,GAAU,QACvB,eAAY,KACb,MAAkB,GAAO,EAAgB,OACjC,cAAO,EAAkB,OAC7B,WACI,QAGV,gBAAoB,KAAE,CAAO,OAAO,EAAK,KAC1C,MAE4D,CACF,eACzD,IACE,MAAW,GAAe,EACpB,qBAAY,SAAyB,OACzC,IAAU,GACL,KAAO,OAAG,GAAO,OAAM,KACpB,CACN,IAEG,KAAG,GAAQ,QAAM,KACjB,CACM,CADD,KAGA,OAAC,GAAU,OAAmB,aAAQ,KAC9C,eACA,KAEG,KAAG,GAAQ,QAAa,KACrB,CACN,IAKG,KAAM,MAEf,KAAC,GAAc,QACP,OAAQ,SAElB,SAAC,C,kDA7OD,UACA,QACA,OACA,OAEA,IAAe,EAAO,EAAQ,QAAQ,QAAS,SAC/C,MAAgB,EAAO,EAAkB,UACzC,MAAkB,EAAO,EAAQ,QAAK,EAAgB,OACtD,eAAa,EAAO,EAAS,SAAQ,QASlC,UACH,EAgBC,oBAhBoD,WAEjD,OACQ,yBAER,IACQ,yBAER,IACQ,2BAER,IACQ,0BAAQ,QAGZ,UACP,qFClCD,UAEmB,GAGnB,EAgEC,YA9DkC,mBAMjC,MAAU,GAAG,GAET,KAYE,KAZE,IAAO,OAAO,EAClB,QAAI,IAAU,UAAO,EAEtB,SAAM,EACH,SAAI,IAAQ,QAAO,EAGrB,SAAI,IAAW,WACf,YAAI,IAAM,MACV,8CAAI,IAAU,UAAE,EAAG,IAEpB,oBACI,KAAS,KAAU,QAClB,UAAQ,MAIhB,WAAoB,GACZ,QACH,OACI,IA/BwB,2DAgCf,gBAIlB,sCAAU,EAAG,CAAC,GAAO,EAAW,WAC1B,IACF,CACE,WAA0B,yBAC7B,yBACI,KAEP,QACE,UAAiB,SAAuB,OACtC,MAAa,GAAG,EAAG,IAEZ,aAAG,GAAW,WAAU,KAC1B,CAEH,GAFY,KAAW,WAInB,aAAe,EAAW,gBAAc,EAE5C,aACA,gBAEK,KAAG,GAEH,aACP,MACC,OAAK,KACT,0BAAU,QACN,KAAM,MAEb,mCAAC,kFCrED,UACA,OACA,QACA,QAA4C,KAE5C,GAEsC,MACtC,EAgDC,sBAhDyE,aACrE,CAIH,OAJS,MAAC,EAEP,kBAIyB,OAE5B,OAEA,oBAAiB,GAAG,GAAI,GAAW,YACpB,EAAW,SAIf,eAAU,UAAC,IACT,GACX,MAES,KAAe,eAAC,IACzB,GAAM,OAAe,eAEb,MACC,QAAoC,MAClC,8BAGL,qFADA,iJAC2D,EAAM,OAC1D,EACV,OARD,IASQ,IAEJ,GAAG,IAEL,aAAG,IAGT,MAAE,EAES,KAAQ,QAAC,IAEhB,GAAG,IAEL,aAAG,IACH,MAES,KACZ,uFCxDD,UACA,OAEA,QAEA,IAAc,EACd,IAAe,EAQZ,IACH,EA6JC,YA7JD,KASE,CAAqD,gBAPpC,MAAO,QAAG,GAAI,GAIvB,aACA,2BAGN,0BAAmB,GACZ,CACC,QACE,SACC,WACL,YAGW,wBACD,sBAGQ,sBAOA,WAKT,4BAAc,cAKzB,cAAO,OAAG,GAAI,GACd,sBACA,aACL,WAEU,OACN,KAAM,MAQL,+BAAO,OAAY,YAAK,KAAoB,oBAAE,IAC7C,KAAM,MACT,2BAEE,QAAO,OAAY,YAAK,KAAkB,kBAAE,IAC3C,KAAM,MAKL,iCACA,2BACJ,kBAEE,QAAO,OAAY,YAAG,GAAkB,kBAAE,IACxC,MAAO,OAAY,YAAyB,yBAAE,EAClD,EAEE,QAAO,OAAY,YAAG,GAAgB,gBAAE,IACvC,KAAM,MAKH,qCAAQ,QAAK,KAAgB,gBAEnC,KAEF,KAAO,QAAG,GAAc,cAAkC,IACrD,KAAgC,MAE/B,+BAEA,0BACA,iBACJ,kBAEF,KAAO,QAAG,GAAa,aAAkC,IACpD,KAAM,MACL,2CAAO,OACX,OAEF,KAAgC,iCAAK,KAEjC,aAAO,OAAS,kBACtB,SAAC,cAMuB,mBACnB,CAAK,KAAmB,oBAAQ,KAC7B,wBAAQ,QAAK,KAAW,WAE/B,KAEa,CAAe,UACvB,MAAO,OAAG,GACf,WAEoB,CAAe,iBAC9B,MAAQ,QAAG,GAChB,kBAMe,CAAe,YACvB,OAAK,MAAQ,QAAG,GACvB,aAEW,QACN,MAAO,OACZ,OAGU,OACN,KAAM,MACL,qCAAO,OACZ,MAGgB,YAGf,MAAmB,GACZ,OAAM,KAAM,MACV,cAAM,KAAM,MACf,aAAM,KAAM,MAGlB,MAAa,EACP,MAAM,KACL,UAGH,cAAO,OAAY,YAAK,KAC7B,UAEa,UACR,MAAO,OAEd","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 49);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 851348b69bb444f7fca2","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 0\n// module chunks = 0","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar queue = []\n\nvar util = require('util')\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    require('assert').equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(require('./fs.js'))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {\n  module.exports = patch(fs)\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close =\nfs.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync =\nfs.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n  ReadStream.prototype.open = ReadStream$open\n\n  var fs$WriteStream = fs.WriteStream\n  WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n  WriteStream.prototype.open = WriteStream$open\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/graceful-fs/graceful-fs.js\n// module id = 1\n// module chunks = 0","module.exports = {\n  mkdirs: require('./mkdirs'),\n  mkdirsSync: require('./mkdirs-sync'),\n  // alias\n  mkdirp: require('./mkdirs'),\n  mkdirpSync: require('./mkdirs-sync'),\n  ensureDir: require('./mkdirs'),\n  ensureDirSync: require('./mkdirs-sync')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/mkdirs/index.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"os\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"os\"\n// module id = 6\n// module chunks = 0","module.exports = require(\"stream\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"stream\"\n// module id = 7\n// module chunks = 0","/*\n * common.js: Internal helper and utility functions for winston\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar util = require('util'),\n    crypto = require('crypto'),\n    cycle = require('cycle'),\n    fs = require('fs'),\n    StringDecoder = require('string_decoder').StringDecoder,\n    Stream = require('stream').Stream,\n    config = require('./config');\n\n//\n// ### function setLevels (target, past, current)\n// #### @target {Object} Object on which to set levels.\n// #### @past {Object} Previous levels set on target.\n// #### @current {Object} Current levels to set on target.\n// Create functions on the target objects for each level\n// in current.levels. If past is defined, remove functions\n// for each of those levels.\n//\nexports.setLevels = function (target, past, current, isDefault) {\n  var self = this;\n  if (past) {\n    Object.keys(past).forEach(function (level) {\n      delete target[level];\n    });\n  }\n\n  target.levels = current || config.npm.levels;\n  if (target.padLevels) {\n    target.levelLength = exports.longestElement(Object.keys(target.levels));\n  }\n\n  //\n  //  Define prototype methods for each log level\n  //  e.g. target.log('info', msg) <=> target.info(msg)\n  //\n  Object.keys(target.levels).forEach(function (level) {\n\n    // TODO Refactor logging methods into a different object to avoid name clashes\n    if (level === 'log') {\n      console.warn('Log level named \"log\" will clash with the method \"log\". Consider using a different name.');\n      return;\n    }\n\n    target[level] = function (msg) {\n      // build argument list (level, msg, ... [string interpolate], [{metadata}], [callback])\n      var args = [level].concat(Array.prototype.slice.call(arguments));\n      target.log.apply(target, args);\n    };\n  });\n\n  return target;\n};\n\n//\n// ### function longestElement\n// #### @xs {Array} Array to calculate against\n// Returns the longest element in the `xs` array.\n//\nexports.longestElement = function (xs) {\n  return Math.max.apply(\n    null,\n    xs.map(function (x) { return x.length; })\n  );\n};\n\n//\n// ### function clone (obj)\n// #### @obj {Object} Object to clone.\n// Helper method for deep cloning pure JSON objects\n// i.e. JSON objects that are either literals or objects (no Arrays, etc)\n//\nexports.clone = function (obj) {\n  //\n  // We only need to clone reference types (Object)\n  //\n  var copy = {};\n\n  if (obj instanceof Error) {\n    // With potential custom Error objects, this might not be exactly correct,\n    // but probably close-enough for purposes of this lib.\n    copy = { message: obj.message };\n    Object.getOwnPropertyNames(obj).forEach(function (key) {\n      copy[key] = obj[key];\n    });\n\n    return copy;\n  }\n  else if (!(obj instanceof Object)) {\n    return obj;\n  }\n  else if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n\n  for (var i in obj) {\n    if (Array.isArray(obj[i])) {\n      copy[i] = obj[i].slice(0);\n    }\n    else if (obj[i] instanceof Buffer) {\n        copy[i] = obj[i].slice(0);\n    }\n    else if (typeof obj[i] != 'function') {\n      copy[i] = obj[i] instanceof Object ? exports.clone(obj[i]) : obj[i];\n    }\n    else if (typeof obj[i] === 'function') {\n      copy[i] = obj[i];\n    }\n  }\n\n  return copy;\n};\n\n//\n// ### function log (options)\n// #### @options {Object} All information about the log serialization.\n// Generic logging function for returning timestamped strings\n// with the following options:\n//\n//    {\n//      level:     'level to add to serialized message',\n//      message:   'message to serialize',\n//      meta:      'additional logging metadata to serialize',\n//      colorize:  false, // Colorizes output (only if `.json` is false)\n//      align:     false  // Align message level.\n//      timestamp: true   // Adds a timestamp to the serialized message\n//      label:     'label to prepend the message'\n//    }\n//\nexports.log = function (options) {\n  var timestampFn = typeof options.timestamp === 'function'\n        ? options.timestamp\n        : exports.timestamp,\n      timestamp   = options.timestamp ? timestampFn() : null,\n      showLevel   = options.showLevel === undefined ? true : options.showLevel,\n      meta        = options.meta !== null && options.meta !== undefined && !(options.meta instanceof Error)\n        ? exports.clone(cycle.decycle(options.meta))\n        : options.meta || null,\n      output;\n\n  //\n  // raw mode is intended for outputing winston as streaming JSON to STDOUT\n  //\n  if (options.raw) {\n    if (typeof meta !== 'object' && meta != null) {\n      meta = { meta: meta };\n    }\n    output         = exports.clone(meta) || {};\n    output.level   = options.level;\n    //\n    // Remark (jcrugzz): This used to be output.message = options.message.stripColors.\n    // I do not know why this is, it does not make sense but im handling that\n    // case here as well as handling the case that does make sense which is to\n    // make the `output.message = options.message`\n    //\n    output.message = options.message.stripColors\n      ? options.message.stripColors\n      : options.message;\n\n    return JSON.stringify(output);\n  }\n\n  //\n  // json mode is intended for pretty printing multi-line json to the terminal\n  //\n  if (options.json || true === options.logstash) {\n    if (typeof meta !== 'object' && meta != null) {\n      meta = { meta: meta };\n    }\n\n    output         = exports.clone(meta) || {};\n    output.level   = options.level;\n    output.message = output.message || '';\n\n    if (options.label) { output.label = options.label; }\n    if (options.message) { output.message = options.message; }\n    if (timestamp) { output.timestamp = timestamp; }\n\n    if (options.logstash === true) {\n      // use logstash format\n      var logstashOutput = {};\n      if (output.message !== undefined) {\n        logstashOutput['@message'] = output.message;\n        delete output.message;\n      }\n\n      if (output.timestamp !== undefined) {\n        logstashOutput['@timestamp'] = output.timestamp;\n        delete output.timestamp;\n      }\n\n      logstashOutput['@fields'] = exports.clone(output);\n      output = logstashOutput;\n    }\n\n    if (typeof options.stringify === 'function') {\n      return options.stringify(output);\n    }\n\n    return JSON.stringify(output, function (key, value) {\n      return value instanceof Buffer\n        ? value.toString('base64')\n        : value;\n    });\n  }\n\n  //\n  // Remark: this should really be a call to `util.format`.\n  //\n  if (typeof options.formatter == 'function') {\n    options.meta = meta;\n    return String(options.formatter(exports.clone(options)));\n  }\n\n  output = timestamp ? timestamp + ' - ' : '';\n  if (showLevel) {\n    output += options.colorize === 'all' || options.colorize === 'level' || options.colorize === true\n      ? config.colorize(options.level)\n      : options.level;\n  }\n\n  output += (options.align) ? '\\t' : '';\n  output += (timestamp || showLevel) ? ': ' : '';\n  output += options.label ? ('[' + options.label + '] ') : '';\n  output += options.colorize === 'all' || options.colorize === 'message'\n    ? config.colorize(options.level, options.message)\n    : options.message;\n\n  if (meta !== null && meta !== undefined) {\n    if (meta && meta instanceof Error && meta.stack) {\n      meta = meta.stack;\n    }\n\n    if (typeof meta !== 'object') {\n      output += ' ' + meta;\n    }\n    else if (Object.keys(meta).length > 0) {\n      if (typeof options.prettyPrint === 'function') {\n        output += ' ' + options.prettyPrint(meta);\n      } else if (options.prettyPrint) {\n        output += ' ' + '\\n' + util.inspect(meta, false, options.depth || null, options.colorize);\n      } else if (\n        options.humanReadableUnhandledException\n          && Object.keys(meta).length === 5\n          && meta.hasOwnProperty('date')\n          && meta.hasOwnProperty('process')\n          && meta.hasOwnProperty('os')\n          && meta.hasOwnProperty('trace')\n          && meta.hasOwnProperty('stack')) {\n\n        //\n        // If meta carries unhandled exception data serialize the stack nicely\n        //\n        var stack = meta.stack;\n        delete meta.stack;\n        delete meta.trace;\n        output += ' ' + exports.serialize(meta);\n\n        if (stack) {\n          output += '\\n' + stack.join('\\n');\n        }\n      } else {\n        output += ' ' + exports.serialize(meta);\n      }\n    }\n  }\n\n  return output;\n};\n\nexports.capitalize = function (str) {\n  return str && str[0].toUpperCase() + str.slice(1);\n};\n\n//\n// ### function hash (str)\n// #### @str {string} String to hash.\n// Utility function for creating unique ids\n// e.g. Profiling incoming HTTP requests on the same tick\n//\nexports.hash = function (str) {\n  return crypto.createHash('sha1').update(str).digest('hex');\n};\n\n//\n// ### function pad (n)\n// Returns a padded string if `n < 10`.\n//\nexports.pad = function (n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n};\n\n//\n// ### function timestamp ()\n// Returns a timestamp string for the current time.\n//\nexports.timestamp = function () {\n  return new Date().toISOString();\n};\n\n//\n// ### function serialize (obj, key)\n// #### @obj {Object|literal} Object to serialize\n// #### @key {string} **Optional** Optional key represented by obj in a larger object\n// Performs simple comma-separated, `key=value` serialization for Loggly when\n// logging to non-JSON inputs.\n//\nexports.serialize = function (obj, key) {\n  // symbols cannot be directly casted to strings\n  if (typeof key === 'symbol') {\n    key = key.toString()\n  }\n  if (typeof obj === 'symbol') {\n    obj = obj.toString()\n  }\n\n  if (obj === null) {\n    obj = 'null';\n  }\n  else if (obj === undefined) {\n    obj = 'undefined';\n  }\n  else if (obj === false) {\n    obj = 'false';\n  }\n\n  if (typeof obj !== 'object') {\n    return key ? key + '=' + obj : obj;\n  }\n\n  if (obj instanceof Buffer) {\n    return key ? key + '=' + obj.toString('base64') : obj.toString('base64');\n  }\n\n  var msg = '',\n      keys = Object.keys(obj),\n      length = keys.length;\n\n  for (var i = 0; i < length; i++) {\n    if (Array.isArray(obj[keys[i]])) {\n      msg += keys[i] + '=[';\n\n      for (var j = 0, l = obj[keys[i]].length; j < l; j++) {\n        msg += exports.serialize(obj[keys[i]][j]);\n        if (j < l - 1) {\n          msg += ', ';\n        }\n      }\n\n      msg += ']';\n    }\n    else if (obj[keys[i]] instanceof Date) {\n      msg += keys[i] + '=' + obj[keys[i]];\n    }\n    else {\n      msg += exports.serialize(obj[keys[i]], keys[i]);\n    }\n\n    if (i < length - 1) {\n      msg += ', ';\n    }\n  }\n\n  return msg;\n};\n\n//\n// ### function tailFile (options, callback)\n// #### @options {Object} Options for tail.\n// #### @callback {function} Callback to execute on every line.\n// `tail -f` a file. Options must include file.\n//\nexports.tailFile = function(options, callback) {\n  var buffer = new Buffer(64 * 1024)\n    , decode = new StringDecoder('utf8')\n    , stream = new Stream\n    , buff = ''\n    , pos = 0\n    , row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n  stream.destroy = function() {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', function(err, fd) {\n    if (err) {\n      if (!callback) {\n        stream.emit('error', err);\n      } else {\n        callback(err);\n      }\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, function(err, bytes) {\n        if (err) {\n          if (!callback) {\n            stream.emit('error', err);\n          } else {\n            callback(err);\n          }\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            if (options.start == null || row > options.start) {\n              if (!callback) {\n                stream.emit('line', buff);\n              } else {\n                callback(null, buff);\n              }\n            }\n            row++;\n            buff = '';\n          }\n          return setTimeout(read, 1000);\n        }\n\n        var data = decode.write(buffer.slice(0, bytes));\n\n        if (!callback) {\n          stream.emit('data', data);\n        }\n\n        var data = (buff + data).split(/\\n+/)\n          , l = data.length - 1\n          , i = 0;\n\n        for (; i < l; i++) {\n          if (options.start == null || row > options.start) {\n            if (!callback) {\n              stream.emit('line', data[i]);\n            } else {\n              callback(null, data[i]);\n            }\n          }\n          row++;\n        }\n\n        buff = data[l];\n\n        pos += bytes;\n\n        return read();\n      });\n    })();\n  });\n\n  if (!callback) {\n    return stream;\n  }\n\n  return stream.destroy;\n};\n\n//\n// ### function stringArrayToSet (array)\n// #### @strArray {Array} Array of Set-elements as strings.\n// #### @errMsg {string} **Optional** Custom error message thrown on invalid input.\n// Returns a Set-like object with strArray's elements as keys (each with the value true).\n//\nexports.stringArrayToSet = function (strArray, errMsg) {\n  if (typeof errMsg === 'undefined') {\n    errMsg = 'Cannot make set from Array with non-string elements';\n  }\n  return strArray.reduce(function (set, el) {\n    if (!(typeof el === 'string' || el instanceof String)) {\n      throw new Error(errMsg);\n    }\n    set[el] = true;\n    return set;\n  }, Object.create(null));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/common.js\n// module id = 8\n// module chunks = 0","/*\n * winston.js: Top-level include defining Winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar winston = exports;\n\n//\n// use require method for webpack bundle\n//\nwinston.version = require('../package.json').version\n\n//\n// Include transports defined by default by winston\n//\nwinston.transports = require('./winston/transports');\n\n//\n// Expose utility methods\n//\nvar common             = require('./winston/common');\nwinston.hash           = common.hash;\nwinston.clone          = common.clone;\nwinston.longestElement = common.longestElement;\nwinston.exception      = require('./winston/exception');\nwinston.config         = require('./winston/config');\nwinston.addColors      = winston.config.addColors;\n\n//\n// Expose core Logging-related prototypes.\n//\nwinston.Container      = require('./winston/container').Container;\nwinston.Logger         = require('./winston/logger').Logger;\nwinston.Transport      = require('./winston/transports/transport').Transport;\n\n//\n// We create and expose a default `Container` to `winston.loggers` so that the\n// programmer may manage multiple `winston.Logger` instances without any additional overhead.\n//\n// ### some-file1.js\n//\n//     var logger = require('winston').loggers.get('something');\n//\n// ### some-file2.js\n//\n//     var logger = require('winston').loggers.get('something');\n//\nwinston.loggers = new winston.Container();\n\n//\n// We create and expose a 'defaultLogger' so that the programmer may do the\n// following without the need to create an instance of winston.Logger directly:\n//\n//     var winston = require('winston');\n//     winston.log('info', 'some message');\n//     winston.error('some error');\n//\nvar defaultLogger = new winston.Logger({\n  transports: [new winston.transports.Console()]\n});\n\n//\n// Pass through the target methods onto `winston`.\n//\nvar methods = [\n  'log',\n  'query',\n  'stream',\n  'add',\n  'remove',\n  'clear',\n  'profile',\n  'startTimer',\n  'extend',\n  'cli',\n  'handleExceptions',\n  'unhandleExceptions',\n  'configure'\n];\ncommon.setLevels(winston, null, defaultLogger.levels);\nmethods.forEach(function (method) {\n  winston[method] = function () {\n    return defaultLogger[method].apply(defaultLogger, arguments);\n  };\n});\n\n//\n// ### function cli ()\n// Configures the default winston logger to have the\n// settings for command-line interfaces: no timestamp,\n// colors enabled, padded output, and additional levels.\n//\nwinston.cli = function () {\n  winston.padLevels = true;\n  common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);\n  defaultLogger.setLevels(winston.config.cli.levels);\n  winston.config.addColors(winston.config.cli.colors);\n\n  if (defaultLogger.transports.console) {\n    defaultLogger.transports.console.colorize = true;\n    defaultLogger.transports.console.timestamp = false;\n  }\n\n  return winston;\n};\n\n//\n// ### function setLevels (target)\n// #### @target {Object} Target levels to use\n// Sets the `target` levels specified on the default winston logger.\n//\nwinston.setLevels = function (target) {\n  common.setLevels(winston, defaultLogger.levels, target);\n  defaultLogger.setLevels(target);\n};\n\n//\n// Define getter / setter for the default logger level\n// which need to be exposed by winston.\n//\nObject.defineProperty(winston, 'level', {\n  get: function () {\n    return defaultLogger.level;\n  },\n  set: function (val) {\n    defaultLogger.level = val;\n\n    Object.keys(defaultLogger.transports).forEach(function(key) {\n      defaultLogger.transports[key].level = val;\n    });\n  }\n});\n\n//\n// Define getters / setters for appropriate properties of the\n// default logger which need to be exposed by winston.\n//\n['emitErrs', 'exitOnError', 'padLevels', 'levelLength', 'stripColors'].forEach(function (prop) {\n  Object.defineProperty(winston, prop, {\n    get: function () {\n      return defaultLogger[prop];\n    },\n    set: function (val) {\n      defaultLogger[prop] = val;\n    }\n  });\n});\n\n//\n// @default {Object}\n// The default transports and exceptionHandlers for\n// the default winston logger.\n//\nObject.defineProperty(winston, 'default', {\n  get: function () {\n    return {\n      transports: defaultLogger.transports,\n      exceptionHandlers: defaultLogger.exceptionHandlers\n    };\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston.js\n// module id = 9\n// module chunks = 0","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 10\n// module chunks = 0","/*\n\nThe MIT License (MIT)\n\nOriginal Library \n  - Copyright (c) Marak Squires\n\nAdditional functionality\n - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\n\ncolors.supportsColor = require('./system/supports-colors');\n\nif (typeof colors.enabled === \"undefined\") {\n  colors.enabled = colors.supportsColor;\n}\n\ncolors.stripColors = colors.strip = function(str){\n  return (\"\" + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n\nvar stylize = colors.stylize = function stylize (str, style) {\n  return ansiStyles[style].open + str + ansiStyles[style].close;\n}\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe,  '\\\\$&');\n}\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function () {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function (key) {\n    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function () {\n        return build(this._styles.concat(key));\n      }\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = arguments;\n  var argsLen = args.length;\n  var str = argsLen !== 0 && String(arguments[0]);\n  if (argsLen > 1) {\n    for (var a = 1; a < argsLen; a++) {\n      str += ' ' + args[a];\n    }\n  }\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n  }\n\n  return str;\n}\n\nfunction applyTheme (theme) {\n  for (var style in theme) {\n    (function(style){\n      colors[style] = function(str){\n        return colors[theme[style]](str);\n      };\n    })(style)\n  }\n}\n\ncolors.setTheme = function (theme) {\n  if (typeof theme === 'string') {\n    try {\n      colors.themes[theme] = require(theme);\n      applyTheme(colors.themes[theme]);\n      return colors.themes[theme];\n    } catch (err) {\n      console.log(err);\n      return err;\n    }\n  } else {\n    applyTheme(theme);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function (name) {\n    ret[name] = {\n      get: function () {\n        return build([name]);\n      }\n    };\n  });\n  return ret;\n}\n\nvar sequencer = function sequencer (map, str) {\n  var exploded = str.split(\"\"), i = 0;\n  exploded = exploded.map(map);\n  return exploded.join(\"\");\n};\n\n// custom formatter methods\ncolors.trap = require('./custom/trap');\ncolors.zalgo = require('./custom/zalgo');\n\n// maps\ncolors.maps = {};\ncolors.maps.america = require('./maps/america');\ncolors.maps.zebra = require('./maps/zebra');\ncolors.maps.rainbow = require('./maps/rainbow');\ncolors.maps.random = require('./maps/random')\n\nfor (var map in colors.maps) {\n  (function(map){\n    colors[map] = function (str) {\n      return sequencer(colors.maps[map], str);\n    }\n  })(map)\n}\n\ndefineProps(colors, init());\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/colors.js\n// module id = 11\n// module chunks = 0","/*\n * transport.js: Base Transport object for all Winston transports.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    util = require('util');\n\n//\n// ### function Transport (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Tranport object responsible\n// base functionality for all winston transports.\n//\nvar Transport = exports.Transport = function (options) {\n  events.EventEmitter.call(this);\n\n  options        = options        || {};\n  this.silent    = options.silent || false;\n  this.raw       = options.raw    || false;\n  this.name      = options.name   || this.name;\n  this.formatter = options.formatter;\n\n  //\n  // Do not set a default level. When `level` is falsey on any\n  // `Transport` instance, any `Logger` instance uses the\n  // configured level (instead of the Transport level)\n  //\n  this.level = options.level;\n\n  this.handleExceptions = options.handleExceptions || false;\n  this.exceptionsLevel  = options.exceptionsLevel || 'error';\n  this.humanReadableUnhandledException = options.humanReadableUnhandledException || false;\n};\n\n//\n// Inherit from `events.EventEmitter`.\n//\nutil.inherits(Transport, events.EventEmitter);\n\n//\n// ### function formatQuery (query)\n// #### @query {string|Object} Query to format\n// Formats the specified `query` Object (or string) to conform\n// with the underlying implementation of this transport.\n//\nTransport.prototype.formatQuery = function (query) {\n  return query;\n};\n\n//\n// ### function normalizeQuery (query)\n// #### @options {string|Object} Query to normalize\n// Normalize options for query\n//\nTransport.prototype.normalizeQuery = function (options) {\n  //\n  // Use options similar to loggly.\n  // [See Loggly Search API](http://wiki.loggly.com/retrieve_events#optional)\n  //\n\n  options = options || {};\n\n  // limit\n  options.rows = options.rows || options.limit || 10;\n\n  // starting row offset\n  options.start = options.start || 0;\n\n  // now\n  options.until = options.until || new Date;\n  if (typeof options.until !== 'object') {\n    options.until = new Date(options.until);\n  }\n\n  // now - 24\n  options.from = options.from || (options.until - (24 * 60 * 60 * 1000));\n  if (typeof options.from !== 'object') {\n    options.from = new Date(options.from);\n  }\n\n\n  // 'asc' or 'desc'\n  options.order = options.order || 'desc';\n\n  // which fields to select\n  options.fields = options.fields;\n\n  return options;\n};\n\n//\n// ### function formatResults (results, options)\n// #### @results {Object|Array} Results returned from `.query`.\n// #### @options {Object} **Optional** Formatting options\n// Formats the specified `results` with the given `options` accordinging\n// to the implementation of this transport.\n//\nTransport.prototype.formatResults = function (results, options) {\n  return results;\n};\n\n//\n// ### function logException (msg, meta, callback)\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Logs the specified `msg`, `meta` and responds to the callback once the log\n// operation is complete to ensure that the event loop will not exit before\n// all logging has completed.\n//\nTransport.prototype.logException = function (msg, meta, callback) {\n  var self = this,\n      called;\n\n  if (this.silent) {\n    return callback();\n  }\n\n  function onComplete () {\n    if (!called) {\n      called = true;\n      self.removeListener('logged', onComplete);\n      self.removeListener('error', onComplete);\n      callback();\n    }\n  }\n\n  this.once('logged', onComplete);\n  this.once('error', onComplete);\n  this.log(self.exceptionsLevel, msg, meta, function () { });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports/transport.js\n// module id = 12\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/util.js\n// module id = 13\n// module chunks = 0","'use strict'\n\nconst rimraf = require('./rimraf')\n\nfunction removeSync (dir) {\n  return rimraf.sync(dir, {disableGlob: true})\n}\n\nfunction remove (dir, callback) {\n  const options = {disableGlob: true}\n  return callback ? rimraf(dir, options, callback) : rimraf(dir, options, function () {})\n}\n\nmodule.exports = {\n  remove,\n  removeSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/remove/index.js\n// module id = 14\n// module chunks = 0","(function() {\n  exports.Emitter = require('./emitter');\n\n  exports.Disposable = require('./disposable');\n\n  exports.CompositeDisposable = require('./composite-disposable');\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/event-kit/lib/event-kit.js\n// module id = 15\n// module chunks = 0","import * as Path from 'path'\nimport * as winston from 'winston'\n\nimport { getLogDirectoryPath } from '../lib/logging/get-log-path'\nimport { LogLevel } from '../lib/logging/log-level'\nimport { mkdirIfNeeded } from '../lib/file-system'\n\nrequire('winston-daily-rotate-file')\n\n/**\n * The maximum number of log files we should have on disk before pruning old\n * ones.\n */\nconst MaxLogFiles = 14\n\n/** resolve the log file location based on the current channel */\nfunction getLogFilePath(directory: string): string {\n  const channel = __RELEASE_CHANNEL__\n  const fileName = `desktop.${channel}.log`\n  return Path.join(directory, fileName)\n}\n\n/**\n * Initializes winston and returns a subset of the available log level\n * methods (debug, info, error). This method should only be called once\n * during an application's lifetime.\n *\n * @param path The path where to write log files. This path will have\n *             the current date prepended to the basename part of the\n *             path such that passing a path '/logs/foo' will end up\n *             writing to '/logs/2017-05-17.foo'\n */\nfunction initializeWinston(path: string): winston.LogMethod {\n  const fileLogger = new winston.transports.DailyRotateFile({\n    filename: path,\n    // We'll do this ourselves, thank you\n    handleExceptions: false,\n    json: false,\n    datePattern: 'yyyy-MM-dd.',\n    prepend: true,\n    // log everything interesting (info and up)\n    level: 'info',\n    maxFiles: MaxLogFiles,\n  })\n\n  const consoleLogger = new winston.transports.Console({\n    level: process.env.NODE_ENV === 'development' ? 'debug' : 'error',\n  })\n\n  winston.configure({\n    transports: [consoleLogger, fileLogger],\n  })\n\n  return winston.log\n}\n\nlet loggerPromise: Promise<winston.LogMethod> | null = null\n\n/**\n * Initializes and configures winston (if necessary) to write to Electron's\n * console as well as to disk.\n *\n * @returns a function reference which can be used to write log entries,\n *          this function is equivalent to that of winston.log in that\n *          it accepts a log level, a message and an optional callback\n *          for when the event has been written to all destinations.\n */\nfunction getLogger(): Promise<winston.LogMethod> {\n  if (loggerPromise) {\n    return loggerPromise\n  }\n\n  loggerPromise = new Promise<winston.LogMethod>((resolve, reject) => {\n    const logDirectory = getLogDirectoryPath()\n\n    mkdirIfNeeded(logDirectory)\n      .then(() => {\n        try {\n          const logger = initializeWinston(getLogFilePath(logDirectory))\n          resolve(logger)\n        } catch (err) {\n          reject(err)\n        }\n      })\n      .catch(error => {\n        reject(error)\n      })\n  })\n\n  return loggerPromise\n}\n\n/**\n * Write the given log entry to all configured transports,\n * see initializeWinston in logger.ts for more details about\n * what transports we set up.\n *\n * Returns a promise that will never yield an error and which\n * resolves when the log entry has been written to all transports\n * or if the entry could not be written due to an error.\n */\nexport async function log(level: LogLevel, message: string) {\n  try {\n    const logger = await getLogger()\n    await new Promise<void>((resolve, reject) => {\n      logger(level, message, error => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  } catch (error) {\n    /**\n     * Welp. I guess we have to ignore this for now, we\n     * don't have any good mechanisms for reporting this.\n     * In the future we can discuss whether we should\n     * IPC to the renderer or dump it somewhere else\n     * but for now logging isn't a critical thing.\n     */\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/log.ts","/*\n * config.js: Default settings for all levels that winston knows about\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar colors = require('colors/safe');\n\n// Fix colors not appearing in non-tty environments\ncolors.enabled = true;\n\nvar config = exports,\n    allColors = exports.allColors = {};\n\nconfig.addColors = function (colors) {\n  mixin(allColors, colors);\n};\n\nconfig.colorize = function (level, message) {\n  if (typeof message === 'undefined') message = level;\n\n  var colorized = message;\n  if (allColors[level] instanceof Array) {\n    for (var i = 0, l = allColors[level].length; i < l; ++i) {\n      colorized = colors[allColors[level][i]](colorized);\n    }\n  }\n  else if (allColors[level].match(/\\s/)) {\n    var colorArr = allColors[level].split(/\\s+/);\n    for (var i = 0; i < colorArr.length; ++i) {\n      colorized = colors[colorArr[i]](colorized);\n    }\n    allColors[level] = colorArr;\n  }\n  else {\n    colorized = colors[allColors[level]](colorized);\n  }\n\n  return colorized;\n};\n\n//\n// Export config sets\n//\nconfig.cli    = require('./config/cli-config');\nconfig.npm    = require('./config/npm-config');\nconfig.syslog = require('./config/syslog-config');\n\n//\n// Add colors for pre-defined config sets\n//\nconfig.addColors(config.cli.colors);\nconfig.addColors(config.npm.colors);\nconfig.addColors(config.syslog.colors);\n\nfunction mixin (target) {\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  args.forEach(function (a) {\n    var keys = Object.keys(a);\n    for (var i = 0; i < keys.length; i++) {\n      target[keys[i]] = a[keys[i]];\n    }\n  });\n  return target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/config.js\n// module id = 17\n// module chunks = 0","import * as Fs from 'fs-extra'\nimport * as Os from 'os'\nimport * as Path from 'path'\nimport { Disposable } from 'event-kit'\nimport { Tailer } from './tailer'\n\nconst byline = require('byline')\n\n/** Create directory using basic Fs.mkdir but ignores\n * the error thrown when directory already exists.\n * All other errors must be handled by caller.\n *\n * @param directoryPath the path of the directory the caller wants to create.\n */\nexport function mkdirIfNeeded(directoryPath: string): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    Fs.mkdir(directoryPath, err => {\n      if (err && err.code !== 'EEXIST') {\n        reject(err)\n        return\n      }\n      resolve()\n    })\n  })\n}\n\n/*\n * Write a file using the standard fs.writeFile API, but wrapped in a promise.\n *\n * @param path the path to the file on disk\n * @param data the contents of the file to write\n * @param options the default Fs.writeFile options\n */\nexport function writeFile(\n  path: string,\n  data: any,\n  options: { encoding?: string; mode?: number; flag?: string } = {}\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    Fs.writeFile(path, data, options, err => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\n/**\n * Get a path to a temp file using the given name. Note that the file itself\n * will not be created.\n */\nexport function getTempFilePath(name: string): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    const tempDir = Path.join(Os.tmpdir(), `${name}-`)\n    Fs.mkdtemp(tempDir, (err, directory) => {\n      if (err) {\n        reject(err)\n      } else {\n        const fullPath = Path.join(directory, name)\n        resolve(fullPath)\n      }\n    })\n  })\n}\n\n/**\n * Tail the file and call the callback on every line.\n *\n * Note that this will not stop tailing until the returned `Disposable` is\n * disposed of.\n */\nexport function tailByLine(\n  path: string,\n  cb: (line: string) => void\n): Disposable {\n  const tailer = new Tailer(path)\n  const disposable = tailer.onDataAvailable(stream => {\n    byline(stream).on('data', (buffer: Buffer) => {\n      if (disposable.disposed) {\n        return\n      }\n\n      const line = buffer.toString()\n      cb(line)\n    })\n  })\n\n  tailer.start()\n\n  return new Disposable(() => {\n    disposable.dispose()\n    tailer.stop()\n  })\n}\n\n/*\n * Helper function to promisify and simplify fs.stat.\n *\n * @param path Path to check for existence.\n */\nexport function pathExists(path: string): Promise<boolean> {\n  return new Promise<boolean>((resolve, reject) => {\n    Fs.stat(path, (error, stats) => {\n      if (error) {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/file-system.ts","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/mkdirs/mkdirs.js\n// module id = 19\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    switch (err0.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) throw err0\n        made = mkdirsSync(path.dirname(p), opts, made)\n        mkdirsSync(p, opts, made)\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        let stat\n        try {\n          stat = xfs.statSync(p)\n        } catch (err1) {\n          throw err0\n        }\n        if (!stat.isDirectory()) throw err0\n        break\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\n// module id = 20\n// module chunks = 0","'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJSON: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  readJSONSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJSON: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync,\n  writeJSONSync: jsonFile.writeFileSync,\n  spaces: 2 // default in fs-extra\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/json/jsonfile.js\n// module id = 21\n// module chunks = 0","(function() {\n  var Disposable;\n\n  module.exports = Disposable = (function() {\n    Disposable.prototype.disposed = false;\n\n    Disposable.isDisposable = function(object) {\n      return typeof (object != null ? object.dispose : void 0) === \"function\";\n    };\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function Disposable(disposalAction) {\n      this.disposalAction = disposalAction;\n    }\n\n    Disposable.prototype.dispose = function() {\n      if (!this.disposed) {\n        this.disposed = true;\n        if (typeof this.disposalAction === \"function\") {\n          this.disposalAction();\n        }\n        this.disposalAction = null;\n      }\n    };\n\n    return Disposable;\n\n  })();\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/event-kit/lib/disposable.js\n// module id = 22\n// module chunks = 0","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    var noop = function () {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    if (typeof window == 'object' && this === window) {\n        root = window;\n    }\n    else if (typeof global == 'object' && this === global) {\n        root = global;\n    }\n    else {\n        root = this;\n    }\n\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n      var index = -1,\n          length = arr.length;\n\n      while (++index < length) {\n        iterator(arr[index], index, arr);\n      }\n    };\n\n    var _map = function (arr, iterator) {\n      var index = -1,\n          length = arr.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iterator(arr[index], index, arr);\n      }\n      return result;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _forEachOf = function (object, iterator) {\n        _each(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    };\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    var _baseSlice = function (arr, start) {\n        start = start || 0;\n        var index = -1;\n        var length = arr.length;\n\n        if (start) {\n          length -= start;\n          length = length < 0 ? 0 : length;\n        }\n        var result = Array(length);\n\n        while (++index < length) {\n          result[index] = arr[index + start];\n        }\n        return result;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate;\n    if (typeof setImmediate === 'function') {\n        _setImmediate = setImmediate;\n    }\n\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (_setImmediate) {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                _setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (_setImmediate) {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              _setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || noop;\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = noop;\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || noop;\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = noop;\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || noop;\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = noop;\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n\n    async.forEachOf = async.eachOf = function (object, iterator, callback) {\n        callback = callback || function () {};\n        var size = object.length || _keys(object).length;\n        var completed = 0;\n        if (!size) {\n            return callback();\n        }\n        _forEachOf(object, function (value, key) {\n            iterator(object[key], key, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                } else {\n                    completed += 1;\n                    if (completed === size) {\n                        callback(null);\n                    }\n                }\n            });\n        });\n    };\n\n    async.forEachOfSeries = async.eachOfSeries = function (obj, iterator, callback) {\n        callback = callback || function () {};\n        var keys = _keys(obj);\n        var size = keys.length;\n        if (!size) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            var sync = true;\n            var key = keys[completed];\n            iterator(obj[key], key, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= size) {\n                        callback(null);\n                    }\n                    else {\n                        if (sync) {\n                            async.nextTick(iterate);\n                        }\n                        else {\n                            iterate();\n                        }\n                    }\n                }\n            });\n            sync = false;\n        };\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit = async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _forEachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    var _forEachOfLimit = function (limit) {\n\n        return function (obj, iterator, callback) {\n            callback = callback || function () {};\n            var keys = _keys(obj);\n            var size = keys.length;\n            if (!size || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= size) {\n                    return callback();\n                }\n\n                while (running < limit && started < size) {\n                    started += 1;\n                    running += 1;\n                    var key = keys[started - 1];\n                    iterator(obj[key], key, function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= size) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = noop;\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = noop;\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = noop;\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || noop;\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--;\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = noop;\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = _baseSlice(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = noop;\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has inexistant dependency');\n                }\n                if (_isArray(dep) && !!~dep.indexOf(k)) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        };\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || noop;\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = noop;\n                }\n                else {\n                    var args = _baseSlice(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || noop;\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = _baseSlice(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = _baseSlice(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || noop;\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = _baseSlice(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = _baseSlice(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = _baseSlice(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(_baseSlice(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = _baseSlice(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = _baseSlice(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length === 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length === 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number' ?\n                    tasks.splice(0, payload) :\n                    tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = _baseSlice(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = _baseSlice(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = _baseSlice(arguments);\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = _baseSlice(arguments, 1);\n                    cb(err, nextargs);\n                }]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = _baseSlice(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/async/lib/async.js\n// module id = 23\n// module chunks = 0","module.exports = require(\"zlib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"zlib\"\n// module id = 24\n// module chunks = 0","/*\n * exception.js: Utility methods for gathing information about uncaughtExceptions.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar os = require('os'),\n    stackTrace = require('stack-trace');\n\nvar exception = exports;\n\nexception.getAllInfo = function (err) {\n  return {\n    date:    new Date().toString(),\n    process: exception.getProcessInfo(),\n    os:      exception.getOsInfo(),\n    trace:   exception.getTrace(err),\n    stack:   err.stack && err.stack.split('\\n')\n  };\n};\n\nexception.getProcessInfo = function () {\n  return {\n    pid:         process.pid,\n    uid:         process.getuid ? process.getuid() : null,\n    gid:         process.getgid ? process.getgid() : null,\n    cwd:         process.cwd(),\n    execPath:    process.execPath,\n    version:     process.version,\n    argv:        process.argv,\n    memoryUsage: process.memoryUsage()\n  };\n};\n\nexception.getOsInfo = function () {\n  return {\n    loadavg: os.loadavg(),\n    uptime:  os.uptime()\n  };\n};\n\nexception.getTrace = function (err) {\n  var trace = err ? stackTrace.parse(err) : stackTrace.get();\n  return trace.map(function (site) {\n    return {\n      column:   site.getColumnNumber(),\n      file:     site.getFileName(),\n      function: site.getFunctionName(),\n      line:     site.getLineNumber(),\n      method:   site.getMethodName(),\n      native:   site.isNative(),\n    }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/exception.js\n// module id = 25\n// module chunks = 0","import * as Path from 'path'\nimport { app } from 'electron'\n\nlet logDirectoryPath: string | null = null\n\nexport function getLogDirectoryPath() {\n  if (!logDirectoryPath) {\n    const userData = app.getPath('userData')\n    logDirectoryPath = Path.join(userData, 'logs')\n  }\n\n  return logDirectoryPath\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/get-log-path.ts","'use strict'\n\nconst assign = require('./util/assign')\n\nconst fse = {}\nconst gfs = require('graceful-fs')\n\n// attach fs methods to fse\nObject.keys(gfs).forEach(key => {\n  fse[key] = gfs[key]\n})\n\nconst fs = fse\n\nassign(fs, require('./copy'))\nassign(fs, require('./copy-sync'))\nassign(fs, require('./mkdirs'))\nassign(fs, require('./remove'))\nassign(fs, require('./json'))\nassign(fs, require('./move'))\nassign(fs, require('./move-sync'))\nassign(fs, require('./empty'))\nassign(fs, require('./ensure'))\nassign(fs, require('./output'))\n\nmodule.exports = fs\n\n// maintain backwards compatibility for awhile\nconst jsonfile = {}\nObject.defineProperty(jsonfile, 'spaces', {\n  get: () => fs.spaces, // found in ./json\n  set: val => {\n    fs.spaces = val\n  }\n})\n\nmodule.exports.jsonfile = jsonfile // so users of fs-extra can modify jsonFile.spaces\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/index.js\n// module id = 27\n// module chunks = 0","'use strict'\n\nvar fs = require('fs')\n\nmodule.exports = clone(fs)\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/graceful-fs/fs.js\n// module id = 28\n// module chunks = 0","module.exports = require(\"assert\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"assert\"\n// module id = 29\n// module chunks = 0","// imported from ncp (this is temporary, will rewrite)\n\nvar fs = require('graceful-fs')\nvar path = require('path')\nvar utimes = require('../util/utimes')\n\nfunction ncp (source, dest, options, callback) {\n  if (!callback) {\n    callback = options\n    options = {}\n  }\n\n  var basePath = process.cwd()\n  var currentPath = path.resolve(basePath, source)\n  var targetPath = path.resolve(basePath, dest)\n\n  var filter = options.filter\n  var transform = options.transform\n  var overwrite = options.overwrite\n  // If overwrite is undefined, use clobber, otherwise default to true:\n  if (overwrite === undefined) overwrite = options.clobber\n  if (overwrite === undefined) overwrite = true\n  var errorOnExist = options.errorOnExist\n  var dereference = options.dereference\n  var preserveTimestamps = options.preserveTimestamps === true\n\n  var started = 0\n  var finished = 0\n  var running = 0\n\n  var errored = false\n\n  startCopy(currentPath)\n\n  function startCopy (source) {\n    started++\n    if (filter) {\n      if (filter instanceof RegExp) {\n        console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function')\n        if (!filter.test(source)) {\n          return doneOne(true)\n        }\n      } else if (typeof filter === 'function') {\n        if (!filter(source, dest)) {\n          return doneOne(true)\n        }\n      }\n    }\n    return getStats(source)\n  }\n\n  function getStats (source) {\n    var stat = dereference ? fs.stat : fs.lstat\n    running++\n    stat(source, function (err, stats) {\n      if (err) return onError(err)\n\n      // We need to get the mode from the stats object and preserve it.\n      var item = {\n        name: source,\n        mode: stats.mode,\n        mtime: stats.mtime, // modified time\n        atime: stats.atime, // access time\n        stats: stats // temporary\n      }\n\n      if (stats.isDirectory()) {\n        return onDir(item)\n      } else if (stats.isFile() || stats.isCharacterDevice() || stats.isBlockDevice()) {\n        return onFile(item)\n      } else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source)\n      }\n    })\n  }\n\n  function onFile (file) {\n    var target = file.name.replace(currentPath, targetPath.replace('$', '$$$$')) // escapes '$' with '$$'\n    isWritable(target, function (writable) {\n      if (writable) {\n        copyFile(file, target)\n      } else {\n        if (overwrite) {\n          rmFile(target, function () {\n            copyFile(file, target)\n          })\n        } else if (errorOnExist) {\n          onError(new Error(target + ' already exists'))\n        } else {\n          doneOne()\n        }\n      }\n    })\n  }\n\n  function copyFile (file, target) {\n    var readStream = fs.createReadStream(file.name)\n    var writeStream = fs.createWriteStream(target, { mode: file.mode })\n\n    readStream.on('error', onError)\n    writeStream.on('error', onError)\n\n    if (transform) {\n      transform(readStream, writeStream, file)\n    } else {\n      writeStream.on('open', function () {\n        readStream.pipe(writeStream)\n      })\n    }\n\n    writeStream.once('close', function () {\n      fs.chmod(target, file.mode, function (err) {\n        if (err) return onError(err)\n        if (preserveTimestamps) {\n          utimes.utimesMillis(target, file.atime, file.mtime, function (err) {\n            if (err) return onError(err)\n            return doneOne()\n          })\n        } else {\n          doneOne()\n        }\n      })\n    })\n  }\n\n  function rmFile (file, done) {\n    fs.unlink(file, function (err) {\n      if (err) return onError(err)\n      return done()\n    })\n  }\n\n  function onDir (dir) {\n    var target = dir.name.replace(currentPath, targetPath.replace('$', '$$$$')) // escapes '$' with '$$'\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target)\n      }\n      copyDir(dir.name)\n    })\n  }\n\n  function mkDir (dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) return onError(err)\n      // despite setting mode in fs.mkdir, doesn't seem to work\n      // so we set it here.\n      fs.chmod(target, dir.mode, function (err) {\n        if (err) return onError(err)\n        copyDir(dir.name)\n      })\n    })\n  }\n\n  function copyDir (dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) return onError(err)\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item))\n      })\n      return doneOne()\n    })\n  }\n\n  function onLink (link) {\n    var target = link.replace(currentPath, targetPath)\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) return onError(err)\n      checkLink(resolvedPath, target)\n    })\n  }\n\n  function checkLink (resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath)\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target)\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) return onError(err)\n\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest)\n        }\n        if (targetDest === resolvedPath) {\n          return doneOne()\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target)\n        })\n      })\n    })\n  }\n\n  function makeLink (linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) return onError(err)\n      return doneOne()\n    })\n  }\n\n  function isWritable (path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true)\n        return done(false)\n      }\n      return done(false)\n    })\n  }\n\n  function onError (err) {\n    // ensure callback is defined & called only once:\n    if (!errored && callback !== undefined) {\n      errored = true\n      return callback(err)\n    }\n  }\n\n  function doneOne (skipped) {\n    if (!skipped) running--\n    finished++\n    if ((started === finished) && (running === 0)) {\n      if (callback !== undefined) {\n        return callback(null)\n      }\n    }\n  }\n}\n\nmodule.exports = ncp\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy/ncp.js\n// module id = 30\n// module chunks = 0","'use strict'\n\nconst path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/mkdirs/win32.js\n// module id = 31\n// module chunks = 0","module.exports = {\n  copySync: require('./copy-sync')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy-sync/index.js\n// module id = 32\n// module chunks = 0","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n  if ('passParsingErrors' in options) {\n    shouldThrow = options.passParsingErrors\n  } else if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  var content = fs.readFileSync(file, options)\n  content = stripBom(content)\n\n  try {\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = ''\n  try {\n    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\\n'\n  } catch (err) {\n    if (callback) return callback(err, null)\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var spaces = typeof options === 'object' && options !== null\n    ? 'spaces' in options\n    ? options.spaces : this.spaces\n    : this.spaces\n\n  var str = JSON.stringify(obj, options.replacer, spaces) + '\\n'\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  spaces: null,\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/jsonfile/index.js\n// module id = 33\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/json/output-json-sync.js\n// module id = 34\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  fs.exists(dir, itDoes => {\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/json/output-json.js\n// module id = 35\n// module chunks = 0","import { withSourceMappedStack } from '../source-map-support'\n\n/**\n * Formats an error for log file output. Use this instead of\n * multiple calls to log.error.\n */\nexport function formatError(error: Error, title?: string) {\n  error = withSourceMappedStack(error)\n\n  if (error.stack) {\n    return title ? `${title}\\n${error.stack}` : error.stack.trim()\n  } else {\n    return title\n      ? `${title}\\n${error.name}: ${error.message}`\n      : `${error.name}: ${error.message}`\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/format-error.ts","import * as Path from 'path'\nimport * as Fs from 'fs'\n\nconst fileUriToPath: (uri: string) => string = require('file-uri-to-path')\nconst sourceMapSupport = require('source-map-support')\n\n/**\n * This array tells the source map logic which files that we can expect to\n * be able to resolve a source map for and they should reflect the chunks\n * entry names from our webpack config.\n *\n * Note that we explicitly don't enable source maps for the crash process\n * since it's possible that the error which caused us to spawn the crash\n * process was related to source maps.\n */\nconst knownFilesWithSourceMap = ['renderer.js', 'main.js']\n\nfunction retrieveSourceMap(source: string) {\n  // This is a happy path in case we know for certain that we won't be\n  // able to resolve a source map for the given location.\n  if (!knownFilesWithSourceMap.some(file => source.endsWith(file))) {\n    return null\n  }\n\n  // We get a file uri when we're inside a renderer, convert to a path\n  if (source.startsWith('file://')) {\n    source = fileUriToPath(source)\n  }\n\n  // We store our source maps right next to the bundle\n  const path = `${source}.map`\n\n  if (__DEV__ && path.startsWith('http://')) {\n    try {\n      const xhr = new XMLHttpRequest()\n      xhr.open('GET', path, false)\n      xhr.send(null)\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        return { url: Path.basename(path), map: xhr.responseText }\n      }\n    } catch (error) {\n      return\n    }\n    return\n  }\n\n  // We don't have an option here, see\n  //  https://github.com/v8/v8/wiki/Stack-Trace-API#customizing-stack-traces\n  // This happens on-demand when someone accesses the stack\n  // property on an error object and has to be synchronous :/\n  // tslint:disable-next-line:no-sync-functions\n  if (!Fs.existsSync(path)) {\n    return\n  }\n\n  try {\n    // tslint:disable-next-line:no-sync-functions\n    const map = Fs.readFileSync(path, 'utf8')\n    return { url: Path.basename(path), map }\n  } catch (error) {\n    return\n  }\n}\n\n/** A map from errors to their stack frames. */\nconst stackFrameMap = new WeakMap<Error, ReadonlyArray<any>>()\n\n/**\n * The `prepareStackTrace` that comes from the `source-map-support` module.\n * We'll use this when the user explicitly wants the stack source mapped.\n */\nlet prepareStackTraceWithSourceMap: (\n  error: Error,\n  frames: ReadonlyArray<any>\n) => string\n\n/**\n * Capture the error's stack frames and return a standard, un-source mapped\n * stack trace.\n */\nfunction prepareStackTrace(error: Error, frames: ReadonlyArray<any>) {\n  stackFrameMap.set(error, frames)\n\n  // Ideally we'd use the default `Error.prepareStackTrace` here but it's\n  // undefined so V8 must doing something fancy. Instead we'll do a decent\n  // impression.\n  return error + frames.map(frame => `\\n    at ${frame}`).join('')\n}\n\n/** Enable source map support in the current process. */\nexport function enableSourceMaps() {\n  sourceMapSupport.install({\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap,\n  })\n\n  const AnyError = Error as any\n  // We want to keep `source-map-support`s `prepareStackTrace` around to use\n  // later, but our cheaper `prepareStackTrace` should be the default.\n  prepareStackTraceWithSourceMap = AnyError.prepareStackTrace\n  AnyError.prepareStackTrace = prepareStackTrace\n}\n\n/**\n * Make a copy of the error with a source-mapped stack trace. If it couldn't\n * perform the source mapping, it'll use the original error stack.\n */\nexport function withSourceMappedStack(error: Error): Error {\n  return {\n    name: error.name,\n    message: error.message,\n    stack: sourceMappedStackTrace(error),\n  }\n}\n\n/** Get the source mapped stack trace for the error. */\nfunction sourceMappedStackTrace(error: Error): string | undefined {\n  let frames = stackFrameMap.get(error)\n\n  if (!frames) {\n    // At this point there's no guarantee that anyone has actually retrieved the\n    // stack on this error which means that our custom prepareStackTrace handler\n    // hasn't run and as a result of that we don't have the native frames stored\n    // in our weak map. In order to get around that we'll eagerly access the\n    // stack, forcing our handler to run which should ensure that the native\n    // frames are stored in our weak map.\n    // tslint:disable-next-line:whitespace\n    ;(error.stack || '').toString()\n    frames = stackFrameMap.get(error)\n  }\n\n  if (!frames) {\n    return error.stack\n  }\n\n  return prepareStackTraceWithSourceMap(error, frames)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/source-map-support.ts","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/source-map-generator.js\n// module id = 38\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/base64-vlq.js\n// module id = 39\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/array-set.js\n// module id = 40\n// module chunks = 0","// The name of the ipc channel over which state changes are communicated.\nexport const windowStateChannelName = 'window-state-changed'\n\nexport type WindowState =\n  | 'minimized'\n  | 'normal'\n  | 'maximized'\n  | 'full-screen'\n  | 'hidden'\n\nexport function getWindowState(window: Electron.BrowserWindow): WindowState {\n  if (window.isFullScreen()) {\n    return 'full-screen'\n  } else if (window.isMaximized()) {\n    return 'maximized'\n  } else if (window.isMinimized()) {\n    return 'minimized'\n  } else if (!window.isVisible()) {\n    return 'hidden'\n  } else {\n    return 'normal'\n  }\n}\n\n/**\n * Registers event handlers for all window state transition events and\n * forwards those to the renderer process for a given window.\n */\nexport function registerWindowStateChangedEvents(\n  window: Electron.BrowserWindow\n) {\n  window.on('enter-full-screen', () =>\n    sendWindowStateEvent(window, 'full-screen')\n  )\n\n  // So this is a bit of a hack. If we call window.isFullScreen directly after\n  // receiving the leave-full-screen event it'll return true which isn't what\n  // we're after. So we'll say that we're transitioning to 'normal' even though\n  // we might be maximized. This works because electron will emit a 'maximized'\n  // event after 'leave-full-screen' if the state prior to full-screen was maximized.\n  window.on('leave-full-screen', () => sendWindowStateEvent(window, 'normal'))\n\n  window.on('maximize', () => sendWindowStateEvent(window, 'maximized'))\n  window.on('minimize', () => sendWindowStateEvent(window, 'minimized'))\n  window.on('unmaximize', () => sendWindowStateEvent(window, 'normal'))\n  window.on('restore', () => sendWindowStateEvent(window, 'normal'))\n  window.on('hide', () => sendWindowStateEvent(window, 'hidden'))\n  window.on('show', () => sendWindowStateEvent(window, 'normal'))\n}\n\n/**\n * Short hand convenience function for sending a window state change event\n * over the window-state-changed channel to the render process.\n */\nfunction sendWindowStateEvent(\n  window: Electron.BrowserWindow,\n  state: WindowState\n) {\n  window.webContents.send(windowStateChannelName, state)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/window-state.ts","/** Throw an error. */\nexport function fatalError(msg: string): never {\n  throw new Error(msg)\n}\n\n/**\n * Utility function used to achieve exhaustive type checks at compile time.\n *\n * If the type system is bypassed or this method will throw an exception\n * using the second parameter as the message.\n *\n * @param {x}       Placeholder parameter in order to leverage the type\n *                  system. Pass the variable which has been type narrowed\n *                  in an exhaustive check.\n *\n * @param {message} The message to be used in the runtime exception.\n *\n */\nexport function assertNever(x: never, message: string): never {\n  throw new Error(message)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/fatal-error.ts","/**\n * Get the time from some arbitrary fixed starting point. The time will not be\n * based on clock time.\n *\n * Ideally we'd just use `performance.now` but that's a browser API and not\n * available in our Plain Old Node main process environment.\n */\nexport function now(): number {\n  const time = process.hrtime()\n  return time[0] * 1000 + time[1] / 1000000\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/now.ts","export * from './build-default-menu'\nexport * from './ensure-item-ids'\nexport * from './find-menu-item'\nexport * from './menu-event'\nexport * from './menu-ids'\nexport * from './crash-menu'\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/menu/index.ts","function getItemId(template: Electron.MenuItemConstructorOptions) {\n  return template.id || template.label || template.role || 'unknown'\n}\n\n/**\n * Ensures that all menu items in the given template are assigned an id\n * by recursively traversing the template and mutating items in place.\n *\n * Items which already have an id are left alone, the other get a unique,\n * but consistent id based on their label or role and their position in\n * the menu hierarchy.\n *\n * Note that this does not do anything to prevent the case where items have\n * explicitly been given duplicate ids.\n */\nexport function ensureItemIds(\n  template: ReadonlyArray<Electron.MenuItemConstructorOptions>,\n  prefix = '@',\n  seenIds = new Set<string>()\n) {\n  for (const item of template) {\n    let counter = 0\n    let id = item.id\n\n    // Automatically generate an id if one hasn't been explicitly provided\n    if (!id) {\n      // Ensure that multiple items with the same key gets suffixed with a number\n      // i.e. @.separator, @.separator1 @.separator2 etc\n      do {\n        id = `${prefix}.${getItemId(item)}${counter++ || ''}`\n      } while (seenIds.has(id))\n    }\n\n    item.id = id\n    seenIds.add(id)\n\n    if (item.submenu) {\n      const subMenuTemplate = item.submenu as ReadonlyArray<\n        Electron.MenuItemConstructorOptions\n      >\n      ensureItemIds(subMenuTemplate, item.id, seenIds)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/menu/ensure-item-ids.ts","import * as Url from 'url'\nimport { shell } from 'electron'\n\n/**\n * Wraps the inbuilt shell.openItem path to address a focus issue that affects macOS.\n *\n * When opening a folder in Finder, the window will appear behind the application\n * window, which may confuse users. As a workaround, we will fallback to using\n * shell.openExternal for macOS until it can be fixed upstream.\n *\n * @param path directory to open\n */\nexport function openDirectorySafe(path: string) {\n  if (__DARWIN__) {\n    const directoryURL = Url.format({\n      pathname: path,\n      protocol: 'file:',\n      slashes: true,\n    })\n\n    shell.openExternal(directoryURL)\n  } else {\n    shell.openItem(path)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/shell.ts","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 47\n// module chunks = 0","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 48\n// module chunks = 0","import '../lib/logging/main/install'\n\nimport { app, Menu, MenuItem, ipcMain, BrowserWindow, shell } from 'electron'\nimport * as Fs from 'fs'\n\nimport { AppWindow } from './app-window'\nimport { buildDefaultMenu, MenuEvent, findMenuItemByID } from './menu'\nimport { shellNeedsPatching, updateEnvironmentForProcess } from '../lib/shell'\nimport { parseAppURL } from '../lib/parse-app-url'\nimport { handleSquirrelEvent } from './squirrel-updater'\nimport { fatalError } from '../lib/fatal-error'\n\nimport { IMenuItemState } from '../lib/menu-update'\nimport { LogLevel } from '../lib/logging/log-level'\nimport { log as writeLog } from './log'\nimport { openDirectorySafe } from './shell'\nimport { reportError } from './exception-reporting'\nimport {\n  enableSourceMaps,\n  withSourceMappedStack,\n} from '../lib/source-map-support'\nimport { now } from './now'\nimport { showUncaughtException } from './show-uncaught-exception'\n\nenableSourceMaps()\n\nlet mainWindow: AppWindow | null = null\n\nconst launchTime = now()\n\nlet preventQuit = false\nlet readyTime: number | null = null\n\ntype OnDidLoadFn = (window: AppWindow) => void\n/** See the `onDidLoad` function. */\nlet onDidLoadFns: Array<OnDidLoadFn> | null = []\n\nfunction handleUncaughtException(error: Error) {\n  preventQuit = true\n\n  if (mainWindow) {\n    mainWindow.destroy()\n    mainWindow = null\n  }\n\n  const isLaunchError = !mainWindow\n  showUncaughtException(isLaunchError, error)\n}\n\nprocess.on('uncaughtException', (error: Error) => {\n  error = withSourceMappedStack(error)\n\n  reportError(error)\n  handleUncaughtException(error)\n})\n\nlet handlingSquirrelEvent = false\nif (__WIN32__ && process.argv.length > 1) {\n  const arg = process.argv[1]\n\n  const promise = handleSquirrelEvent(arg)\n  if (promise) {\n    handlingSquirrelEvent = true\n    promise\n      .catch(e => {\n        log.error(`Failed handling Squirrel event: ${arg}`, e)\n      })\n      .then(() => {\n        app.quit()\n      })\n  } else {\n    handleAppURL(arg)\n  }\n}\n\nfunction handleAppURL(url: string) {\n  const action = parseAppURL(url)\n  onDidLoad(window => {\n    // This manual focus call _shouldn't_ be necessary, but is for Chrome on\n    // macOS. See https://github.com/desktop/desktop/issues/973.\n    window.focus()\n    window.sendURLAction(action)\n  })\n}\n\nlet isDuplicateInstance = false\n// If we're handling a Squirrel event we don't want to enforce single instance.\n// We want to let the updated instance launch and do its work. It will then quit\n// once it's done.\nif (!handlingSquirrelEvent) {\n  isDuplicateInstance = app.makeSingleInstance((args, workingDirectory) => {\n    // Someone tried to run a second instance, we should focus our window.\n    if (mainWindow) {\n      if (mainWindow.isMinimized()) {\n        mainWindow.restore()\n      }\n\n      if (!mainWindow.isVisible()) {\n        mainWindow.show()\n      }\n\n      mainWindow.focus()\n    }\n\n    if (args.length > 1) {\n      handleAppURL(args[1])\n    }\n  })\n\n  if (isDuplicateInstance) {\n    app.quit()\n  }\n}\n\nif (shellNeedsPatching(process)) {\n  updateEnvironmentForProcess()\n}\n\napp.on('will-finish-launching', () => {\n  app.on('open-url', (event, url) => {\n    event.preventDefault()\n\n    handleAppURL(url)\n  })\n})\n\napp.on('ready', () => {\n  if (isDuplicateInstance || handlingSquirrelEvent) {\n    return\n  }\n\n  readyTime = now() - launchTime\n\n  app.setAsDefaultProtocolClient('x-github-client')\n\n  if (__DEV__) {\n    app.setAsDefaultProtocolClient('x-github-desktop-dev-auth')\n  } else {\n    app.setAsDefaultProtocolClient('x-github-desktop-auth')\n  }\n\n  // Also support Desktop Classic's protocols.\n  if (__DARWIN__) {\n    app.setAsDefaultProtocolClient('github-mac')\n  } else if (__WIN32__) {\n    app.setAsDefaultProtocolClient('github-windows')\n  }\n\n  createWindow()\n\n  let menu = buildDefaultMenu()\n  Menu.setApplicationMenu(menu)\n\n  ipcMain.on(\n    'update-preferred-app-menu-item-labels',\n    (\n      event: Electron.IpcMessageEvent,\n      labels: { editor?: string; shell: string }\n    ) => {\n      menu = buildDefaultMenu(labels.editor, labels.shell)\n      Menu.setApplicationMenu(menu)\n      if (mainWindow) {\n        mainWindow.sendAppMenu()\n      }\n    }\n  )\n\n  ipcMain.on('menu-event', (event: Electron.IpcMessageEvent, args: any[]) => {\n    const { name }: { name: MenuEvent } = event as any\n    if (mainWindow) {\n      mainWindow.sendMenuEvent(name)\n    }\n  })\n\n  /**\n   * An event sent by the renderer asking that the menu item with the given id\n   * is executed (ie clicked).\n   */\n  ipcMain.on(\n    'execute-menu-item',\n    (event: Electron.IpcMessageEvent, { id }: { id: string }) => {\n      const menuItem = findMenuItemByID(menu, id)\n      if (menuItem) {\n        const window = BrowserWindow.fromWebContents(event.sender)\n        const fakeEvent = { preventDefault: () => {}, sender: event.sender }\n        menuItem.click(fakeEvent, window, event.sender)\n      }\n    }\n  )\n\n  ipcMain.on(\n    'update-menu-state',\n    (\n      event: Electron.IpcMessageEvent,\n      items: Array<{ id: string; state: IMenuItemState }>\n    ) => {\n      let sendMenuChangedEvent = false\n\n      for (const item of items) {\n        const { id, state } = item\n        const menuItem = findMenuItemByID(menu, id)\n\n        if (menuItem) {\n          // Only send the updated app menu when the state actually changes\n          // or we might end up introducing a never ending loop between\n          // the renderer and the main process\n          if (\n            state.enabled !== undefined &&\n            menuItem.enabled !== state.enabled\n          ) {\n            menuItem.enabled = state.enabled\n            sendMenuChangedEvent = true\n          }\n        } else {\n          fatalError(`Unknown menu id: ${id}`)\n        }\n      }\n\n      if (sendMenuChangedEvent && mainWindow) {\n        mainWindow.sendAppMenu()\n      }\n    }\n  )\n\n  ipcMain.on(\n    'show-contextual-menu',\n    (event: Electron.IpcMessageEvent, items: ReadonlyArray<any>) => {\n      const menu = new Menu()\n      const menuItems = items.map((item, i) => {\n        return new MenuItem({\n          label: item.label,\n          click: () => event.sender.send('contextual-menu-action', i),\n          type: item.type,\n          enabled: item.enabled,\n        })\n      })\n\n      for (const item of menuItems) {\n        menu.append(item)\n      }\n\n      const window = BrowserWindow.fromWebContents(event.sender)\n      menu.popup(window, { async: true })\n    }\n  )\n\n  /**\n   * An event sent by the renderer asking for a copy of the current\n   * application menu.\n   */\n  ipcMain.on('get-app-menu', () => {\n    if (mainWindow) {\n      mainWindow.sendAppMenu()\n    }\n  })\n\n  ipcMain.on(\n    'show-certificate-trust-dialog',\n    (\n      event: Electron.IpcMessageEvent,\n      {\n        certificate,\n        message,\n      }: { certificate: Electron.Certificate; message: string }\n    ) => {\n      // This API is only implemented for macOS and Windows right now.\n      if (__DARWIN__ || __WIN32__) {\n        onDidLoad(window => {\n          window.showCertificateTrustDialog(certificate, message)\n        })\n      }\n    }\n  )\n\n  ipcMain.on(\n    'log',\n    (event: Electron.IpcMessageEvent, level: LogLevel, message: string) => {\n      writeLog(level, message)\n    }\n  )\n\n  ipcMain.on(\n    'uncaught-exception',\n    (event: Electron.IpcMessageEvent, error: Error) => {\n      handleUncaughtException(error)\n    }\n  )\n\n  ipcMain.on(\n    'send-error-report',\n    (\n      event: Electron.IpcMessageEvent,\n      { error, extra }: { error: Error; extra: { [key: string]: string } }\n    ) => {\n      reportError(error, extra)\n    }\n  )\n\n  ipcMain.on(\n    'open-external',\n    (event: Electron.IpcMessageEvent, { path }: { path: string }) => {\n      const result = shell.openExternal(path)\n      event.sender.send('open-external-result', { result })\n    }\n  )\n\n  ipcMain.on(\n    'show-item-in-folder',\n    (event: Electron.IpcMessageEvent, { path }: { path: string }) => {\n      Fs.stat(path, (err, stats) => {\n        if (err) {\n          log.error(`Unable to find file at '${path}'`, err)\n          return\n        }\n\n        if (stats.isDirectory()) {\n          openDirectorySafe(path)\n        } else {\n          shell.showItemInFolder(path)\n        }\n      })\n    }\n  )\n})\n\napp.on('activate', () => {\n  onDidLoad(window => {\n    window.show()\n  })\n})\n\napp.on('web-contents-created', (event, contents) => {\n  contents.on('new-window', (event, url) => {\n    // Prevent links or window.open from opening new windows\n    event.preventDefault()\n    log.warn(`Prevented new window to: ${url}`)\n  })\n})\n\napp.on(\n  'certificate-error',\n  (event, webContents, url, error, certificate, callback) => {\n    callback(false)\n\n    onDidLoad(window => {\n      window.sendCertificateError(certificate, error, url)\n    })\n  }\n)\n\nfunction createWindow() {\n  const window = new AppWindow()\n\n  if (__DEV__) {\n    const installer = require('electron-devtools-installer')\n    require('electron-debug')({ showDevTools: true })\n\n    const extensions = ['REACT_DEVELOPER_TOOLS', 'REACT_PERF']\n\n    for (const name of extensions) {\n      try {\n        installer.default(installer[name])\n      } catch (e) {}\n    }\n  }\n\n  window.onClose(() => {\n    mainWindow = null\n    if (!__DARWIN__ && !preventQuit) {\n      app.quit()\n    }\n  })\n\n  window.onDidLoad(() => {\n    window.show()\n    window.sendLaunchTimingStats({\n      mainReadyTime: readyTime!,\n      loadTime: window.loadTime!,\n      rendererReadyTime: window.rendererReadyTime!,\n    })\n\n    const fns = onDidLoadFns!\n    onDidLoadFns = null\n    for (const fn of fns) {\n      fn(window)\n    }\n  })\n\n  window.load()\n\n  mainWindow = window\n}\n\n/**\n * Register a function to be called once the window has been loaded. If the\n * window has already been loaded, the function will be called immediately.\n */\nfunction onDidLoad(fn: OnDidLoadFn) {\n  if (onDidLoadFns) {\n    onDidLoadFns.push(fn)\n  } else {\n    if (mainWindow) {\n      fn(mainWindow)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/main.ts","import { log } from '../../../main-process/log'\nimport { formatLogMessage } from '../format-log-message'\n\nconst g = global as any\n\ng.log = <IDesktopLogger>{\n  error(message: string, error?: Error) {\n    log('error', '[main] ' + formatLogMessage(message, error))\n  },\n  warn(message: string, error?: Error) {\n    log('warn', '[main] ' + formatLogMessage(message, error))\n  },\n  info(message: string, error?: Error) {\n    log('info', '[main] ' + formatLogMessage(message, error))\n  },\n  debug(message: string, error?: Error) {\n    log('debug', '[main] ' + formatLogMessage(message, error))\n  },\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/main/install.ts","module.exports = {\"_args\":[[{\"raw\":\"winston@https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"scope\":null,\"escapedName\":\"winston\",\"name\":\"winston\",\"rawSpec\":\"https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"spec\":\"https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"type\":\"remote\"},\".\"]],\"_from\":\"winston@>=2.3.1 <3.0.0\",\"_id\":\"winston@2.3.1\",\"_inCache\":true,\"_location\":\"/winston\",\"_phantomChildren\":{},\"_requested\":{\"raw\":\"winston@https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"scope\":null,\"escapedName\":\"winston\",\"name\":\"winston\",\"rawSpec\":\"https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"spec\":\"https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"type\":\"remote\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"_shasum\":\"0b48420d978c01804cf0230b648861598225a119\",\"_shrinkwrap\":null,\"_spec\":\"winston@https://registry.npmjs.org/winston/-/winston-2.3.1.tgz\",\"_where\":\".\",\"author\":{\"name\":\"Charlie Robbins\",\"email\":\"charlie.robbins@gmail.com\"},\"bugs\":{\"url\":\"https://github.com/winstonjs/winston/issues\"},\"dependencies\":{\"async\":\"~1.0.0\",\"colors\":\"1.0.x\",\"cycle\":\"1.0.x\",\"eyes\":\"0.1.x\",\"isstream\":\"0.1.x\",\"stack-trace\":\"0.0.x\"},\"description\":\"A multi-transport async logging library for Node.js\",\"devDependencies\":{\"cross-spawn-async\":\"^2.0.0\",\"hock\":\"1.x.x\",\"std-mocks\":\"~1.0.0\",\"vows\":\"0.7.x\"},\"engines\":{\"node\":\">= 0.10.0\"},\"homepage\":\"https://github.com/winstonjs/winston#readme\",\"keywords\":[\"winston\",\"logging\",\"sysadmin\",\"tools\"],\"license\":\"MIT\",\"main\":\"./lib/winston\",\"maintainers\":[{\"name\":\"Jarrett Cruger\",\"email\":\"jcrugzz@gmail.com\"},{\"name\":\"Alberto Pose\",\"email\":\"albertopose@gmail.com\"}],\"name\":\"winston\",\"optionalDependencies\":{},\"readme\":\"# winston\\n\\n[![Join the chat at https://gitter.im/winstonjs/winston](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/winstonjs/winston?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\\n\\n[![Version npm](https://img.shields.io/npm/v/winston.svg?style=flat-square)](https://www.npmjs.com/package/winston)[![npm Downloads](https://img.shields.io/npm/dm/winston.svg?style=flat-square)](https://www.npmjs.com/package/winston)[![Build Status](https://img.shields.io/travis/winstonjs/winston/master.svg?style=flat-square)](https://travis-ci.org/winstonjs/winston)[![Dependencies](https://img.shields.io/david/winstonjs/winston.svg?style=flat-square)](https://david-dm.org/winstonjs/winston)\\n\\n[![NPM](https://nodei.co/npm/winston.png?downloads=true&downloadRank=true)](https://nodei.co/npm/winston/)\\n\\nA multi-transport async logging library for node.js. <span style=\\\"font-size:28px; font-weight:bold;\\\">&quot;CHILL WINSTON! ... I put it in the logs.&quot;</span>\\n\\n## Motivation\\nWinston is designed to be a simple and universal logging library with support for multiple transports. A transport is essentially a storage device for your logs. Each instance of a winston logger can have multiple transports configured at different levels. For example, one may want error logs to be stored in a persistent remote location (like a database), but all logs output to the console or a local file.\\n\\nThere also seemed to be a lot of logging libraries out there that coupled their implementation of logging (i.e. how the logs are stored / indexed) to the API that they exposed to the programmer. This library aims to decouple those parts of the process to make it more flexible and extensible.\\n\\n## Installation\\n\\n```bashp\\nnpm install winston\\n```\\n\\n## Usage\\nThere are two different ways to use winston: directly via the default logger, or by instantiating your own Logger. The former is merely intended to be a convenient shared logger to use throughout your application if you so choose.\\n\\n* [Logging](#logging)\\n  * [Using the Default Logger](#using-the-default-logger)\\n  * [Instantiating your own Logger](#instantiating-your-own-logger)\\n  * [Logging with Metadata](#logging-with-metadata)\\n  * [String interpolation](#string-interpolation)\\n* [Transports](https://github.com/winstonjs/winston/blob/master/docs/transports.md)\\n  * [Multiple transports of the same type](#multiple-transports-of-the-same-type)\\n* [Profiling](#profiling)\\n* [Streaming Logs](#streaming-logs)\\n* [Querying Logs](#querying-logs)\\n* [Exceptions](#exceptions)\\n  * [Handling Uncaught Exceptions with winston](#handling-uncaught-exceptions-with-winston)\\n  * [To Exit or Not to Exit](#to-exit-or-not-to-exit)\\n* [Logging Levels](#logging-levels)\\n  * [Using Logging Levels](#using-logging-levels)\\n  * [Using Custom Logging Levels](#using-custom-logging-levels)\\n* [Further Reading](#further-reading)\\n  * [Events and Callbacks in Winston](#events-and-callbacks-in-winston)\\n  * [Working with multiple Loggers in winston](#working-with-multiple-loggers-in-winston)\\n  * [Using winston in a CLI tool](#using-winston-in-a-cli-tool)\\n  * [Filters and Rewriters](#filters-and-rewriters)\\n  * [Adding Custom Transports](#adding-custom-transports)\\n* [Installation](#installation)\\n* [Run Tests](#run-tests)\\n\\n\\n## Logging\\n\\nLogging levels in `winston` conform to the severity ordering specified by [RFC5424](https://tools.ietf.org/html/rfc5424): _severity of all levels is assumed to be numerically **ascending** from most important to least important._\\n\\n### Using the Default Logger\\nThe default logger is accessible through the winston module directly. Any method that you could call on an instance of a logger is available on the default logger:\\n\\n``` js\\n  var winston = require('winston');\\n\\n  winston.log('info', 'Hello distributed log files!');\\n  winston.info('Hello again distributed logs');\\n\\n  winston.level = 'debug';\\n  winston.log('debug', 'Now my debug messages are written to console!');\\n```\\n\\nBy default, only the Console transport is set on the default logger. You can add or remove transports via the add() and remove() methods:\\n\\n``` js\\n  winston.add(winston.transports.File, { filename: 'somefile.log' });\\n  winston.remove(winston.transports.Console);\\n```\\n\\nOr do it with one call to configure():\\n\\n``` js\\n  winston.configure({\\n    transports: [\\n      new (winston.transports.File)({ filename: 'somefile.log' })\\n    ]\\n  });\\n```\\n\\nFor more documentation about working with each individual transport supported by Winston see the [Winston Transports](docs/transports.md) document.\\n\\n### Instantiating your own Logger\\nIf you would prefer to manage the object lifetime of loggers you are free to instantiate them yourself:\\n\\n``` js\\n  var logger = new (winston.Logger)({\\n    transports: [\\n      new (winston.transports.Console)(),\\n      new (winston.transports.File)({ filename: 'somefile.log' })\\n    ]\\n  });\\n```\\n\\nYou can work with this logger in the same way that you work with the default logger:\\n\\n``` js\\n  //\\n  // Logging\\n  //\\n  logger.log('info', 'Hello distributed log files!');\\n  logger.info('Hello again distributed logs');\\n\\n  //\\n  // Adding / Removing Transports\\n  //   (Yes It's chainable)\\n  //\\n  logger\\n    .add(winston.transports.File)\\n    .remove(winston.transports.Console);\\n```\\n\\nYou can also wholesale reconfigure a `winston.Logger` instance using the `configure` method:\\n\\n``` js\\n  var logger = new winston.Logger({\\n    level: 'info',\\n    transports: [\\n      new (winston.transports.Console)(),\\n      new (winston.transports.File)({ filename: 'somefile.log' })\\n    ]\\n  });\\n\\n  //\\n  // Replaces the previous transports with those in the\\n  // new configuration wholesale.\\n  //\\n  logger.configure({\\n    level: 'verbose',\\n    transports: [\\n      new (require('winston-daily-rotate-file'))(opts)\\n    ]\\n  });\\n```\\n\\n\\n### Logging with Metadata\\nIn addition to logging string messages, winston will also optionally log additional JSON metadata objects. Adding metadata is simple:\\n\\n``` js\\n  winston.log('info', 'Test Log Message', { anything: 'This is metadata' });\\n```\\n\\nThe way these objects are stored varies from transport to transport (to best support the storage mechanisms offered). Here's a quick summary of how each transports handles metadata:\\n\\n1. __Console:__ Logged via util.inspect(meta)\\n2. __File:__ Logged via util.inspect(meta)\\n\\n## Multiple transports of the same type\\n\\nIt is possible to use multiple transports of the same type e.g. `winston.transports.File` by passing in a custom `name` when you construct the transport.\\n\\n``` js\\nvar logger = new (winston.Logger)({\\n  transports: [\\n    new (winston.transports.File)({\\n      name: 'info-file',\\n      filename: 'filelog-info.log',\\n      level: 'info'\\n    }),\\n    new (winston.transports.File)({\\n      name: 'error-file',\\n      filename: 'filelog-error.log',\\n      level: 'error'\\n    })\\n  ]\\n});\\n```\\n\\nIf you later want to remove one of these transports you can do so by using the string name. e.g.:\\n\\n``` js\\nlogger.remove('info-file');\\n```\\n\\nIn this example one could also remove by passing in the instance of the Transport itself. e.g. this is equivalent to the string example above;\\n\\n``` js\\n// Notice it was first in the Array above\\nvar infoFile = logger.transports[0];\\nlogger.remove(infoFile);\\n```\\n\\n## Profiling\\nIn addition to logging messages and metadata, winston also has a simple profiling mechanism implemented for any logger:\\n\\n``` js\\n  //\\n  // Start profile of 'test'\\n  // Remark: Consider using Date.now() with async operations\\n  //\\n  winston.profile('test');\\n\\n  setTimeout(function () {\\n    //\\n    // Stop profile of 'test'. Logging will now take place:\\n    //   \\\"17 Jan 21:00:00 - info: test duration=1000ms\\\"\\n    //\\n    winston.profile('test');\\n  }, 1000);\\n```\\n\\nAll profile messages are set to the 'info' by default and both message and metadata are optional There are no plans in the Roadmap to make this configurable, but I'm open to suggestions / issues.\\n\\n### String interpolation\\nThe `log` method provides the same string interpolation methods like [`util.format`][10].\\n\\nThis allows for the following log messages.\\n``` js\\nlogger.log('info', 'test message %s', 'my string');\\n// info: test message my string\\n\\nlogger.log('info', 'test message %d', 123);\\n// info: test message 123\\n\\nlogger.log('info', 'test message %j', {number: 123}, {});\\n// info: test message {\\\"number\\\":123}\\n// meta = {}\\n\\nlogger.log('info', 'test message %s, %s', 'first', 'second', {number: 123});\\n// info: test message first, second\\n// meta = {number: 123}\\n\\nlogger.log('info', 'test message', 'first', 'second', {number: 123});\\n// info: test message first second\\n// meta = {number: 123}\\n\\nlogger.log('info', 'test message %s, %s', 'first', 'second', {number: 123}, function(){});\\n// info: test message first, second\\n// meta = {number: 123}\\n// callback = function(){}\\n\\nlogger.log('info', 'test message', 'first', 'second', {number: 123}, function(){});\\n// info: test message first second\\n// meta = {number: 123}\\n// callback = function(){}\\n```\\n\\n\\n\\n\\n\\n## Querying Logs\\nWinston supports querying of logs with Loggly-like options. [See Loggly Search API](https://www.loggly.com/docs/api-retrieving-data/).\\nSpecifically: `File`, `Couchdb`, `Redis`, `Loggly`, `Nssocket`, and `Http`.\\n\\n``` js\\n  var options = {\\n    from: new Date - 24 * 60 * 60 * 1000,\\n    until: new Date,\\n    limit: 10,\\n    start: 0,\\n    order: 'desc',\\n    fields: ['message']\\n  };\\n\\n  //\\n  // Find items logged between today and yesterday.\\n  //\\n  winston.query(options, function (err, results) {\\n    if (err) {\\n      throw err;\\n    }\\n\\n    console.log(results);\\n  });\\n```\\n\\n## Streaming Logs\\nStreaming allows you to stream your logs back from your chosen transport.\\n\\n``` js\\n  //\\n  // Start at the end.\\n  //\\n  winston.stream({ start: -1 }).on('log', function(log) {\\n    console.log(log);\\n  });\\n```\\n\\n## Exceptions\\n\\n### Handling Uncaught Exceptions with winston\\n\\nWith `winston`, it is possible to catch and log `uncaughtException` events from your process. There are two distinct ways of enabling this functionality either through the default winston logger or your own logger instance.\\n\\nIf you want to use this feature with the default logger simply call `.handleExceptions()` with a transport instance.\\n\\n``` js\\n  //\\n  // You can add a separate exception logger by passing it to `.handleExceptions`\\n  //\\n  winston.handleExceptions(new winston.transports.File({ filename: 'path/to/exceptions.log' }))\\n\\n  //\\n  // Alternatively you can set `.handleExceptions` to true when adding transports to winston.\\n  // You can use the `.humanReadableUnhandledException` option to get more readable exceptions.\\n  //\\n  winston.add(winston.transports.File, {\\n    filename: 'path/to/all-logs.log',\\n    handleExceptions: true,\\n    humanReadableUnhandledException: true\\n  });\\n  \\n  //\\n  // Exceptions can also be handled by multiple transports.\\n  //\\n  winston.handleExceptions([ transport1, transport2, ... ]);\\n```\\n\\n### To Exit or Not to Exit\\n\\nBy default, winston will exit after logging an uncaughtException. if this is not the behavior you want,\\nset `exitOnError = false`\\n\\n``` js\\n  var logger = new (winston.Logger)({ exitOnError: false });\\n\\n  //\\n  // or, like this:\\n  //\\n  logger.exitOnError = false;\\n```\\n\\nWhen working with custom logger instances, you can pass in separate transports to the `exceptionHandlers` property or set `.handleExceptions` on any transport.\\n\\nExample 1\\n\\n``` js\\n  var logger = new (winston.Logger)({\\n    transports: [\\n      new winston.transports.File({ filename: 'path/to/all-logs.log' })\\n    ],\\n    exceptionHandlers: [\\n      new winston.transports.File({ filename: 'path/to/exceptions.log' })\\n    ]\\n  });\\n```\\n\\nExample 2\\n\\n``` js\\nvar logger = new winston.Logger({\\n  transports: [\\n    new winston.transports.Console({\\n      handleExceptions: true,\\n      json: true\\n    })\\n  ],\\n  exitOnError: false\\n});\\n```\\n\\nThe `exitOnError` option can also be a function to prevent exit on only certain types of errors:\\n\\n``` js\\n  function ignoreEpipe(err) {\\n    return err.code !== 'EPIPE';\\n  }\\n\\n  var logger = new (winston.Logger)({ exitOnError: ignoreEpipe });\\n\\n  //\\n  // or, like this:\\n  //\\n  logger.exitOnError = ignoreEpipe;\\n```\\n\\n## Logging Levels\\n\\nEach `level` is given a specific integer priority. The higher the priority the more important the message is considered to be, and the lower the corresponding integer priority.  For example, `npm` logging levels are prioritized from 0 to 5 (highest to lowest):\\n\\n``` js\\n{ error: 0, warn: 1, info: 2, verbose: 3, debug: 4, silly: 5 }\\n```\\n\\nSimilarly, as specified exactly in RFC5424 the `syslog` levels are prioritized from 0 to 7 (highest to lowest).\\n\\n```js\\n{ emerg: 0, alert: 1, crit: 2, error: 3, warning: 4, notice: 5, info: 6, debug: 7 }\\n```\\n\\nIf you do not explicitly define the levels that `winston` should use the `npm` levels above will be used.\\n\\n### Using Logging Levels\\nSetting the level for your logging message can be accomplished in one of two ways. You can pass a string representing the logging level to the log() method or use the level specified methods defined on every winston Logger.\\n\\n``` js\\n  //\\n  // Any logger instance\\n  //\\n  logger.log('silly', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.log('debug', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.log('verbose', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.log('warn', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.log('error', \\\"127.0.0.1 - there's no place like home\\\");\\n  logger.info(\\\"127.0.0.1 - there's no place like home\\\");\\n  logger.warn(\\\"127.0.0.1 - there's no place like home\\\");\\n  logger.error(\\\"127.0.0.1 - there's no place like home\\\");\\n\\n  //\\n  // Default logger\\n  //\\n  winston.log('info', \\\"127.0.0.1 - there's no place like home\\\");\\n  winston.info(\\\"127.0.0.1 - there's no place like home\\\");\\n```\\n\\n`winston` allows you to define a `level` property on each transport which specifies the **maximum** level of messages that a transport should log. For example, using the `npm` levels you could log only `error` messages to the console and everything `info` and below to a file (which includes `error` messages):\\n\\n``` js\\n  var logger = new (winston.Logger)({\\n    transports: [\\n      new (winston.transports.Console)({ level: 'error' }),\\n      new (winston.transports.File)({\\n        filename: 'somefile.log',\\n        level: 'info'\\n      })\\n    ]\\n  });\\n```\\n\\nYou may also dynamically change the log level of a transport:\\n\\n``` js\\n  var logger = new (winston.Logger)({\\n    transports: [\\n      new (winston.transports.Console)({ level: 'warn' }),\\n      new (winston.transports.File)({ filename: 'somefile.log', level: 'error' })\\n    ]\\n  });\\n  logger.debug(\\\"Will not be logged in either transport!\\\");\\n  logger.transports.console.level = 'debug';\\n  logger.transports.file.level = 'verbose';\\n  logger.verbose(\\\"Will be logged in both transports!\\\");\\n```\\n\\nAs of 0.2.0, winston supports customizable logging levels, defaulting to [npm][0] style logging levels. Changing logging levels is easy:\\n\\n``` js\\n  //\\n  // Change levels on the default winston logger\\n  //\\n  winston.setLevels(winston.config.syslog.levels);\\n\\n  //\\n  // Change levels on an instance of a logger\\n  //\\n  logger.setLevels(winston.config.syslog.levels);\\n```\\n\\nCalling `.setLevels` on a logger will remove all of the previous helper methods for the old levels and define helper methods for the new levels. Thus, you should be careful about the logging statements you use when changing levels. For example, if you ran this code after changing to the syslog levels:\\n\\n``` js\\n  //\\n  // Logger does not have 'silly' defined since that level is not in the syslog levels\\n  //\\n  logger.silly('some silly message');\\n```\\n\\n### Using Custom Logging Levels\\nIn addition to the predefined `npm` and `syslog` levels available in Winston, you can also choose to define your own:\\n\\n``` js\\n  var myCustomLevels = {\\n    levels: {\\n      foo: 0,\\n      bar: 1,\\n      baz: 2,\\n      foobar: 3\\n    },\\n    colors: {\\n      foo: 'blue',\\n      bar: 'green',\\n      baz: 'yellow',\\n      foobar: 'red'\\n    }\\n  };\\n\\n  var customLevelLogger = new (winston.Logger)({ levels: myCustomLevels.levels });\\n  customLevelLogger.foobar('some foobar level-ed message');\\n```\\n\\nAlthough there is slight repetition in this data structure, it enables simple encapsulation if you do not want to have colors. If you do wish to have colors, in addition to passing the levels to the Logger itself, you must make winston aware of them:\\n\\n``` js\\n  //\\n  // Make winston aware of these colors\\n  //\\n  winston.addColors(myCustomLevels.colors);\\n```\\n\\nThis enables transports with the 'colorize' option set to appropriately color the output of custom levels.\\n\\n## Further Reading\\n\\n### Events and Callbacks in Winston\\nEach instance of winston.Logger is also an instance of an [EventEmitter][1]. A log event will be raised each time a transport successfully logs a message:\\n\\n``` js\\n  logger.on('logging', function (transport, level, msg, meta) {\\n    // [msg] and [meta] have now been logged at [level] to [transport]\\n  });\\n\\n  logger.info('CHILL WINSTON!', { seriously: true });\\n```\\n\\nIt is also worth mentioning that the logger also emits an 'error' event which you should handle or suppress if you don't want unhandled exceptions:\\n\\n``` js\\n  //\\n  // Handle errors\\n  //\\n  logger.on('error', function (err) { /* Do Something */ });\\n\\n  //\\n  // Or just suppress them.\\n  //\\n  logger.emitErrs = false;\\n```\\n\\nEvery logging method described in the previous section also takes an optional callback which will be called only when all of the transports have logged the specified message.\\n\\n``` js\\n  logger.info('CHILL WINSTON!', { seriously: true }, function (err, level, msg, meta) {\\n    // [msg] and [meta] have now been logged at [level] to **every** transport.\\n  });\\n```\\n\\n### Working with multiple Loggers in winston\\n\\nOften in larger, more complex applications it is necessary to have multiple logger instances with different settings. Each logger is responsible for a different feature area (or category). This is exposed in `winston` in two ways: through `winston.loggers` and instances of `winston.Container`. In fact, `winston.loggers` is just a predefined instance of `winston.Container`:\\n\\n``` js\\n  var winston = require('winston');\\n\\n  //\\n  // Configure the logger for `category1`\\n  //\\n  winston.loggers.add('category1', {\\n    console: {\\n      level: 'silly',\\n      colorize: true,\\n      label: 'category one'\\n    },\\n    file: {\\n      filename: '/path/to/some/file'\\n    }\\n  });\\n\\n  //\\n  // Configure the logger for `category2`\\n  //\\n  winston.loggers.add('category2', {\\n    couchdb: {\\n      host: '127.0.0.1',\\n      port: 5984\\n    }\\n  });\\n```\\n\\nNow that your loggers are setup you can require winston _in any file in your application_ and access these pre-configured loggers:\\n\\n``` js\\n  var winston = require('winston');\\n\\n  //\\n  // Grab your preconfigured logger\\n  //\\n  var category1 = winston.loggers.get('category1');\\n\\n  category1.info('logging from your IoC container-based logger');\\n```\\n\\nIf you prefer to manage the `Container` yourself you can simply instantiate one:\\n\\n``` js\\n  var winston = require('winston'),\\n      container = new winston.Container();\\n\\n  container.add('category1', {\\n    console: {\\n      level: 'silly',\\n      colorize: true\\n    },\\n    file: {\\n      filename: '/path/to/some/file'\\n    }\\n  });\\n```\\n\\n### Sharing transports between Loggers in winston\\n\\n``` js\\n  var winston = require('winston');\\n\\n  //\\n  // Setup transports to be shared across all loggers\\n  // in three ways:\\n  //\\n  // 1. By setting it on the default Container\\n  // 2. By passing `transports` into the constructor function of winston.Container\\n  // 3. By passing `transports` into the `.get()` or `.add()` methods\\n  //\\n\\n  //\\n  // 1. By setting it on the default Container\\n  //\\n  winston.loggers.options.transports = [\\n    // Setup your shared transports here\\n  ];\\n\\n  //\\n  // 2. By passing `transports` into the constructor function of winston.Container\\n  //\\n  var container = new winston.Container({\\n    transports: [\\n      // Setup your shared transports here\\n    ]\\n  });\\n\\n  //\\n  // 3. By passing `transports` into the `.get()` or `.add()` methods\\n  //\\n  winston.loggers.add('some-category', {\\n    transports: [\\n      // Setup your shared transports here\\n    ]\\n  });\\n\\n  container.add('some-category', {\\n    transports: [\\n      // Setup your shared transports here\\n    ]\\n  });\\n```\\n\\n### Using winston in a CLI tool\\nA common use-case for logging is output to a CLI tool. Winston has a special helper method which will pretty print output from your CLI tool. Here's an example from the [require-analyzer][2] written by [Nodejitsu][3]:\\n\\n```\\n  info:   require-analyzer starting in /Users/Charlie/Nodejitsu/require-analyzer\\n  info:   Found existing dependencies\\n  data:   {\\n  data:     colors: '0.x.x',\\n  data:     eyes: '0.1.x',\\n  data:     findit: '0.0.x',\\n  data:     npm: '1.0.x',\\n  data:     optimist: '0.2.x',\\n  data:     semver: '1.0.x',\\n  data:     winston: '0.2.x'\\n  data:   }\\n  info:   Analyzing dependencies...\\n  info:   Done analyzing raw dependencies\\n  info:   Retrieved packages from npm\\n  warn:   No additional dependencies found\\n```\\n\\nConfiguring output for this style is easy, just use the `.cli()` method on `winston` or an instance of `winston.Logger`:\\n\\n``` js\\n  var winston = require('winston');\\n\\n  //\\n  // Configure CLI output on the default logger\\n  //\\n  winston.cli();\\n\\n  //\\n  // Configure CLI on an instance of winston.Logger\\n  //\\n  var logger = new winston.Logger({\\n    transports: [\\n      new (winston.transports.Console)()\\n    ]\\n  });\\n\\n  logger.cli();\\n```\\n\\n### Filters and Rewriters\\nFilters allow modifying the contents of **log messages**, and Rewriters allow modifying the contents of **log meta** e.g. to mask data that should not appear in logs.\\n\\nBoth filters and rewriters are simple Arrays of functions which can be provided when creating a `new winston.Logger(options)`. e.g.:\\n\\n``` js\\nvar logger = new winston.Logger({\\n  rewriters: [function (level, msg, meta) { /* etc etc */ }],\\n  filters:   [function (level, msg, meta) { /* etc etc */ }]\\n})\\n```\\n\\nLike any Array they can also be modified at runtime with no adverse side-effects to the `winston` internals.\\n\\n``` js\\nlogger.filters.push(function(level, msg, meta) {\\n  return meta.production\\n    ? maskCardNumbers(msg)\\n    : msg;\\n});\\n\\nlogger.info('transaction with card number 123456789012345 successful.');\\n```\\n\\nThis may result in this output:\\n\\n```\\ninfo: transaction with card number 123456****2345 successful.\\n```\\n\\nWhere as for rewriters, if you wanted to sanitize the `creditCard` field of your `meta` you could:\\n\\n``` js\\nlogger.rewriters.push(function(level, msg, meta) {\\n  if (meta.creditCard) {\\n    meta.creditCard = maskCardNumbers(meta.creditCard)\\n  }\\n\\n  return meta;\\n});\\n\\nlogger.info('transaction ok', { creditCard: 123456789012345 });\\n```\\n\\nwhich may result in this output:\\n\\n```\\ninfo: transaction ok creditCard=123456****2345\\n```\\n\\nSee [log-filter-test.js](./test/log-filter-test.js), where card number masking is implemented as an example along with [log-rewriter-test.js](./test/log-rewriter-test.js)\\n\\n## Adding Custom Transports\\nAdding a custom transport is actually pretty easy. All you need to do is accept a couple of options, set a name, implement a log() method, and add it to the set of transports exposed by winston.\\n\\n``` js\\n  var util = require('util'),\\n      winston = require('winston');\\n\\n  var CustomLogger = winston.transports.CustomLogger = function (options) {\\n    //\\n    // Name this logger\\n    //\\n    this.name = 'customLogger';\\n\\n    //\\n    // Set the level from your options\\n    //\\n    this.level = options.level || 'info';\\n\\n    //\\n    // Configure your storage backing as you see fit\\n    //\\n  };\\n\\n  //\\n  // Inherit from `winston.Transport` so you can take advantage\\n  // of the base functionality and `.handleExceptions()`.\\n  //\\n  util.inherits(CustomLogger, winston.Transport);\\n\\n  CustomLogger.prototype.log = function (level, msg, meta, callback) {\\n    //\\n    // Store this message and metadata, maybe use some custom logic\\n    // then callback indicating success.\\n    //\\n    callback(null, true);\\n  };\\n```\\n\\n### Custom Log Format\\nTo specify custom log format you should set formatter function for transport. Currently supported transports are: Console, File, Memory.\\nOptions object will be passed to the format function. It's general properties are: timestamp, level, message, meta. Depending on the transport type may be additional properties.\\n\\n``` js\\nvar logger = new (winston.Logger)({\\n  transports: [\\n    new (winston.transports.Console)({\\n      timestamp: function() {\\n        return Date.now();\\n      },\\n      formatter: function(options) {\\n        // Return string will be passed to logger.\\n        return options.timestamp() +' '+ options.level.toUpperCase() +' '+ (options.message ? options.message : '') +\\n          (options.meta && Object.keys(options.meta).length ? '\\\\n\\\\t'+ JSON.stringify(options.meta) : '' );\\n      }\\n    })\\n  ]\\n});\\nlogger.info('Data to log.');\\n```\\n\\n### Inspirations\\n1. [npm][0]\\n2. [log.js][4]\\n3. [socket.io][5]\\n4. [node-rlog][6]\\n5. [BigBrother][7]\\n6. [Loggly][8]\\n\\n## Installation\\n\\n### Installing npm (node package manager)\\n```\\n  curl http://npmjs.org/install.sh | sh\\n```\\n\\n### Installing winston\\n```\\n  [sudo] npm install winston\\n```\\n\\n## Run Tests\\nAll of the winston tests are written in [vows][9], and designed to be run with npm.\\n\\n``` bash\\n  $ npm test\\n```\\n\\n#### Author: [Charlie Robbins](http://twitter.com/indexzero)\\n#### Contributors: [Matthew Bergman](http://github.com/fotoverite), [Marak Squires](http://github.com/marak)\\n\\n[0]: https://github.com/npm/npmlog/blob/master/log.js\\n[1]: http://nodejs.org/docs/v0.3.5/api/events.html#events.EventEmitter\\n[2]: http://github.com/nodejitsu/require-analyzer\\n[3]: http://nodejitsu.com\\n[4]: https://github.com/visionmedia/log.js\\n[5]: http://socket.io\\n[6]: https://github.com/jbrisbin/node-rlog\\n[7]: https://github.com/feisty/BigBrother\\n[8]: http://loggly.com\\n[9]: http://vowsjs.org\\n[10]: http://nodejs.org/api/util.html#util_util_format_format\\n[14]: http://nodejs.org/api/stream.html#stream_class_stream_writable\\n[16]: https://github.com/indexzero/winston-mongodb\\n[17]: https://github.com/indexzero/winston-riak\\n[18]: https://github.com/appsattic/winston-simpledb\\n[19]: https://github.com/wavded/winston-mail\\n[21]: https://github.com/jesseditson/winston-sns\\n[22]: https://github.com/flite/winston-graylog2\\n[23]: https://github.com/kenperkins/winston-papertrail\\n[24]: https://github.com/jorgebay/winston-cassandra\\n[25]: https://github.com/jesseditson/winston-sns\\n[26]: https://github.com/inspiredjw/winston-dynamodb/\\n\",\"readmeFilename\":\"README.md\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/winstonjs/winston.git\"},\"scripts\":{\"test\":\"vows --spec --isolate\"},\"version\":\"2.3.1\"}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/package.json\n// module id = 51\n// module chunks = 0","/*\n * transports.js: Set of all transports Winston knows about\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nObject.defineProperty(exports, 'Console', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/console').Console;\n  }\n});\nObject.defineProperty(exports, 'File', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/file').File;\n  }\n});\nObject.defineProperty(exports, 'Http', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/http').Http;\n  }\n});\nObject.defineProperty(exports, 'Memory', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/memory').Memory;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports.js\n// module id = 52\n// module chunks = 0","/*\n * console.js: Transport for outputting to the console\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    os = require('os'),\n    util = require('util'),\n    common = require('../common'),\n    Transport = require('./transport').Transport;\n\n//\n// ### function Console (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Console transport object responsible\n// for persisting log messages and metadata to a terminal or TTY.\n//\nvar Console = exports.Console = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.json         = options.json        || false;\n  this.colorize     = options.colorize    || false;\n  this.prettyPrint  = options.prettyPrint || false;\n  this.timestamp    = typeof options.timestamp !== 'undefined' ? options.timestamp : false;\n  this.showLevel    = options.showLevel === undefined ? true : options.showLevel;\n  this.label        = options.label       || null;\n  this.logstash     = options.logstash    || false;\n  this.depth        = options.depth       || null;\n  this.align        = options.align       || false;\n  this.stderrLevels = setStderrLevels(options.stderrLevels, options.debugStdout);\n  this.eol          = options.eol   || os.EOL;\n\n  if (this.json) {\n    this.stringify = options.stringify || function (obj) {\n      return JSON.stringify(obj, null, 2);\n    };\n  }\n\n  //\n  // Convert stderrLevels into an Object for faster key-lookup times than an Array.\n  //\n  // For backwards compatibility, stderrLevels defaults to ['error', 'debug']\n  // or ['error'] depending on whether options.debugStdout is true.\n  //\n  function setStderrLevels (levels, debugStdout) {\n    var defaultMsg = 'Cannot have non-string elements in stderrLevels Array';\n    if (debugStdout) {\n      if (levels) {\n        //\n        // Don't allow setting both debugStdout and stderrLevels together,\n        // since this could cause behaviour a programmer might not expect.\n        //\n        throw new Error('Cannot set debugStdout and stderrLevels together');\n      }\n\n      return common.stringArrayToSet(['error'], defaultMsg);\n    }\n\n    if (!levels) {\n      return common.stringArrayToSet(['error', 'debug'], defaultMsg);\n    } else if (!(Array.isArray(levels))) {\n      throw new Error('Cannot set stderrLevels to type other than Array');\n    }\n\n    return common.stringArrayToSet(levels, defaultMsg);\n  };\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(Console, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nConsole.prototype.name = 'console';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nConsole.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      output;\n\n  output = common.log({\n    colorize:    this.colorize,\n    json:        this.json,\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    stringify:   this.stringify,\n    timestamp:   this.timestamp,\n    showLevel:   this.showLevel,\n    prettyPrint: this.prettyPrint,\n    raw:         this.raw,\n    label:       this.label,\n    logstash:    this.logstash,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    align:       this.align,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (this.stderrLevels[level]) {\n    process.stderr.write(output + this.eol);\n  } else {\n    process.stdout.write(output + this.eol);\n  }\n\n  //\n  // Emit the `logged` event immediately because the event loop\n  // will not exit until `process.stdout` has drained anyway.\n  //\n  self.emit('logged');\n  callback(null, true);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports/console.js\n// module id = 53\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 54\n// module chunks = 0","/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\n\nvar cycle = exports;\n\ncycle.decycle = function decycle(object) {\n    'use strict';\n\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n\n\ncycle.retrocycle = function retrocycle($) {\n    'use strict';\n\n// Restore an object that was reduced by decycle. Members whose values are\n// objects of the form\n//      {$ref: PATH}\n// are replaced with references to the value found by the PATH. This will\n// restore cycles. The object will be mutated.\n\n// The eval function is used to locate the values described by a PATH. The\n// root object is kept in a $ variable. A regular expression is used to\n// assure that the PATH is extremely well formed. The regexp contains nested\n// * quantifiers. That has been known to have extremely bad performance\n// problems on some browsers for very long strings. A PATH is expected to be\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\n// Goessner's JSONPath.\n\n// So,\n//      var s = '[{\"$ref\":\"$\"}]';\n//      return JSON.retrocycle(JSON.parse(s));\n// produces an array containing a single element which is the array itself.\n\n    var px =\n        /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n\n    (function rez(value) {\n\n// The rez function walks recursively through the object looking for $ref\n// properties. When it finds one that has a value that is a path, then it\n// replaces the $ref object with a reference to the value that is found by\n// the path.\n\n        var i, item, name, path;\n\n        if (value && typeof value === 'object') {\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                for (i = 0; i < value.length; i += 1) {\n                    item = value[i];\n                    if (item && typeof item === 'object') {\n                        path = item.$ref;\n                        if (typeof path === 'string' && px.test(path)) {\n                            value[i] = eval(path);\n                        } else {\n                            rez(item);\n                        }\n                    }\n                }\n            } else {\n                for (name in value) {\n                    if (typeof value[name] === 'object') {\n                        item = value[name];\n                        if (item) {\n                            path = item.$ref;\n                            if (typeof path === 'string' && px.test(path)) {\n                                value[name] = eval(path);\n                            } else {\n                                rez(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }($));\n    return $;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/cycle/cycle.js\n// module id = 55\n// module chunks = 0","module.exports = require(\"string_decoder\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"string_decoder\"\n// module id = 56\n// module chunks = 0","//\n// Remark: Requiring this file will use the \"safe\" colors API which will not touch String.prototype\n//\n//   var colors = require('colors/safe);\n//   colors.red(\"foo\")\n//\n//\nvar colors = require('./lib/colors');\nmodule['exports'] = colors;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/safe.js\n// module id = 57\n// module chunks = 0","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49]\n\n};\n\nObject.keys(codes).forEach(function (key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/styles.js\n// module id = 58\n// module chunks = 0","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar argv = process.argv;\n\nmodule.exports = (function () {\n  if (argv.indexOf('--no-color') !== -1 ||\n    argv.indexOf('--color=false') !== -1) {\n    return false;\n  }\n\n  if (argv.indexOf('--color') !== -1 ||\n    argv.indexOf('--color=true') !== -1 ||\n    argv.indexOf('--color=always') !== -1) {\n    return true;\n  }\n\n  if (process.stdout && !process.stdout.isTTY) {\n    return false;\n  }\n\n  if (process.platform === 'win32') {\n    return true;\n  }\n\n  if ('COLORTERM' in process.env) {\n    return true;\n  }\n\n  if (process.env.TERM === 'dumb') {\n    return false;\n  }\n\n  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n    return true;\n  }\n\n  return false;\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/system/supports-colors.js\n// module id = 59\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 60;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib\n// module id = 60\n// module chunks = 0","module['exports'] = function runTheTrap (text, options) {\n  var result = \"\";\n  text = text || \"Run the trap, drop the bass\";\n  text = text.split('');\n  var trap = {\n    a: [\"\\u0040\", \"\\u0104\", \"\\u023a\", \"\\u0245\", \"\\u0394\", \"\\u039b\", \"\\u0414\"],\n    b: [\"\\u00df\", \"\\u0181\", \"\\u0243\", \"\\u026e\", \"\\u03b2\", \"\\u0e3f\"],\n    c: [\"\\u00a9\", \"\\u023b\", \"\\u03fe\"],\n    d: [\"\\u00d0\", \"\\u018a\", \"\\u0500\" , \"\\u0501\" ,\"\\u0502\", \"\\u0503\"],\n    e: [\"\\u00cb\", \"\\u0115\", \"\\u018e\", \"\\u0258\", \"\\u03a3\", \"\\u03be\", \"\\u04bc\", \"\\u0a6c\"],\n    f: [\"\\u04fa\"],\n    g: [\"\\u0262\"],\n    h: [\"\\u0126\", \"\\u0195\", \"\\u04a2\", \"\\u04ba\", \"\\u04c7\", \"\\u050a\"],\n    i: [\"\\u0f0f\"],\n    j: [\"\\u0134\"],\n    k: [\"\\u0138\", \"\\u04a0\", \"\\u04c3\", \"\\u051e\"],\n    l: [\"\\u0139\"],\n    m: [\"\\u028d\", \"\\u04cd\", \"\\u04ce\", \"\\u0520\", \"\\u0521\", \"\\u0d69\"],\n    n: [\"\\u00d1\", \"\\u014b\", \"\\u019d\", \"\\u0376\", \"\\u03a0\", \"\\u048a\"],\n    o: [\"\\u00d8\", \"\\u00f5\", \"\\u00f8\", \"\\u01fe\", \"\\u0298\", \"\\u047a\", \"\\u05dd\", \"\\u06dd\", \"\\u0e4f\"],\n    p: [\"\\u01f7\", \"\\u048e\"],\n    q: [\"\\u09cd\"],\n    r: [\"\\u00ae\", \"\\u01a6\", \"\\u0210\", \"\\u024c\", \"\\u0280\", \"\\u042f\"],\n    s: [\"\\u00a7\", \"\\u03de\", \"\\u03df\", \"\\u03e8\"],\n    t: [\"\\u0141\", \"\\u0166\", \"\\u0373\"],\n    u: [\"\\u01b1\", \"\\u054d\"],\n    v: [\"\\u05d8\"],\n    w: [\"\\u0428\", \"\\u0460\", \"\\u047c\", \"\\u0d70\"],\n    x: [\"\\u04b2\", \"\\u04fe\", \"\\u04fc\", \"\\u04fd\"],\n    y: [\"\\u00a5\", \"\\u04b0\", \"\\u04cb\"],\n    z: [\"\\u01b5\", \"\\u0240\"]\n  }\n  text.forEach(function(c){\n    c = c.toLowerCase();\n    var chars = trap[c] || [\" \"];\n    var rand = Math.floor(Math.random() * chars.length);\n    if (typeof trap[c] !== \"undefined\") {\n      result += trap[c][rand];\n    } else {\n      result += c;\n    }\n  });\n  return result;\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/custom/trap.js\n// module id = 61\n// module chunks = 0","// please no\nmodule['exports'] = function zalgo(text, options) {\n  text = text || \"   he is here   \";\n  var soul = {\n    \"up\" : [\n      '̍', '̎', '̄', '̅',\n      '̿', '̑', '̆', '̐',\n      '͒', '͗', '͑', '̇',\n      '̈', '̊', '͂', '̓',\n      '̈', '͊', '͋', '͌',\n      '̃', '̂', '̌', '͐',\n      '̀', '́', '̋', '̏',\n      '̒', '̓', '̔', '̽',\n      '̉', 'ͣ', 'ͤ', 'ͥ',\n      'ͦ', 'ͧ', 'ͨ', 'ͩ',\n      'ͪ', 'ͫ', 'ͬ', 'ͭ',\n      'ͮ', 'ͯ', '̾', '͛',\n      '͆', '̚'\n    ],\n    \"down\" : [\n      '̖', '̗', '̘', '̙',\n      '̜', '̝', '̞', '̟',\n      '̠', '̤', '̥', '̦',\n      '̩', '̪', '̫', '̬',\n      '̭', '̮', '̯', '̰',\n      '̱', '̲', '̳', '̹',\n      '̺', '̻', '̼', 'ͅ',\n      '͇', '͈', '͉', '͍',\n      '͎', '͓', '͔', '͕',\n      '͖', '͙', '͚', '̣'\n    ],\n    \"mid\" : [\n      '̕', '̛', '̀', '́',\n      '͘', '̡', '̢', '̧',\n      '̨', '̴', '̵', '̶',\n      '͜', '͝', '͞',\n      '͟', '͠', '͢', '̸',\n      '̷', '͡', ' ҉'\n    ]\n  },\n  all = [].concat(soul.up, soul.down, soul.mid),\n  zalgo = {};\n\n  function randomNumber(range) {\n    var r = Math.floor(Math.random() * range);\n    return r;\n  }\n\n  function is_char(character) {\n    var bool = false;\n    all.filter(function (i) {\n      bool = (i === character);\n    });\n    return bool;\n  }\n  \n\n  function heComes(text, options) {\n    var result = '', counts, l;\n    options = options || {};\n    options[\"up\"] = options[\"up\"] || true;\n    options[\"mid\"] = options[\"mid\"] || true;\n    options[\"down\"] = options[\"down\"] || true;\n    options[\"size\"] = options[\"size\"] || \"maxi\";\n    text = text.split('');\n    for (l in text) {\n      if (is_char(l)) {\n        continue;\n      }\n      result = result + text[l];\n      counts = {\"up\" : 0, \"down\" : 0, \"mid\" : 0};\n      switch (options.size) {\n      case 'mini':\n        counts.up = randomNumber(8);\n        counts.min = randomNumber(2);\n        counts.down = randomNumber(8);\n        break;\n      case 'maxi':\n        counts.up = randomNumber(16) + 3;\n        counts.min = randomNumber(4) + 1;\n        counts.down = randomNumber(64) + 3;\n        break;\n      default:\n        counts.up = randomNumber(8) + 1;\n        counts.mid = randomNumber(6) / 2;\n        counts.down = randomNumber(8) + 1;\n        break;\n      }\n\n      var arr = [\"up\", \"mid\", \"down\"];\n      for (var d in arr) {\n        var index = arr[d];\n        for (var i = 0 ; i <= counts[index]; i++) {\n          if (options[index]) {\n            result = result + soul[index][randomNumber(soul[index].length)];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  // don't summon him\n  return heComes(text);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/custom/zalgo.js\n// module id = 62\n// module chunks = 0","var colors = require('../colors');\n\nmodule['exports'] = (function() {\n  return function (letter, i, exploded) {\n    if(letter === \" \") return letter;\n    switch(i%3) {\n      case 0: return colors.red(letter);\n      case 1: return colors.white(letter)\n      case 2: return colors.blue(letter)\n    }\n  }\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/maps/america.js\n// module id = 63\n// module chunks = 0","var colors = require('../colors');\n\nmodule['exports'] = function (letter, i, exploded) {\n  return i % 2 === 0 ? letter : colors.inverse(letter);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/maps/zebra.js\n// module id = 64\n// module chunks = 0","var colors = require('../colors');\n\nmodule['exports'] = (function () {\n  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV\n  return function (letter, i, exploded) {\n    if (letter === \" \") {\n      return letter;\n    } else {\n      return colors[rainbowColors[i++ % rainbowColors.length]](letter);\n    }\n  };\n})();\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/maps/rainbow.js\n// module id = 65\n// module chunks = 0","var colors = require('../colors');\n\nmodule['exports'] = (function () {\n  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];\n  return function(letter, i, exploded) {\n    return letter === \" \" ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);\n  };\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/colors/lib/maps/random.js\n// module id = 66\n// module chunks = 0","/*\n * cli-config.js: Config that conform to commonly used CLI logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar cliConfig = exports;\n\ncliConfig.levels = {\n  error: 0,\n  warn: 1,\n  help: 2,\n  data: 3,\n  info: 4,\n  debug: 5,\n  prompt: 6,\n  verbose: 7,\n  input: 8,\n  silly: 9,\n};\n\ncliConfig.colors = {\n  error: 'red',\n  warn: 'yellow',\n  help: 'cyan',\n  data: 'grey',\n  info: 'green',\n  debug: 'blue',\n  prompt: 'grey',\n  verbose: 'cyan',\n  input: 'grey',\n  silly: 'magenta'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/config/cli-config.js\n// module id = 67\n// module chunks = 0","/*\n * npm-config.js: Config that conform to npm logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar npmConfig = exports;\n\nnpmConfig.levels = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  verbose: 3,\n  debug: 4,\n  silly: 5\n};\n\nnpmConfig.colors = {\n  error: 'red',\n  warn: 'yellow',\n  info: 'green',\n  verbose: 'cyan',\n  debug: 'blue',\n  silly: 'magenta'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/config/npm-config.js\n// module id = 68\n// module chunks = 0","/*\n * syslog-config.js: Config that conform to syslog logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar syslogConfig = exports;\n\nsyslogConfig.levels = {\n  emerg: 0,\n  alert: 1,\n  crit: 2,\n  error: 3,\n  warning: 4,\n  notice: 5,\n  info: 6,\n  debug: 7\n};\n\nsyslogConfig.colors = {\n  emerg: 'red',\n  alert: 'yellow',\n  crit: 'red',\n  error: 'red',\n  warning: 'red',\n  notice: 'yellow',\n  info: 'green',\n  debug: 'blue'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/config/syslog-config.js\n// module id = 69\n// module chunks = 0","/*\n * file.js: Transport for outputting to a local log file\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    async = require('async'),\n    zlib = require('zlib'),\n    common = require('../common'),\n    Transport = require('./transport').Transport,\n    isWritable = require('isstream').isWritable,\n    Stream = require('stream').Stream,\n    os = require('os');\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the File transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar File = exports.File = function (options) {\n  var self = this;\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf (target /*, illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename\n      ? path.basename(options.filename)\n      : 'winston.log';\n\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || { flags: 'a' };\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  }\n  else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    this._isStreams2 = isWritable(this._stream);\n    this._stream.on('error', function(error){\n      self.emit('error', error);\n    });\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  }\n  else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json        = options.json !== false;\n  this.logstash    = options.logstash    || false;\n  this.colorize    = options.colorize    || false;\n  this.maxsize     = options.maxsize     || null;\n  this.rotationFormat = options.rotationFormat || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxFiles    = options.maxFiles    || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.label       = options.label       || null;\n  this.timestamp   = options.timestamp != null ? options.timestamp : true;\n  this.eol         = options.eol || os.EOL;\n  this.tailable    = options.tailable    || false;\n  this.depth       = options.depth       || null;\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\n  this.maxRetries  = options.maxRetries || 2;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size     = 0;\n  this._created  = 0;\n  this._buffer   = [];\n  this._draining = false;\n  this._opening  = false;\n  this._failures = 0;\n  this._archive = null;\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(File, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nFile.prototype.name = 'file';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  if (typeof msg !== 'string') {\n    msg = '' + msg;\n  }\n\n  var output = common.log({\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    json:        this.json,\n    logstash:    this.logstash,\n    colorize:    this.colorize,\n    prettyPrint: this.prettyPrint,\n    timestamp:   this.timestamp,\n    showLevel:   this.showLevel,\n    stringify:   this.stringify,\n    label:       this.label,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (typeof output === 'string') {\n    output += this.eol;\n  }\n\n  if (!this.filename) {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._size += output.length;\n    this._lazyDrain();\n  }\n  else {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n      self._size += output.length;\n      self._lazyDrain();\n    });\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nFile.prototype._write = function(data, callback) {\n  if (this._isStreams2) {\n    this._stream.write(data);\n    return callback && process.nextTick(function () {\n      callback(null, true);\n    });\n  }\n\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) return;\n  if (ret === false) {\n    return this._stream.once('drain', function() {\n      callback(null, true);\n    });\n  }\n  process.nextTick(function () {\n    callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var file = path.join(this.dirname, this.filename),\n      options = this.normalizeQuery(options),\n      buff = '',\n      results = [],\n      row = 0;\n\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n    if (!callback) return;\n    return err.code !== 'ENOENT'\n      ? callback(err)\n      : callback(null, results);\n  });\n\n  stream.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n      row++;\n    }\n\n    buff = data[l];\n  });\n\n  stream.on('close', function () {\n    if (buff) add(buff, true);\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n    if (callback) callback(null, results);\n  });\n\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) push(log);\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n\n  function push(log) {\n    if (options.rows && results.length >= options.rows\n        && options.order != 'desc') {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      return;\n    }\n\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n\n    if (options.order === 'desc') {\n      if (results.length >= options.rows) {\n        results.shift();\n      }\n    }\n    results.push(log);\n  }\n\n  function check(log) {\n    if (!log) return;\n\n    if (typeof log !== 'object') return;\n\n    var time = new Date(log.timestamp);\n    if ((options.from && time < options.from)\n        || (options.until && time > options.until)) {\n      return;\n    }\n\n    return true;\n  }\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this.filename),\n      options = options || {},\n      stream = new Stream;\n\n  var tail = {\n    file: file,\n    start: options.start\n  };\n\n  stream.destroy = common.tailFile(tail, function (err, line) {\n\n    if(err){\n      return stream.emit('error',err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  }\n  else if (!this._stream || (this.maxsize && this._size >= this.maxsize)) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  this._archive = this.zippedArchive ? this._stream.path : null;\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n\n    this._stream.once('finish', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nFile.prototype.flush = function () {\n  var self = this;\n\n  // If nothing to flush, there will be no \"flush\" event from native stream\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\n  // That means, self.opening will never set to false and no logs will be written to disk\n  if (!this._buffer.length) {\n    return self.emit('flush');\n  }\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0],\n        callback = item[1];\n\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile (target) {\n    var fullname = path.join(self.dirname, target);\n\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush (size) {\n      if (self._stream) {\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._isStreams2 = isWritable(self._stream);\n      self._stream.on('error', function(error){\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        }\n        else {\n          self.emit('error', error);\n        }\n      });\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      if (self._archive) {\n        var gzip = zlib.createGzip();\n\n        var inp = fs.createReadStream(String(self._archive));\n        var out = fs.createWriteStream(self._archive + '.gz');\n\n        inp.pipe(gzip).pipe(out);\n\n        fs.unlink(String(self._archive));\n        self._archive = '';\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n        return createAndFlush(0);\n      }\n\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return self._incFile(function() {\n          checkFile(self._getFile());\n        });\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\n\nFile.prototype._incFile = function (callback) {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext),\n      oldest,\n      target;\n\n  if (!this.tailable) {\n    this._created += 1;\n    this._checkMaxFilesIncrementing(ext, basename, callback);\n  }\n  else {\n    this._checkMaxFilesTailable(ext, basename, callback);\n  }\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nFile.prototype._getFile = function () {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext);\n\n  //\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\n  // when combined with max files because the set of files to unlink\n  // is never stored.\n  //\n  return !this.tailable && this._created\n    ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext\n    : basename + ext;\n};\n\n//\n// ### @private function _checkMaxFilesIncrementing ()\n// Increment the number of files created or\n// checked by this instance.\n//\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\n  var oldest, target,\n    self = this;\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename +\n        ((self._created === 1) ? '' : self._created-1) +\n        ext);\n  }\n\n\n  // Check for maxFiles option and delete file\n  if (!self.maxFiles || self._created < self.maxFiles) {\n    return callback();\n  }\n\n  oldest = self._created - self.maxFiles;\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext +\n    (self.zippedArchive ? '.gz' : ''));\n  fs.unlink(target, callback);\n};\n\n//\n// ### @private function _checkMaxFilesTailable ()\n//\n// Roll files forward based on integer, up to maxFiles.\n// e.g. if base if file.log and it becomes oversized, roll\n//    to file1.log, and allow file.log to be re-used. If\n//    file is oversized again, roll file1.log to file2.log,\n//    roll file.log to file1.log, and so on.\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\n  var tasks = [],\n      self = this;\n\n  if (!this.maxFiles)\n    return;\n\n  for (var x = this.maxFiles - 1; x > 0; x--) {\n    tasks.push(function (i) {\n      return function (cb) {\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext +\n          (self.zippedArchive ? '.gz' : ''));\n        fs.exists(tmppath, function (exists) {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext +\n            (self.zippedArchive ? '.gz' : '')), cb);\n        });\n      };\n    }(x));\n  }\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + 1 + ext);\n  }\n  async.series(tasks, function (err) {\n    fs.rename(\n      path.join(self.dirname, basename + ext),\n      path.join(self.dirname, basename + 1 + ext),\n      callback\n    );\n  });\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports/file.js\n// module id = 70\n// module chunks = 0","var stream = require('stream')\n\n\nfunction isStream (obj) {\n  return obj instanceof stream.Stream\n}\n\n\nfunction isReadable (obj) {\n  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'\n}\n\n\nfunction isWritable (obj) {\n  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'\n}\n\n\nfunction isDuplex (obj) {\n  return isReadable(obj) && isWritable(obj)\n}\n\n\nmodule.exports            = isStream\nmodule.exports.isReadable = isReadable\nmodule.exports.isWritable = isWritable\nmodule.exports.isDuplex   = isDuplex\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/isstream/isstream.js\n// module id = 71\n// module chunks = 0","var util = require('util'),\n    winston = require('../../winston'),\n    http = require('http'),\n    https = require('https'),\n    Stream = require('stream').Stream,\n    Transport = require('./transport').Transport;\n\n//\n// ### function Http (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Http transport object responsible\n// for persisting log messages and metadata to a terminal or TTY.\n//\nvar Http = exports.Http = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.name = 'http';\n  this.ssl = !!options.ssl;\n  this.host = options.host || 'localhost';\n  this.port = options.port;\n  this.auth = options.auth;\n  this.path = options.path || '';\n  this.agent = options.agent;\n\n  if (!this.port) {\n    this.port = this.ssl ? 443 : 80;\n  }\n};\n\nutil.inherits(Http, winston.Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nHttp.prototype.name = 'http';\n\n//\n// ### function _request (options, callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Make a request to a winstond server or any http server which can\n// handle json-rpc.\n//\nHttp.prototype._request = function (options, callback) {\n  options = options || {};\n\n  var auth = options.auth || this.auth,\n      path = options.path || this.path || '',\n      req;\n\n  delete options.auth;\n  delete options.path;\n\n  // Prepare options for outgoing HTTP request\n  req = (this.ssl ? https : http).request({\n    host: this.host,\n    port: this.port,\n    path: '/' + path.replace(/^\\//, ''),\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    agent: this.agent,\n    auth: (auth) ? auth.username + ':' + auth.password : ''\n  });\n\n  req.on('error', callback);\n  req.on('response', function (res) {\n    var body = '';\n\n    res.on('data', function (chunk) {\n      body += chunk;\n    });\n\n    res.on('end', function () {\n      callback(null, res, body);\n    });\n\n    res.resume();\n  });\n\n  req.end(new Buffer(JSON.stringify(options), 'utf8'));\n};\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nHttp.prototype.log = function (level, msg, meta, callback) {\n  var self = this;\n\n  if (typeof meta === 'function') {\n    callback = meta;\n    meta = {};\n  }\n\n  var options = {\n    method: 'collect',\n    params: {\n      level: level,\n      message: msg,\n      meta: meta\n    }\n  };\n\n  if (meta) {\n    if (meta.path) {\n      options.path = meta.path;\n      delete meta.path;\n    }\n\n    if (meta.auth) {\n      options.auth = meta.auth;\n      delete meta.auth;\n    }\n  }\n\n  this._request(options, function (err, res) {\n    if (res && res.statusCode !== 200) {\n      err = new Error('HTTP Status Code: ' + res.statusCode);\n    }\n\n    if (err) return callback(err);\n\n    // TODO: emit 'logged' correctly,\n    // keep track of pending logs.\n    self.emit('logged');\n\n    if (callback) callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nHttp.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self = this,\n      options = this.normalizeQuery(options);\n\n  options = {\n    method: 'query',\n    params: options\n  };\n\n  if (options.params.path) {\n    options.path = options.params.path;\n    delete options.params.path;\n  }\n\n  if (options.params.auth) {\n    options.auth = options.params.auth;\n    delete options.params.auth;\n  }\n\n  this._request(options, function (err, res, body) {\n    if (res && res.statusCode !== 200) {\n      err = new Error('HTTP Status Code: ' + res.statusCode);\n    }\n\n    if (err) return callback(err);\n\n    if (typeof body === 'string') {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        return callback(e);\n      }\n    }\n\n    callback(null, body);\n  });\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nHttp.prototype.stream = function (options) {\n  options = options || {};\n  \n  var self = this,\n      stream = new Stream,\n      req,\n      buff;\n\n  stream.destroy = function () {\n    req.destroy();\n  };\n\n  options = {\n    method: 'stream',\n    params: options\n  };\n\n  if (options.params.path) {\n    options.path = options.params.path;\n    delete options.params.path;\n  }\n\n  if (options.params.auth) {\n    options.auth = options.params.auth;\n    delete options.params.auth;\n  }\n\n  req = this._request(options);\n  buff = '';\n\n  req.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      try {\n        stream.emit('log', JSON.parse(data[i]));\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    }\n\n    buff = data[l];\n  });\n\n  req.on('error', function (err) {\n    stream.emit('error', err);\n  });\n\n  return stream;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports/http.js\n// module id = 72\n// module chunks = 0","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 73\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 74\n// module chunks = 0","var events = require('events'),\n    util = require('util'),\n    common = require('../common'),\n    Transport = require('./transport').Transport;\n\n//\n// ### function Memory (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Memory transport object responsible\n// for persisting log messages and metadata to a memory array of messages.\n//\nvar Memory = exports.Memory = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.errorOutput = [];\n  this.writeOutput = [];\n\n  this.json        = options.json        || false;\n  this.colorize    = options.colorize    || false;\n  this.prettyPrint = options.prettyPrint || false;\n  this.timestamp   = typeof options.timestamp !== 'undefined' ? options.timestamp : false;\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\n  this.label       = options.label       || null;\n  this.depth       = options.depth       || null;\n\n  if (this.json) {\n    this.stringify = options.stringify || function (obj) {\n      return JSON.stringify(obj, null, 2);\n    };\n  }\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(Memory, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nMemory.prototype.name = 'memory';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nMemory.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      output;\n\n  output = common.log({\n    colorize:    this.colorize,\n    json:        this.json,\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    stringify:   this.stringify,\n    timestamp:   this.timestamp,\n    prettyPrint: this.prettyPrint,\n    raw:         this.raw,\n    label:       this.label,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (level === 'error' || level === 'debug') {\n    this.errorOutput.push(output);\n  } else {\n    this.writeOutput.push(output);\n  }\n\n  self.emit('logged');\n  callback(null, true);\n};\n\nMemory.prototype.clearLogs = function () {\n  this.errorOutput = [];\n  this.writeOutput = [];\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/transports/memory.js\n// module id = 75\n// module chunks = 0","exports.get = function(belowFn) {\n  var oldLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = Infinity;\n\n  var dummyObject = {};\n\n  var v8Handler = Error.prepareStackTrace;\n  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {\n    return v8StackTrace;\n  };\n  Error.captureStackTrace(dummyObject, belowFn || exports.get);\n\n  var v8StackTrace = dummyObject.stack;\n  Error.prepareStackTrace = v8Handler;\n  Error.stackTraceLimit = oldLimit;\n\n  return v8StackTrace;\n};\n\nexports.parse = function(err) {\n  if (!err.stack) {\n    return [];\n  }\n\n  var self = this;\n  var lines = err.stack.split('\\n').slice(1);\n\n  return lines\n    .map(function(line) {\n      if (line.match(/^\\s*[-]{4,}$/)) {\n        return self._createParsedCallSite({\n          fileName: line,\n          lineNumber: null,\n          functionName: null,\n          typeName: null,\n          methodName: null,\n          columnNumber: null,\n          'native': null,\n        });\n      }\n\n      var lineMatch = line.match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n      if (!lineMatch) {\n        return;\n      }\n\n      var object = null;\n      var method = null;\n      var functionName = null;\n      var typeName = null;\n      var methodName = null;\n      var isNative = (lineMatch[5] === 'native');\n\n      if (lineMatch[1]) {\n        var methodMatch = lineMatch[1].match(/([^\\.]+)(?:\\.(.+))?/);\n        object = methodMatch[1];\n        method = methodMatch[2];\n        functionName = lineMatch[1];\n        typeName = 'Object';\n      }\n\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n\n      if (method === '<anonymous>') {\n        methodName = null;\n        functionName = '';\n      }\n\n      var properties = {\n        fileName: lineMatch[2] || null,\n        lineNumber: parseInt(lineMatch[3], 10) || null,\n        functionName: functionName,\n        typeName: typeName,\n        methodName: methodName,\n        columnNumber: parseInt(lineMatch[4], 10) || null,\n        'native': isNative,\n      };\n\n      return self._createParsedCallSite(properties);\n    })\n    .filter(function(callSite) {\n      return !!callSite;\n    });\n};\n\nexports._createParsedCallSite = function(properties) {\n  var methods = {};\n  for (var property in properties) {\n    var prefix = 'get';\n    if (property === 'native') {\n      prefix = 'is';\n    }\n    var method = prefix + property.substr(0, 1).toUpperCase() + property.substr(1);\n\n    (function(property) {\n      methods[method] = function() {\n        return properties[property];\n      }\n    })(property);\n  }\n\n  var callSite = Object.create(methods);\n  for (var property in properties) {\n    callSite[property] = properties[property];\n  }\n\n  return callSite;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/stack-trace/lib/stack-trace.js\n// module id = 76\n// module chunks = 0","/*\n * container.js: Inversion of control container for winston logger instances\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar common = require('./common'),\n    winston = require('../winston'),\n    extend = require('util')._extend;\n\n//\n// ### function Container (options)\n// #### @options {Object} Default pass-thru options for Loggers\n// Constructor function for the Container object responsible for managing\n// a set of `winston.Logger` instances based on string ids.\n//\nvar Container = exports.Container = function (options) {\n  this.loggers = {};\n  this.options = options || {};\n  this.default = {\n    transports: [\n      new winston.transports.Console({\n        level: 'silly',\n        colorize: false\n      })\n    ]\n  }\n};\n\n//\n// ### function get / add (id, options)\n// #### @id {string} Id of the Logger to get\n// #### @options {Object} **Optional** Options for the Logger instance\n// Retreives a `winston.Logger` instance for the specified `id`. If\n// an instance does not exist, one is created.\n//\nContainer.prototype.get = Container.prototype.add = function (id, options) {\n  var self = this,\n      existing;\n\n  if (!this.loggers[id]) {\n    //\n    // Remark: Simple shallow clone for configuration options in case we pass in\n    // instantiated protoypal objects\n    //\n    options = extend({}, options || this.options || this.default);\n    existing = options.transports || this.options.transports;\n    //\n    // Remark: Make sure if we have an array of transports we slice it to make copies\n    // of those references.\n    //\n    options.transports = existing ? existing.slice() : [];\n\n    if (options.transports.length === 0 && (!options || !options['console'])) {\n      options.transports.push(this.default.transports[0]);\n    }\n\n    Object.keys(options).forEach(function (key) {\n      if (key === 'transports') {\n        return;\n      }\n\n      var name = common.capitalize(key);\n\n      if (!winston.transports[name]) {\n        throw new Error('Cannot add unknown transport: ' + name);\n      }\n\n      var namedOptions = options[key];\n      namedOptions.id = id;\n      options.transports.push(new (winston.transports[name])(namedOptions));\n    });\n\n    options.id = id;\n    this.loggers[id] = new winston.Logger(options);\n\n    this.loggers[id].on('close', function () {\n        self._delete(id);\n    });\n  }\n\n  return this.loggers[id];\n};\n\n//\n// ### function close (id)\n// #### @id {string} **Optional** Id of the Logger instance to find\n// Returns a boolean value indicating if this instance\n// has a logger with the specified `id`.\n//\nContainer.prototype.has = function (id) {\n  return !!this.loggers[id];\n};\n\n//\n// ### function close (id)\n// #### @id {string} **Optional** Id of the Logger instance to close\n// Closes a `Logger` instance with the specified `id` if it exists.\n// If no `id` is supplied then all Loggers are closed.\n//\nContainer.prototype.close = function (id) {\n  var self = this;\n\n  function _close (id) {\n    if (!self.loggers[id]) {\n      return;\n    }\n\n    self.loggers[id].close();\n    self._delete(id);\n  }\n\n  return id ? _close(id) : Object.keys(this.loggers).forEach(function (id) {\n    _close(id);\n  });\n};\n\n//\n// ### @private function _delete (id)\n// #### @id {string} Id of the Logger instance to delete from container\n// Deletes a `Logger` instance with the specified `id`.\n//\nContainer.prototype._delete = function (id) {\n    delete this.loggers[id];\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/container.js\n// module id = 77\n// module chunks = 0","/*\n * logger.js: Core logger object used by winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    util = require('util'),\n    async = require('async'),\n    config = require('./config'),\n    common = require('./common'),\n    exception = require('./exception'),\n    Stream = require('stream').Stream;\n\nvar formatRegExp = /%[sdj%]/g;\n\n//\n// ### function Logger (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Logger object responsible\n// for persisting log messages and metadata to one or more transports.\n//\nvar Logger = exports.Logger = function (options) {\n  events.EventEmitter.call(this);\n  this.configure(options);\n};\n\n//\n// Inherit from `events.EventEmitter`.\n//\nutil.inherits(Logger, events.EventEmitter);\n\n//\n// ### function configure (options)\n// This will wholesale reconfigure this instance by:\n// 1. Resetting all transports. Older transports will be removed implicitly.\n// 2. Set all other options including levels, colors, rewriters, filters,\n//    exceptionHandlers, etc.\n//\nLogger.prototype.configure = function (options) {\n  var self = this;\n\n  //\n  // If we have already been setup with transports\n  // then remove them before proceeding.\n  //\n  if (Array.isArray(this._names) && this._names.length) {\n    this.clear();\n  }\n\n  options = options || {};\n  this.transports = {};\n  this._names     = [];\n\n  if (options.transports) {\n    options.transports.forEach(function (transport) {\n      self.add(transport, null, true);\n    });\n  }\n\n  //\n  // Set Levels and default logging level\n  //\n  this.padLevels = options.padLevels || false;\n  this.setLevels(options.levels);\n  if (options.colors) {\n    config.addColors(options.colors);\n  }\n\n  //\n  // Hoist other options onto this instance.\n  //\n  this.id          = options.id || null;\n  this.level       = options.level || 'info';\n  this.emitErrs    = options.emitErrs || false;\n  this.stripColors = options.stripColors || false;\n  this.exitOnError = typeof options.exitOnError !== 'undefined'\n    ? options.exitOnError\n    : true;\n\n  //\n  // Setup internal state as empty Objects even though it is\n  // defined lazily later to ensure a strong existential API contract.\n  //\n  this.exceptionHandlers = {};\n  this.profilers         = {};\n\n  ['rewriters', 'filters'].forEach(function (kind) {\n    self[kind] = Array.isArray(options[kind])\n      ? options[kind]\n      : [];\n  });\n\n  if (options.exceptionHandlers) {\n    this.handleExceptions(options.exceptionHandlers);\n  }\n};\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nLogger.prototype.log = function (level) {\n  var args = Array.prototype.slice.call(arguments, 1),\n      self = this,\n      transports;\n\n  while (args[args.length - 1] === null) {\n    args.pop();\n  }\n\n  //\n  // Determining what is `meta` and what are arguments for string interpolation\n  // turns out to be VERY tricky. e.g. in the cases like this:\n  //\n  //    logger.info('No interpolation symbols', 'ok', 'why', { meta: 'is-this' });\n  //\n  var callback  = typeof args[args.length - 1] === 'function'\n    ? args.pop()\n    : null;\n\n  //\n  // Handle errors appropriately.\n  //\n  function onError(err) {\n    if (callback) {\n      callback(err);\n    }\n    else if (self.emitErrs) {\n      self.emit('error', err);\n    }\n  }\n\n  if (this._names.length === 0) {\n    return onError(new Error('Cannot log with no transports.'));\n  }\n  else if (typeof self.levels[level] === 'undefined') {\n    return onError(new Error('Unknown log level: ' + level));\n  }\n\n  //\n  // If there are no transports that match the level\n  // then be eager and return. This could potentially be calculated\n  // during `setLevels` for more performance gains.\n  //\n  var targets = this._names.filter(function (name) {\n    var transport = self.transports[name];\n    return (transport.level && self.levels[transport.level] >= self.levels[level])\n      || (!transport.level && self.levels[self.level] >= self.levels[level]);\n  });\n\n  if (!targets.length) {\n    if (callback) { callback(); }\n    return;\n  }\n\n  //\n  // Determining what is `meta` and what are arguments for string interpolation\n  // turns out to be VERY tricky. e.g. in the cases like this:\n  //\n  //    logger.info('No interpolation symbols', 'ok', 'why', { meta: 'is-this' });\n  //\n  var msg, meta = {}, validMeta = false;\n  var hasFormat = args && args[0] && args[0].match && args[0].match(formatRegExp) !== null;\n  var tokens = (hasFormat) ? args[0].match(formatRegExp) : [];\n  var ptokens = tokens.filter(function(t) { return t === '%%' });\n  if (((args.length - 1) - (tokens.length - ptokens.length)) > 0 || args.length === 1) {\n    // last arg is meta\n    meta = args[args.length - 1] || args;\n    var metaType = Object.prototype.toString.call(meta);\n    validMeta = metaType === '[object Object]' ||\n      metaType === '[object Error]' || metaType === '[object Array]';\n    meta = validMeta ? args.pop() : {};\n  }\n  msg = util.format.apply(null, args);\n\n  //\n  // Respond to the callback.\n  //\n  function finish(err) {\n    if (callback) {\n      if (err) return callback(err);\n      callback(null, level, msg, meta);\n    }\n\n    callback = null;\n    if (!err) {\n      self.emit('logged', level, msg, meta);\n    }\n  }\n\n  // If we should pad for levels, do so\n  if (this.padLevels) {\n    msg = new Array(this.levelLength - level.length + 1).join(' ') + msg;\n  }\n\n  this.rewriters.forEach(function (rewriter) {\n    meta = rewriter(level, msg, meta, self);\n  });\n\n  this.filters.forEach(function(filter) {\n    var filtered = filter(level, msg, meta, self);\n    if (typeof filtered === 'string')\n      msg = filtered;\n    else {\n      msg = filtered.msg;\n      meta = filtered.meta;\n    }\n  });\n\n  //\n  // For consideration of terminal 'color\" programs like colors.js,\n  // which can add ANSI escape color codes to strings, we destyle the\n  // ANSI color escape codes when `this.stripColors` is set.\n  //\n  // see: http://en.wikipedia.org/wiki/ANSI_escape_code\n  //\n  if (this.stripColors) {\n    var code = /\\u001b\\[(\\d+(;\\d+)*)?m/g;\n    msg = ('' + msg).replace(code, '');\n  }\n\n  //\n  // Log for each transport and emit 'logging' event\n  //\n  function transportLog(name, next) {\n    var transport = self.transports[name];\n    transport.log(level, msg, meta, function (err) {\n      if (err) {\n        err.transport = transport;\n        finish(err);\n        return next();\n      }\n\n      self.emit('logging', transport, level, msg, meta);\n      next();\n    });\n  }\n\n  async.forEach(targets, transportLog, finish);\n  return this;\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Queries the all transports for this instance with the specified `options`.\n// This will aggregate each transport's results into one object containing\n// a property per transport.\n//\nLogger.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self = this,\n      options = options || {},\n      results = {},\n      query = common.clone(options.query) || {},\n      transports;\n\n  //\n  // Helper function to query a single transport\n  //\n  function queryTransport(transport, next) {\n    if (options.query) {\n      options.query = transport.formatQuery(query);\n    }\n\n    transport.query(options, function (err, results) {\n      if (err) {\n        return next(err);\n      }\n\n      next(null, transport.formatResults(results, options.format));\n    });\n  }\n\n  //\n  // Helper function to accumulate the results from\n  // `queryTransport` into the `results`.\n  //\n  function addResults(transport, next) {\n    queryTransport(transport, function (err, result) {\n      //\n      // queryTransport could potentially invoke the callback\n      // multiple times since Transport code can be unpredictable.\n      //\n      if (next) {\n        result = err || result;\n        if (result) {\n          results[transport.name] = result;\n        }\n\n        next();\n      }\n\n      next = null;\n    });\n  }\n\n  //\n  // If an explicit transport is being queried then\n  // respond with the results from only that transport\n  //\n  if (options.transport) {\n    options.transport = options.transport.toLowerCase();\n    return queryTransport(this.transports[options.transport], callback);\n  }\n\n  //\n  // Create a list of all transports for this instance.\n  //\n  transports = this._names.map(function (name) {\n    return self.transports[name];\n  }).filter(function (transport) {\n    return !!transport.query;\n  });\n\n  //\n  // Iterate over the transports in parallel setting the\n  // appropriate key in the `results`\n  //\n  async.forEach(transports, addResults, function () {\n    callback(null, results);\n  });\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for all transports. Options object is optional.\n//\nLogger.prototype.stream = function (options) {\n  var self = this,\n      options = options || {},\n      out = new Stream,\n      streams = [],\n      transports;\n\n  if (options.transport) {\n    var transport = this.transports[options.transport];\n    delete options.transport;\n    if (transport && transport.stream) {\n      return transport.stream(options);\n    }\n  }\n\n  out._streams = streams;\n  out.destroy = function () {\n    var i = streams.length;\n    while (i--) streams[i].destroy();\n  };\n\n  //\n  // Create a list of all transports for this instance.\n  //\n  transports = this._names.map(function (name) {\n    return self.transports[name];\n  }).filter(function (transport) {\n    return !!transport.stream;\n  });\n\n  transports.forEach(function (transport) {\n    var stream = transport.stream(options);\n    if (!stream) return;\n\n    streams.push(stream);\n\n    stream.on('log', function (log) {\n      log.transport = log.transport || [];\n      log.transport.push(transport.name);\n      out.emit('log', log);\n    });\n\n    stream.on('error', function (err) {\n      err.transport = err.transport || [];\n      err.transport.push(transport.name);\n      out.emit('error', err);\n    });\n  });\n\n  return out;\n};\n\n//\n// ### function close ()\n// Cleans up resources (streams, event listeners) for all\n// transports associated with this instance (if necessary).\n//\nLogger.prototype.close = function () {\n  var self = this;\n\n  this._names.forEach(function (name) {\n    var transport = self.transports[name];\n    if (transport && transport.close) {\n      transport.close();\n    }\n  });\n\n  this.emit('close');\n};\n\n//\n// ### function handleExceptions ([tr0, tr1...] || tr0, tr1, ...)\n// Handles `uncaughtException` events for the current process by\n// ADDING any handlers passed in.\n//\nLogger.prototype.handleExceptions = function () {\n  var args = Array.prototype.slice.call(arguments),\n      handlers = [],\n      self = this;\n\n  args.forEach(function (a) {\n    if (Array.isArray(a)) {\n      handlers = handlers.concat(a);\n    }\n    else {\n      handlers.push(a);\n    }\n  });\n\n  this.exceptionHandlers = this.exceptionHandlers || {};\n  handlers.forEach(function (handler) {\n    self.exceptionHandlers[handler.name] = handler;\n  });\n\n  this._hnames = Object.keys(self.exceptionHandlers);\n\n  if (!this.catchExceptions) {\n    this.catchExceptions = this._uncaughtException.bind(this);\n    process.on('uncaughtException', this.catchExceptions);\n  }\n};\n\n//\n// ### function unhandleExceptions ()\n// Removes any handlers to `uncaughtException` events\n// for the current process\n//\nLogger.prototype.unhandleExceptions = function () {\n  var self = this;\n\n  if (this.catchExceptions) {\n    Object.keys(this.exceptionHandlers).forEach(function (name) {\n      var handler = self.exceptionHandlers[name];\n      if (handler.close) {\n        handler.close();\n      }\n    });\n\n    this.exceptionHandlers = {};\n    Object.keys(this.transports).forEach(function (name) {\n      var transport = self.transports[name];\n      if (transport.handleExceptions) {\n        transport.handleExceptions = false;\n      }\n    })\n\n    process.removeListener('uncaughtException', this.catchExceptions);\n    this.catchExceptions = false;\n  }\n};\n\n//\n// ### function add (transport, [options])\n// #### @transport {Transport} Prototype of the Transport object to add.\n// #### @options {Object} **Optional** Options for the Transport to add.\n// #### @instance {Boolean} **Optional** Value indicating if `transport` is already instantiated.\n// Adds a transport of the specified type to this instance.\n//\nLogger.prototype.add = function (transport, options, created) {\n  var instance = created ? transport : (new (transport)(options));\n\n  if (!instance.name && !instance.log) {\n    throw new Error('Unknown transport with no log() method');\n  }\n  else if (this.transports[instance.name]) {\n    throw new Error('Transport already attached: ' + instance.name + \", assign a different name\");\n  }\n\n  this.transports[instance.name] = instance;\n  this._names = Object.keys(this.transports);\n\n  //\n  // Listen for the `error` event on the new Transport\n  //\n  instance._onError = this._onError.bind(this, instance)\n  if (!created) {\n    instance.on('error', instance._onError);\n  }\n\n  //\n  // If this transport has `handleExceptions` set to `true`\n  // and we are not already handling exceptions, do so.\n  //\n  if (instance.handleExceptions && !this.catchExceptions) {\n    this.handleExceptions();\n  }\n\n  return this;\n};\n\n//\n// ### function clear ()\n// Remove all transports from this instance\n//\nLogger.prototype.clear = function () {\n  Object.keys(this.transports).forEach(function (name) {\n    this.remove({ name: name });\n  }, this);\n};\n\n//\n// ### function remove (transport)\n// #### @transport {Transport|String} Transport or Name to remove.\n// Removes a transport of the specified type from this instance.\n//\nLogger.prototype.remove = function (transport) {\n  var name = typeof transport !== 'string'\n    ? transport.name || transport.prototype.name\n    : transport;\n\n  if (!this.transports[name]) {\n    throw new Error('Transport ' + name + ' not attached to this instance');\n  }\n\n  var instance = this.transports[name];\n  delete this.transports[name];\n  this._names = Object.keys(this.transports);\n\n  if (instance.close) {\n    instance.close();\n  }\n\n  if (instance._onError) {\n    instance.removeListener('error', instance._onError);\n  }\n  return this;\n};\n\n//\n// ### function startTimer ()\n// Returns an object corresponding to a specific timing. When done\n// is called the timer will finish and log the duration. e.g.:\n//\n//    timer = winston.startTimer()\n//    setTimeout(function(){\n//      timer.done(\"Logging message\");\n//    }, 1000);\n//\nLogger.prototype.startTimer = function () {\n  return new ProfileHandler(this);\n};\n\n//\n// ### function profile (id, [msg, meta, callback])\n// #### @id {string} Unique id of the profiler\n// #### @msg {string} **Optional** Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Tracks the time inbetween subsequent calls to this method\n// with the same `id` parameter. The second call to this method\n// will log the difference in milliseconds along with the message.\n//\nLogger.prototype.profile = function (id) {\n  var now = Date.now(), then, args,\n      msg, meta, callback;\n\n  if (this.profilers[id]) {\n    then = this.profilers[id];\n    delete this.profilers[id];\n\n    // Support variable arguments: msg, meta, callback\n    args     = Array.prototype.slice.call(arguments);\n    callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n    msg      = args.length === 2 ? args[1] : id;\n\n    // Set the duration property of the metadata\n    meta.durationMs = now - then;\n    return this.info(msg, meta, callback);\n  }\n  else {\n    this.profilers[id] = now;\n  }\n\n  return this;\n};\n\n//\n// ### function setLevels (target)\n// #### @target {Object} Target levels to use on this instance\n// Sets the `target` levels specified on this instance.\n//\nLogger.prototype.setLevels = function (target) {\n  return common.setLevels(this, this.levels, target);\n};\n\n//\n// ### function cli ()\n// Configures this instance to have the default\n// settings for command-line interfaces: no timestamp,\n// colors enabled, padded output, and additional levels.\n//\nLogger.prototype.cli = function () {\n  this.padLevels = true;\n  this.setLevels(config.cli.levels);\n  config.addColors(config.cli.colors);\n\n  if (this.transports.console) {\n    this.transports.console.colorize = this.transports.console.colorize || true;\n    this.transports.console.timestamp = this.transports.console.timestamp || false;\n  }\n\n  return this;\n};\n\n//\n// ### @private function _uncaughtException (err)\n// #### @err {Error} Error to handle\n// Logs all relevant information around the `err` and\n// exits the current process.\n//\nLogger.prototype._uncaughtException = function (err) {\n  var self = this,\n      responded = false,\n      info = exception.getAllInfo(err),\n      handlers = this._getExceptionHandlers(),\n      timeout,\n      doExit;\n\n  //\n  // Calculate if we should exit on this error\n  //\n  doExit = typeof this.exitOnError === 'function'\n    ? this.exitOnError(err)\n    : this.exitOnError;\n\n  function logAndWait(transport, next) {\n    transport.logException('uncaughtException: ' + (err.message || err), info, next, err);\n  }\n\n  function gracefulExit() {\n    if (doExit && !responded) {\n      //\n      // Remark: Currently ignoring any exceptions from transports\n      //         when catching uncaught exceptions.\n      //\n      clearTimeout(timeout);\n      responded = true;\n      process.exit(1);\n    }\n  }\n\n  if (!handlers || handlers.length === 0) {\n    return gracefulExit();\n  }\n\n  //\n  // Log to all transports and allow the operation to take\n  // only up to `3000ms`.\n  //\n  async.forEach(handlers, logAndWait, gracefulExit);\n  if (doExit) {\n    timeout = setTimeout(gracefulExit, 3000);\n  }\n};\n\n//\n// ### @private function _getExceptionHandlers ()\n// Returns the list of transports and exceptionHandlers\n// for this instance.\n//\nLogger.prototype._getExceptionHandlers = function () {\n  var self = this;\n\n  return this._hnames.map(function (name) {\n    return self.exceptionHandlers[name];\n  }).concat(this._names.map(function (name) {\n    return self.transports[name].handleExceptions && self.transports[name];\n  })).filter(Boolean);\n};\n\n//\n// ### @private function _onError (transport, err)\n// #### @transport {Object} Transport on which the error occured\n// #### @err {Error} Error that occurred on the transport\n// Bubbles the error, `err`, that occured on the specified `transport`\n// up from this instance if `emitErrs` has been set.\n//\nLogger.prototype._onError = function (transport, err) {\n  if (this.emitErrs) {\n    this.emit('error', err, transport);\n  }\n};\n\n//\n// ### @private ProfileHandler\n// Constructor function for the ProfileHandler instance used by\n// `Logger.prototype.startTimer`. When done is called the timer\n// will finish and log the duration.\n//\nfunction ProfileHandler(logger) {\n  this.logger = logger;\n  this.start = Date.now();\n}\n\n//\n// ### function done (msg)\n// Ends the current timer (i.e. ProfileHandler) instance and\n// logs the `msg` along with the duration since creation.\n//\nProfileHandler.prototype.done = function (msg) {\n  var args     = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' ? args.pop() : null,\n      meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n\n  meta.duration = (Date.now()) - this.start + 'ms';\n  return this.logger.info(msg, meta, callback);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston/lib/winston/logger.js\n// module id = 78\n// module chunks = 0","'use strict'\n\n// simple mutable assign\nfunction assign () {\n  const args = [].slice.call(arguments).filter(i => i)\n  const dest = args.shift()\n  args.forEach(src => {\n    Object.keys(src).forEach(key => {\n      dest[key] = src[key]\n    })\n  })\n\n  return dest\n}\n\nmodule.exports = assign\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/util/assign.js\n// module id = 79\n// module chunks = 0","var fs = require('./fs.js')\nvar constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n}\n\nfunction patchLchmod (fs) {\n  fs.lchmod = function (path, mode, callback) {\n    fs.open( path\n           , constants.O_WRONLY | constants.O_SYMLINK\n           , mode\n           , function (err, fd) {\n      if (err) {\n        if (callback) callback(err)\n        return\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function (err) {\n        fs.close(fd, function(err2) {\n          if (callback) callback(err || err2)\n        })\n      })\n    })\n  }\n\n  fs.lchmodSync = function (path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var threw = true\n    var ret\n    try {\n      ret = fs.fchmodSync(fd, mode)\n      threw = false\n    } finally {\n      if (threw) {\n        try {\n          fs.closeSync(fd)\n        } catch (er) {}\n      } else {\n        fs.closeSync(fd)\n      }\n    }\n    return ret\n  }\n}\n\nfunction patchLutimes (fs) {\n  if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n    fs.lutimes = function (path, at, mt, cb) {\n      fs.open(path, constants.O_SYMLINK, function (er, fd) {\n        if (er) {\n          if (cb) cb(er)\n          return\n        }\n        fs.futimes(fd, at, mt, function (er) {\n          fs.close(fd, function (er2) {\n            if (cb) cb(er || er2)\n          })\n        })\n      })\n    }\n\n    fs.lutimesSync = function (path, at, mt) {\n      var fd = fs.openSync(path, constants.O_SYMLINK)\n      var ret\n      var threw = true\n      try {\n        ret = fs.futimesSync(fd, at, mt)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n\n  } else {\n    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n    fs.lutimesSync = function () {}\n  }\n}\n\nfunction chmodFix (orig) {\n  if (!orig) return orig\n  return function (target, mode, cb) {\n    return orig.call(fs, target, mode, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chmodFixSync (orig) {\n  if (!orig) return orig\n  return function (target, mode) {\n    try {\n      return orig.call(fs, target, mode)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction chownFix (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid, cb) {\n    return orig.call(fs, target, uid, gid, function (er) {\n      if (chownErOk(er)) er = null\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction chownFixSync (orig) {\n  if (!orig) return orig\n  return function (target, uid, gid) {\n    try {\n      return orig.call(fs, target, uid, gid)\n    } catch (er) {\n      if (!chownErOk(er)) throw er\n    }\n  }\n}\n\n\nfunction statFix (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target, cb) {\n    return orig.call(fs, target, function (er, stats) {\n      if (!stats) return cb.apply(this, arguments)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      if (cb) cb.apply(this, arguments)\n    })\n  }\n}\n\nfunction statFixSync (orig) {\n  if (!orig) return orig\n  // Older versions of Node erroneously returned signed integers for\n  // uid + gid.\n  return function (target) {\n    var stats = orig.call(fs, target)\n    if (stats.uid < 0) stats.uid += 0x100000000\n    if (stats.gid < 0) stats.gid += 0x100000000\n    return stats;\n  }\n}\n\n// ENOSYS means that the fs doesn't support the op. Just ignore\n// that, because it doesn't matter.\n//\n// if there's no getuid, or if getuid() is something other\n// than 0, and the error is EINVAL or EPERM, then just ignore\n// it.\n//\n// This specific case is a silent failure in cp, install, tar,\n// and most other unix tools that manage permissions.\n//\n// When running as root, or if other types of errors are\n// encountered, then it's strict.\nfunction chownErOk (er) {\n  if (!er)\n    return true\n\n  if (er.code === \"ENOSYS\")\n    return true\n\n  var nonroot = !process.getuid || process.getuid() !== 0\n  if (nonroot) {\n    if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n      return true\n  }\n\n  return false\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/graceful-fs/polyfills.js\n// module id = 80\n// module chunks = 0","module.exports = require(\"constants\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"constants\"\n// module id = 81\n// module chunks = 0","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/graceful-fs/legacy-streams.js\n// module id = 82\n// module chunks = 0","module.exports = {\n  copy: require('./copy')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy/index.js\n// module id = 83\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst ncp = require('./ncp')\nconst mkdir = require('../mkdirs')\n\nfunction copy (src, dest, options, callback) {\n  if (typeof options === 'function' && !callback) {\n    callback = options\n    options = {}\n  } else if (typeof options === 'function' || options instanceof RegExp) {\n    options = {filter: options}\n  }\n  callback = callback || function () {}\n  options = options || {}\n\n  // Warn about using preserveTimestamps on 32-bit node:\n  if (options.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  // don't allow src and dest to be the same\n  const basePath = process.cwd()\n  const currentPath = path.resolve(basePath, src)\n  const targetPath = path.resolve(basePath, dest)\n  if (currentPath === targetPath) return callback(new Error('Source and destination must not be the same.'))\n\n  fs.lstat(src, (err, stats) => {\n    if (err) return callback(err)\n\n    let dir = null\n    if (stats.isDirectory()) {\n      const parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, dirExists => {\n      if (dirExists) return ncp(src, dest, options, callback)\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        ncp(src, dest, options, callback)\n      })\n    })\n  })\n}\n\nmodule.exports = copy\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy/copy.js\n// module id = 84\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst path = require('path')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/util/utimes.js\n// module id = 85\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copyFileSync = require('./copy-file-sync')\nconst mkdir = require('../mkdirs')\n\nfunction copySync (src, dest, options) {\n  if (typeof options === 'function' || options instanceof RegExp) {\n    options = {filter: options}\n  }\n\n  options = options || {}\n  options.recursive = !!options.recursive\n\n  // default to true for now\n  options.clobber = 'clobber' in options ? !!options.clobber : true\n  // overwrite falls back to clobber\n  options.overwrite = 'overwrite' in options ? !!options.overwrite : options.clobber\n  options.dereference = 'dereference' in options ? !!options.dereference : false\n  options.preserveTimestamps = 'preserveTimestamps' in options ? !!options.preserveTimestamps : false\n\n  options.filter = options.filter || function () { return true }\n\n  // Warn about using preserveTimestamps on 32-bit node:\n  if (options.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const stats = (options.recursive && !options.dereference) ? fs.lstatSync(src) : fs.statSync(src)\n  const destFolder = path.dirname(dest)\n  const destFolderExists = fs.existsSync(destFolder)\n  let performCopy = false\n\n  if (options.filter instanceof RegExp) {\n    console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function')\n    performCopy = options.filter.test(src)\n  } else if (typeof options.filter === 'function') performCopy = options.filter(src, dest)\n\n  if (stats.isFile() && performCopy) {\n    if (!destFolderExists) mkdir.mkdirsSync(destFolder)\n    copyFileSync(src, dest, {\n      overwrite: options.overwrite,\n      errorOnExist: options.errorOnExist,\n      preserveTimestamps: options.preserveTimestamps\n    })\n  } else if (stats.isDirectory() && performCopy) {\n    if (!fs.existsSync(dest)) mkdir.mkdirsSync(dest)\n    const contents = fs.readdirSync(src)\n    contents.forEach(content => {\n      const opts = options\n      opts.recursive = true\n      copySync(path.join(src, content), path.join(dest, content), opts)\n    })\n  } else if (options.recursive && stats.isSymbolicLink() && performCopy) {\n    const srcPath = fs.readlinkSync(src)\n    fs.symlinkSync(srcPath, dest)\n  }\n}\n\nmodule.exports = copySync\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy-sync/copy-sync.js\n// module id = 86\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\n\nconst BUF_LENGTH = 64 * 1024\nconst _buff = new Buffer(BUF_LENGTH)\n\nfunction copyFileSync (srcFile, destFile, options) {\n  const overwrite = options.overwrite\n  const errorOnExist = options.errorOnExist\n  const preserveTimestamps = options.preserveTimestamps\n\n  if (fs.existsSync(destFile)) {\n    if (overwrite) {\n      fs.unlinkSync(destFile)\n    } else if (errorOnExist) {\n      throw new Error(`${destFile} already exists`)\n    } else return\n  }\n\n  const fdr = fs.openSync(srcFile, 'r')\n  const stat = fs.fstatSync(fdr)\n  const fdw = fs.openSync(destFile, 'w', stat.mode)\n  let bytesRead = 1\n  let pos = 0\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (preserveTimestamps) {\n    fs.futimesSync(fdw, stat.atime, stat.mtime)\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nmodule.exports = copyFileSync\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/copy-sync/copy-file-sync.js\n// module id = 87\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if (isWindows && (er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        let time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n  options.rmdirSync(p, options)\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/remove/rimraf.js\n// module id = 88\n// module chunks = 0","'use strict'\n\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJsonSync = require('./output-json-sync')\njsonFile.outputJson = require('./output-json')\n// aliases\njsonFile.outputJSONSync = require('./output-json-sync')\njsonFile.outputJSON = require('./output-json')\n\nmodule.exports = jsonFile\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/json/index.js\n// module id = 89\n// module chunks = 0","'use strict'\n\n// most of this code was written by Andrew Kelley\n// licensed under the BSD license: see\n// https://github.com/andrewrk/node-mv/blob/master/package.json\n\n// this needs a cleanup\n\nconst fs = require('graceful-fs')\nconst ncp = require('../copy/ncp')\nconst path = require('path')\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirs\n\nfunction move (source, dest, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const shouldMkdirp = ('mkdirp' in options) ? options.mkdirp : true\n  const overwrite = options.overwrite || options.clobber || false\n\n  if (shouldMkdirp) {\n    mkdirs()\n  } else {\n    doRename()\n  }\n\n  function mkdirs () {\n    mkdirp(path.dirname(dest), err => {\n      if (err) return callback(err)\n      doRename()\n    })\n  }\n\n  function doRename () {\n    if (path.resolve(source) === path.resolve(dest)) {\n      setImmediate(callback)\n    } else if (overwrite) {\n      fs.rename(source, dest, err => {\n        if (!err) return callback()\n\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {\n          remove(dest, err => {\n            if (err) return callback(err)\n            options.overwrite = false // just overwriteed it, no need to do it again\n            move(source, dest, options, callback)\n          })\n          return\n        }\n\n        // weird Windows shit\n        if (err.code === 'EPERM') {\n          setTimeout(() => {\n            remove(dest, err => {\n              if (err) return callback(err)\n              options.overwrite = false\n              move(source, dest, options, callback)\n            })\n          }, 200)\n          return\n        }\n\n        if (err.code !== 'EXDEV') return callback(err)\n        moveAcrossDevice(source, dest, overwrite, callback)\n      })\n    } else {\n      fs.link(source, dest, err => {\n        if (err) {\n          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {\n            moveAcrossDevice(source, dest, overwrite, callback)\n            return\n          }\n          callback(err)\n          return\n        }\n        fs.unlink(source, callback)\n      })\n    }\n  }\n}\n\nfunction moveAcrossDevice (source, dest, overwrite, callback) {\n  fs.stat(source, (err, stat) => {\n    if (err) {\n      callback(err)\n      return\n    }\n\n    if (stat.isDirectory()) {\n      moveDirAcrossDevice(source, dest, overwrite, callback)\n    } else {\n      moveFileAcrossDevice(source, dest, overwrite, callback)\n    }\n  })\n}\n\nfunction moveFileAcrossDevice (source, dest, overwrite, callback) {\n  const flags = overwrite ? 'w' : 'wx'\n  const ins = fs.createReadStream(source)\n  const outs = fs.createWriteStream(dest, { flags })\n\n  ins.on('error', err => {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n\n    // may want to create a directory but `out` line above\n    // creates an empty file for us: See #108\n    // don't care about error here\n    fs.unlink(dest, () => {\n      // note: `err` here is from the input stream errror\n      if (err.code === 'EISDIR' || err.code === 'EPERM') {\n        moveDirAcrossDevice(source, dest, overwrite, callback)\n      } else {\n        callback(err)\n      }\n    })\n  })\n\n  outs.on('error', err => {\n    ins.destroy()\n    outs.destroy()\n    outs.removeListener('close', onClose)\n    callback(err)\n  })\n\n  outs.once('close', onClose)\n  ins.pipe(outs)\n\n  function onClose () {\n    fs.unlink(source, callback)\n  }\n}\n\nfunction moveDirAcrossDevice (source, dest, overwrite, callback) {\n  const options = {\n    overwrite: false\n  }\n\n  if (overwrite) {\n    remove(dest, err => {\n      if (err) return callback(err)\n      startNcp()\n    })\n  } else {\n    startNcp()\n  }\n\n  function startNcp () {\n    ncp(source, dest, options, err => {\n      if (err) return callback(err)\n      remove(source, callback)\n    })\n  }\n}\n\nmodule.exports = {\n  move\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/move/index.js\n// module id = 90\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirsSync\n\nfunction moveSync (src, dest, options) {\n  options = options || {}\n  const overwrite = options.overwrite || options.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return\n\n  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)\n\n  mkdirpSync(path.dirname(dest))\n  tryRenameSync()\n\n  function tryRenameSync () {\n    if (overwrite) {\n      try {\n        return fs.renameSync(src, dest)\n      } catch (err) {\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {\n          removeSync(dest)\n          options.overwrite = false // just overwriteed it, no need to do it again\n          return moveSync(src, dest, options)\n        }\n\n        if (err.code !== 'EXDEV') throw err\n        return moveSyncAcrossDevice(src, dest, overwrite)\n      }\n    } else {\n      try {\n        fs.linkSync(src, dest)\n        return fs.unlinkSync(src)\n      } catch (err) {\n        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {\n          return moveSyncAcrossDevice(src, dest, overwrite)\n        }\n        throw err\n      }\n    }\n  }\n}\n\nfunction moveSyncAcrossDevice (src, dest, overwrite) {\n  const stat = fs.statSync(src)\n\n  if (stat.isDirectory()) {\n    return moveDirSyncAcrossDevice(src, dest, overwrite)\n  } else {\n    return moveFileSyncAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveFileSyncAcrossDevice (src, dest, overwrite) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = new Buffer(BUF_LENGTH)\n\n  const flags = overwrite ? 'w' : 'wx'\n\n  const fdr = fs.openSync(src, 'r')\n  const stat = fs.fstatSync(fdr)\n  const fdw = fs.openSync(dest, flags, stat.mode)\n  let bytesRead = 1\n  let pos = 0\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n  return fs.unlinkSync(src)\n}\n\nfunction moveDirSyncAcrossDevice (src, dest, overwrite) {\n  const options = {\n    overwrite: false\n  }\n\n  if (overwrite) {\n    removeSync(dest)\n    tryCopySync()\n  } else {\n    tryCopySync()\n  }\n\n  function tryCopySync () {\n    copySync(src, dest, options)\n    return removeSync(src)\n  }\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  try {\n    return fs.statSync(src).isDirectory() &&\n           src !== dest &&\n           dest.indexOf(src) > -1 &&\n           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)\n  } catch (e) {\n    return false\n  }\n}\n\nmodule.exports = {\n  moveSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/move-sync/index.js\n// module id = 91\n// module chunks = 0","'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nfunction emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n}\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/empty/index.js\n// module id = 92\n// module chunks = 0","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/index.js\n// module id = 93\n// module chunks = 0","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.exists(file, fileExists => {\n    if (fileExists) return callback()\n    const dir = path.dirname(file)\n    fs.exists(dir, dirExists => {\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  if (fs.existsSync(file)) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile,\n  createFileSync,\n  // alias\n  ensureFile: createFile,\n  ensureFileSync: createFileSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/file.js\n// module id = 94\n// module chunks = 0","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  fs.exists(dstpath, destinationExists => {\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err, stat) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      fs.exists(dir, dirExists => {\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath, callback) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink,\n  createLinkSync,\n  // alias\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/link.js\n// module id = 95\n// module chunks = 0","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  fs.exists(dstpath, destinationExists => {\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        fs.exists(dir, dirExists => {\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink,\n  createSymlinkSync,\n  // alias\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/symlink.js\n// module id = 96\n// module chunks = 0","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err, stat) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return fs.exists(relativeToDst, exists => {\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err, stat) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/symlink-paths.js\n// module id = 97\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/ensure/symlink-type.js\n// module id = 98\n// module chunks = 0","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  fs.exists(dir, itDoes => {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, data, encoding) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync.apply(fs, arguments)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\nmodule.exports = {\n  outputFile,\n  outputFileSync\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/fs-extra/lib/output/index.js\n// module id = 99\n// module chunks = 0","(function() {\n  var Disposable, Emitter;\n\n  Disposable = require('./disposable');\n\n  module.exports = Emitter = (function() {\n    Emitter.exceptionHandlers = [];\n\n    Emitter.onEventHandlerException = function(exceptionHandler) {\n      if (this.exceptionHandlers.length === 0) {\n        this.dispatch = this.exceptionHandlingDispatch;\n      }\n      this.exceptionHandlers.push(exceptionHandler);\n      return new Disposable((function(_this) {\n        return function() {\n          _this.exceptionHandlers.splice(_this.exceptionHandlers.indexOf(exceptionHandler), 1);\n          if (_this.exceptionHandlers.length === 0) {\n            return _this.dispatch = _this.simpleDispatch;\n          }\n        };\n      })(this));\n    };\n\n    Emitter.simpleDispatch = function(handler, value) {\n      return handler(value);\n    };\n\n    Emitter.exceptionHandlingDispatch = function(handler, value) {\n      var exception, exceptionHandler, _i, _len, _ref, _results;\n      try {\n        return handler(value);\n      } catch (_error) {\n        exception = _error;\n        _ref = this.exceptionHandlers;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          exceptionHandler = _ref[_i];\n          _results.push(exceptionHandler(exception));\n        }\n        return _results;\n      }\n    };\n\n    Emitter.dispatch = Emitter.simpleDispatch;\n\n    Emitter.prototype.disposed = false;\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function Emitter() {\n      this.clear();\n    }\n\n    Emitter.prototype.clear = function() {\n      return this.handlersByEventName = {};\n    };\n\n    Emitter.prototype.dispose = function() {\n      this.handlersByEventName = null;\n      return this.disposed = true;\n    };\n\n\n    /*\n    Section: Event Subscription\n     */\n\n    Emitter.prototype.on = function(eventName, handler, unshift) {\n      var currentHandlers;\n      if (unshift == null) {\n        unshift = false;\n      }\n      if (this.disposed) {\n        throw new Error(\"Emitter has been disposed\");\n      }\n      if (typeof handler !== 'function') {\n        throw new Error(\"Handler must be a function\");\n      }\n      if (currentHandlers = this.handlersByEventName[eventName]) {\n        if (unshift) {\n          this.handlersByEventName[eventName] = [handler].concat(currentHandlers);\n        } else {\n          this.handlersByEventName[eventName] = currentHandlers.concat(handler);\n        }\n      } else {\n        this.handlersByEventName[eventName] = [handler];\n      }\n      return new Disposable(this.off.bind(this, eventName, handler));\n    };\n\n    Emitter.prototype.once = function(eventName, handler, unshift) {\n      var disposable, wrapped;\n      if (unshift == null) {\n        unshift = false;\n      }\n      wrapped = function(value) {\n        disposable.dispose();\n        return handler(value);\n      };\n      return disposable = this.on(eventName, wrapped, unshift);\n    };\n\n    Emitter.prototype.preempt = function(eventName, handler) {\n      return this.on(eventName, handler, true);\n    };\n\n    Emitter.prototype.off = function(eventName, handlerToRemove) {\n      var handler, newHandlers, oldHandlers, _i, _len;\n      if (this.disposed) {\n        return;\n      }\n      if (oldHandlers = this.handlersByEventName[eventName]) {\n        newHandlers = [];\n        for (_i = 0, _len = oldHandlers.length; _i < _len; _i++) {\n          handler = oldHandlers[_i];\n          if (handler !== handlerToRemove) {\n            newHandlers.push(handler);\n          }\n        }\n        if (newHandlers.length > 0) {\n          this.handlersByEventName[eventName] = newHandlers;\n        } else {\n          delete this.handlersByEventName[eventName];\n        }\n      }\n    };\n\n\n    /*\n    Section: Event Emission\n     */\n\n    Emitter.prototype.emit = function(eventName, value) {\n      var handler, handlers, _i, _len, _ref;\n      if (handlers = (_ref = this.handlersByEventName) != null ? _ref[eventName] : void 0) {\n        for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n          handler = handlers[_i];\n          this.constructor.dispatch(handler, value);\n        }\n      }\n    };\n\n    Emitter.prototype.getEventNames = function() {\n      return Object.keys(this.handlersByEventName);\n    };\n\n    Emitter.prototype.listenerCountForEventName = function(eventName) {\n      var _ref, _ref1;\n      return (_ref = (_ref1 = this.handlersByEventName[eventName]) != null ? _ref1.length : void 0) != null ? _ref : 0;\n    };\n\n    Emitter.prototype.getTotalListenerCount = function() {\n      var eventName, result, _i, _len, _ref;\n      result = 0;\n      _ref = Object.keys(this.handlersByEventName);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        eventName = _ref[_i];\n        result += this.handlersByEventName[eventName].length;\n      }\n      return result;\n    };\n\n    return Emitter;\n\n  })();\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/event-kit/lib/emitter.js\n// module id = 100\n// module chunks = 0","(function() {\n  var CompositeDisposable, Disposable, assertDisposable;\n\n  Disposable = null;\n\n  module.exports = CompositeDisposable = (function() {\n    CompositeDisposable.prototype.disposed = false;\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function CompositeDisposable() {\n      var disposable, _i, _len;\n      this.disposables = new Set;\n      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n        disposable = arguments[_i];\n        this.add(disposable);\n      }\n    }\n\n    CompositeDisposable.prototype.dispose = function() {\n      if (!this.disposed) {\n        this.disposed = true;\n        this.disposables.forEach(function(disposable) {\n          return disposable.dispose();\n        });\n        this.disposables = null;\n      }\n    };\n\n\n    /*\n    Section: Managing Disposables\n     */\n\n    CompositeDisposable.prototype.add = function() {\n      var disposable, _i, _len;\n      if (!this.disposed) {\n        for (_i = 0, _len = arguments.length; _i < _len; _i += 1) {\n          disposable = arguments[_i];\n          assertDisposable(disposable);\n          this.disposables.add(disposable);\n        }\n      }\n    };\n\n    CompositeDisposable.prototype.remove = function(disposable) {\n      if (!this.disposed) {\n        this.disposables[\"delete\"](disposable);\n      }\n    };\n\n    CompositeDisposable.prototype[\"delete\"] = function(disposable) {\n      this.remove(disposable);\n    };\n\n    CompositeDisposable.prototype.clear = function() {\n      if (!this.disposed) {\n        this.disposables.clear();\n      }\n    };\n\n    return CompositeDisposable;\n\n  })();\n\n  assertDisposable = function(disposable) {\n    if (Disposable == null) {\n      Disposable = require('./disposable');\n    }\n    if (!Disposable.isDisposable(disposable)) {\n      throw new TypeError('Arguments to CompositeDisposable.add must have a .dispose() method');\n    }\n  };\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/event-kit/lib/composite-disposable.js\n// module id = 101\n// module chunks = 0","import * as Fs from 'fs-extra'\nimport { Emitter, Disposable } from 'event-kit'\n\ninterface ICurrentFileTailState {\n  /** The current read position in the file. */\n  readonly position: number\n\n  /** The currently active watcher instance. */\n  readonly watcher: Fs.FSWatcher\n}\n\n/** Tail a file and read changes as they happen. */\nexport class Tailer {\n  public readonly path: string\n\n  private readonly emitter = new Emitter()\n\n  private state: ICurrentFileTailState | null = null\n\n  /** Create a new instance for tailing the given file. */\n  public constructor(path: string) {\n    this.path = path\n  }\n\n  /**\n   * Register a function to be called whenever new data is available to be read.\n   * The function will be given a read stream which has been created to read the\n   * new data.\n   */\n  public onDataAvailable(fn: (stream: Fs.ReadStream) => void): Disposable {\n    return this.emitter.on('data', fn)\n  }\n\n  /**\n   * Start tailing the file. This can only be called again after calling `stop`.\n   */\n  public start() {\n    if (this.state) {\n      throw new Error(\n        `Cannot start an already started Tailer for \"${this.path}\"!`\n      )\n    }\n\n    const watcher = Fs.watch(this.path, this.onWatchEvent)\n    this.state = { watcher, position: 0 }\n  }\n\n  private onWatchEvent = (event: string) => {\n    if (event !== 'change') {\n      return\n    }\n\n    if (!this.state) {\n      return\n    }\n\n    Fs.stat(this.path, (err, stats) => {\n      if (err) {\n        return\n      }\n\n      const state = this.state\n      if (!state) {\n        return\n      }\n\n      if (stats.size <= state.position) {\n        return\n      }\n\n      this.state = { ...state, position: stats.size }\n\n      this.readChunk(stats, state.position)\n    })\n  }\n\n  private readChunk(stats: Fs.Stats, position: number) {\n    const stream = Fs.createReadStream(this.path, {\n      start: position,\n      end: stats.size,\n    })\n\n    this.emitter.emit('data', stream)\n  }\n\n  /** Stop tailing the file. */\n  public stop() {\n    const state = this.state\n    if (state) {\n      state.watcher.close()\n      this.state = null\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/tailer.ts","// Copyright (C) 2011-2015 John Hewson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\nvar stream = require('stream'),\n    util = require('util'),\n    timers = require('timers');\n\n// convinience API\nmodule.exports = function(readStream, options) {\n  return module.exports.createStream(readStream, options);\n};\n\n// basic API\nmodule.exports.createStream = function(readStream, options) {\n  if (readStream) {\n    return createLineStream(readStream, options);\n  } else {\n    return new LineStream(options);\n  }\n};\n\n// deprecated API\nmodule.exports.createLineStream = function(readStream) {\n  console.log('WARNING: byline#createLineStream is deprecated and will be removed soon');\n  return createLineStream(readStream);\n};\n\nfunction createLineStream(readStream, options) {\n  if (!readStream) {\n    throw new Error('expected readStream');\n  }\n  if (!readStream.readable) {\n    throw new Error('readStream must be readable');\n  }\n  var ls = new LineStream(options);\n  readStream.pipe(ls);\n  return ls;\n}\n\n//\n// using the new node v0.10 \"streams2\" API\n//\n\nmodule.exports.LineStream = LineStream;\n\nfunction LineStream(options) {\n  stream.Transform.call(this, options);\n  options = options || {};\n\n  // use objectMode to stop the output from being buffered\n  // which re-concatanates the lines, just without newlines.\n  this._readableState.objectMode = true;\n  this._lineBuffer = [];\n  this._keepEmptyLines = options.keepEmptyLines || false;\n  this._lastChunkEndedWithCR = false;\n\n  // take the source's encoding if we don't have one\n  var self = this;\n  this.on('pipe', function(src) {\n    if (!self.encoding) {\n      // but we can't do this for old-style streams\n      if (src instanceof stream.Readable) {\n        self.encoding = src._readableState.encoding;\n      }\n    }\n  });\n}\nutil.inherits(LineStream, stream.Transform);\n\nLineStream.prototype._transform = function(chunk, encoding, done) {\n  // decode binary chunks as UTF-8\n  encoding = encoding || 'utf8';\n  \n  if (Buffer.isBuffer(chunk)) {\n    if (encoding == 'buffer') {\n      chunk = chunk.toString(); // utf8\n      encoding = 'utf8';\n    }\n    else {\n     chunk = chunk.toString(encoding);\n    }\n  }\n  this._chunkEncoding = encoding;\n  \n  // see: http://www.unicode.org/reports/tr18/#Line_Boundaries\n  var lines = chunk.split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/g);\n  \n  // don't split CRLF which spans chunks\n  if (this._lastChunkEndedWithCR && chunk[0] == '\\n') {\n    lines.shift();\n  }\n  \n  if (this._lineBuffer.length > 0) {\n    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];\n    lines.shift();\n  }\n\n  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\\r';\n  this._lineBuffer = this._lineBuffer.concat(lines);\n  this._pushBuffer(encoding, 1, done);\n};\n\nLineStream.prototype._pushBuffer = function(encoding, keep, done) {\n  // always buffer the last (possibly partial) line\n  while (this._lineBuffer.length > keep) {\n    var line = this._lineBuffer.shift();\n    // skip empty lines\n    if (this._keepEmptyLines || line.length > 0 ) {\n      if (!this.push(this._reencode(line, encoding))) {\n        // when the high-water mark is reached, defer pushes until the next tick\n        var self = this;\n        timers.setImmediate(function() {\n          self._pushBuffer(encoding, keep, done);\n        });\n        return;\n      }\n    }\n  }\n  done();\n};\n\nLineStream.prototype._flush = function(done) {\n  this._pushBuffer(this._chunkEncoding, 0, done);\n};\n\n// see Readable::push\nLineStream.prototype._reencode = function(line, chunkEncoding) {\n  if (this.encoding && this.encoding != chunkEncoding) {\n    return new Buffer(line, chunkEncoding).toString(this.encoding);\n  }\n  else if (this.encoding) {\n    // this should be the most common case, i.e. we're using an encoded source stream\n    return line;\n  }\n  else {\n    return new Buffer(line, chunkEncoding);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/byline/lib/byline.js\n// module id = 103\n// module chunks = 0","module.exports = require(\"timers\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"timers\"\n// module id = 104\n// module chunks = 0","'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar common = require('winston/lib/winston/common');\nvar Transport = require('winston').Transport;\nvar Stream = require('stream').Stream;\nvar os = require('os');\nvar winston = require('winston');\nvar zlib = require('zlib');\n\nvar weekday = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\n//\n// ### function DailyRotateFile (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the DailyRotateFile transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar DailyRotateFile = module.exports = function (options) {\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf(target /* , illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename ?\n      path.basename(options.filename) :\n      'winston.log';\n\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || {flags: 'a'};\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  } else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    var self = this;\n    this._stream.on('error', function (error) {\n      self.emit('error', error);\n    });\n\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  } else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json = options.json !== false;\n  this.colorize = options.colorize || false;\n  this.maxsize = options.maxsize || null;\n  this.logstash = options.logstash || null;\n  this.maxFiles = options.maxFiles || null;\n  this.label = options.label || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.showLevel = options.showLevel === undefined ? true : options.showLevel;\n  this.timestamp = options.timestamp === undefined ? true : options.timestamp;\n  this.datePattern = options.datePattern ? options.datePattern : '.yyyy-MM-dd';\n  this.depth = options.depth || null;\n  this.eol = options.eol || os.EOL;\n  this.maxRetries = options.maxRetries || 2;\n  this.prepend = options.prepend || false;\n  this.localTime = options.localTime || false;\n  this.zippedArchive = options.zippedArchive || false;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size = 0;\n  this._created = 0;\n  this._buffer = [];\n  this._draining = false;\n  this._failures = 0;\n  this._archive = false;\n\n  // Internal variable which will hold a record of all files\n  // belonging to this transport which are currently in the\n  // log directory in chronological order.\n  //\n  this._currentFiles = function () {\n    //\n    // Only proceed if maxsize is not configured for this transport.\n    if (!this.maxsize) {\n      try {\n        return fs.readdirSync(this.dirname).filter(function (file) {\n          return file.includes(this._basename);\n        }.bind(this)).map(function (file) {\n          return {\n            name: file,\n            time: fs.statSync(path.join(this.dirname, file)).mtime.getTime()\n          };\n        }.bind(this)).sort(function (a, b) {\n          return a.time - b.time;\n        }).map(function (v) {\n          return v.name;\n        });\n      } catch (e) {\n        // directory doesnt exist so there are no files. Do nothing.\n      }\n    }\n    return [];\n  }.bind(this)();\n\n  this._year = this._getTime('year');\n  this._month = this._getTime('month');\n  this._date = this._getTime('date');\n  this._hour = this._getTime('hour');\n  this._minute = this._getTime('minute');\n  this._weekday = weekday[this._getTime('day')];\n  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhM])\\1?/g;\n  var pad = function (val, len) {\n    val = String(val);\n    len = len || 2;\n    while (val.length < len) {\n      val = '0' + val;\n    }\n    return val;\n  };\n\n  this.getFormattedDate = function () {\n    // update the year, month, date... variables\n    this._year = this._getTime('year');\n    this._month = this._getTime('month');\n    this._date = this._getTime('date');\n    this._hour = this._getTime('hour');\n    this._minute = this._getTime('minute');\n    this._weekday = weekday[this._getTime('day')];\n\n    var flags = {\n      yy: String(this._year).slice(2),\n      yyyy: this._year,\n      M: this._month + 1,\n      MM: pad(this._month + 1),\n      d: this._date,\n      dd: pad(this._date),\n      H: this._hour,\n      HH: pad(this._hour),\n      m: this._minute,\n      mm: pad(this._minute),\n      ddd: this._weekday\n    };\n    return this.datePattern.replace(token, function ($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n    });\n  };\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(DailyRotateFile, Transport);\n\n/**\n * Define a getter so that `winston.transports.DailyRotateFile`\n * is available and thus backwards compatible.\n */\nwinston.transports.DailyRotateFile = DailyRotateFile;\n\n//\n// Expose the name of this Transport on the prototype\n//\nDailyRotateFile.prototype.name = 'dailyRotateFile';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nDailyRotateFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  var output = common.log({\n    level: level,\n    message: msg,\n    meta: meta,\n    json: this.json,\n    colorize: this.colorize,\n    logstash: this.logstash,\n    prettyPrint: this.prettyPrint,\n    timestamp: this.timestamp,\n    label: this.label,\n    stringify: this.stringify,\n    showLevel: this.showLevel,\n    depth: this.depth,\n    formatter: this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  }) + this.eol;\n\n  this._size += output.length;\n\n  if (this.filename) {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n      self._lazyDrain();\n    });\n  } else {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._lazyDrain();\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nDailyRotateFile.prototype._write = function (data, callback) {\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) {\n    return;\n  }\n\n  if (ret === false) {\n    return this._stream.once('drain', function () {\n      callback(null, true);\n    });\n  }\n  callback(null, true);\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nDailyRotateFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  // TODO when maxfilesize rotate occurs\n  var file = path.join(this.dirname, this._getFilename());\n  options = this.normalizeQuery(options);\n  var buff = '';\n  var results = [];\n  var row = 0;\n\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n    if (!callback) {\n      return;\n    }\n    return err.code === 'ENOENT' ? callback(null, results) : callback(err);\n  });\n\n  stream.on('data', function (data) {\n    data = (buff + data).split(/\\n+/);\n    var l = data.length - 1;\n    var i = 0;\n\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n      row++;\n    }\n\n    buff = data[l];\n  });\n\n  stream.on('close', function () {\n    if (buff) {\n      add(buff, true);\n    }\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n    if (callback) {\n      callback(null, results);\n    }\n  });\n\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) {\n        push(log);\n      }\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n\n  function push(log) {\n    if (options.rows && results.length >= options.rows) {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      return;\n    }\n\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n\n    results.push(log);\n  }\n\n  function check(log) {\n    if (!log) {\n      return;\n    }\n\n    if (typeof log !== 'object') {\n      return;\n    }\n\n    var time = new Date(log.timestamp);\n    if ((options.from && time < options.from) ||\n      (options.until && time > options.until)) {\n      return;\n    }\n\n    return true;\n  }\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nDailyRotateFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this._getFilename());\n  options = options || {};\n  var stream = new Stream();\n\n  var tail = {\n    file: file,\n    start: options.start\n  };\n\n  stream.destroy = common.tailFile(tail, function (err, line) {\n    if (err) {\n      return stream.emit('error', err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n\n  if (stream.resume) {\n    stream.resume();\n  }\n\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nDailyRotateFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  } else if (!this._stream || (this.maxsize && this._size >= this.maxsize) ||\n    this._filenameHasExpired()) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nDailyRotateFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n\n    this._stream.once('drain', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nDailyRotateFile.prototype.flush = function () {\n  var self = this;\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0];\n    var callback = item[1];\n\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nDailyRotateFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile(target) {\n    var fullname = path.join(self.dirname, target);\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush(size) {\n      if (self._stream) {\n        self._archive = self.zippedArchive ? self._stream.path : false;\n\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._stream.on('error', function (error) {\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        } else {\n          self.emit('error', error);\n        }\n      });\n\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      var logfile = self._archive;\n      self._archive = false;\n      if (logfile && fs.existsSync(String(logfile))) {\n        var gzip = zlib.createGzip();\n\n        var inp = fs.createReadStream(String(logfile));\n        var out = fs.createWriteStream(logfile + '.gz');\n\n        inp.pipe(gzip).pipe(out);\n        fs.unlinkSync(String(logfile));\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n\n        return createAndFlush(0);\n      }\n\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return checkFile(self._getFile(true));\n      }\n\n      if (self._filenameHasExpired()) {\n        self._year = self._getTime('year');\n        self._month = self._getTime('month');\n        self._date = self._getTime('date');\n        self._hour = self._getTime('hour');\n        self._minute = self._getTime('minute');\n        self._weekday = weekday[self._getTime('day')];\n        self._created = 0;\n        return checkFile(self._getFile());\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nDailyRotateFile.prototype._getFile = function (inc) {\n  var filename = this._getFilename();\n  var remaining;\n\n  if (inc) {\n    //\n    // Increment the number of files created or\n    // checked by this instance.\n    //\n    // Check for maxFiles option and delete file\n    if (this.maxFiles && (this._created >= (this.maxFiles - 1))) {\n      remaining = this._created - (this.maxFiles - 1);\n      if (remaining === 0) {\n        try {\n          fs.unlinkSync(path.join(this.dirname, filename));\n        } catch (e) {}\n      } else {\n        try {\n          fs.unlinkSync(path.join(this.dirname, filename + '.' + remaining));\n        } catch (e) {}\n      }\n    }\n\n    this._created += 1;\n  } else if (!this.maxsize) {\n    //\n    // If the filename does not exist in the _currentFiles array then add it.\n    if (this._currentFiles.indexOf(filename) === -1) {\n      this._currentFiles.push(filename);\n    }\n\n    // While the _currentFiles array contains more file names than is configured\n    // in maxFiles loop the _currentFiles array and delete the file found at el\n    // 0.\n    while (this.maxFiles && (this._currentFiles.length > this.maxFiles)) {\n      try {\n        fs.unlinkSync(path.join(this.dirname, this._currentFiles[0]));\n      } catch (e) {\n        // File isn't accessible, do nothing.\n      }\n\n      // Remove the filename that was just deleted from the _currentFiles array.\n      this._currentFiles = this._currentFiles.slice(1);\n    }\n  }\n\n  return this._created ? filename + '.' + this._created : filename;\n};\n\n//\n// ### @private function _getFilename ()\n// Returns the log filename depending on `this.prepend` option value\n//\nDailyRotateFile.prototype._getFilename = function () {\n  var formattedDate = this.getFormattedDate();\n\n  if (this.prepend) {\n    if (this.datePattern === '.yyyy-MM-dd') {\n      this.datePattern = 'yyyy-MM-dd.';\n      formattedDate = this.getFormattedDate();\n    }\n\n    return formattedDate + this._basename;\n  }\n\n  return this._basename + formattedDate;\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nDailyRotateFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};\n\n//\n// ### @private function _filenameHasExpired ()\n// Checks whether the current log file is valid\n// based on given datepattern\n//\nDailyRotateFile.prototype._filenameHasExpired = function () {\n  // searching for m is enough to say minute in date pattern\n  if (this.datePattern.match(/m/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date') || this._hour < this._getTime('hour') || this._minute < this._getTime('minute'));\n  } else if (this.datePattern.match(/H/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date') || this._hour < this._getTime('hour'));\n  } else if (this.datePattern.match(/d/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date'));\n  } else if (this.datePattern.match(/M/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month'));\n  } else if (this.datePattern.match(/yy/)) {\n    return (this._year < this._getTime('year'));\n  }\n  return false;\n};\n\n//\n// ### @private function _getTime ()\n// Get current date/time\n// based on localTime config\n//\nDailyRotateFile.prototype._getTime = function (timeType) {\n  var now = new Date();\n\n  if (this.localTime) {\n    if (timeType === 'year') {\n      return now.getFullYear();\n    } else if (timeType === 'month') {\n      return now.getMonth();\n    } else if (timeType === 'date') {\n      return now.getDate();\n    } else if (timeType === 'hour') {\n      return now.getHours();\n    } else if (timeType === 'minute') {\n      return now.getMinutes();\n    } else if (timeType === 'day') {\n      return now.getDay();\n    }\n  }\n  if (timeType === 'year') {\n    return now.getUTCFullYear();\n  } else if (timeType === 'month') {\n    return now.getUTCMonth();\n  } else if (timeType === 'date') {\n    return now.getUTCDate();\n  } else if (timeType === 'hour') {\n    return now.getUTCHours();\n  } else if (timeType === 'minute') {\n    return now.getUTCMinutes();\n  } else if (timeType === 'day') {\n    return now.getUTCDay();\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/winston-daily-rotate-file/index.js\n// module id = 105\n// module chunks = 0","import { formatError } from './format-error'\n\nexport function formatLogMessage(message: string, error?: Error) {\n  return error ? formatError(error, message) : message\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/format-log-message.ts","\n/**\n * Module dependencies.\n */\n\nvar sep = require('path').sep || '/';\n\n/**\n * Module exports.\n */\n\nmodule.exports = fileUriToPath;\n\n/**\n * File URI to Path function.\n *\n * @param {String} uri\n * @return {String} path\n * @api public\n */\n\nfunction fileUriToPath (uri) {\n  if ('string' != typeof uri ||\n      uri.length <= 7 ||\n      'file://' != uri.substring(0, 7)) {\n    throw new TypeError('must pass in a file:// URI to convert to a file path');\n  }\n\n  var rest = unescape(uri.substring(7));\n  var firstSlash = rest.indexOf('/');\n  var host = rest.substring(0, firstSlash);\n  var path = rest.substring(firstSlash + 1);\n\n  // 2.  Scheme Definition\n  // As a special case, <host> can be the string \"localhost\" or the empty\n  // string; this is interpreted as \"the machine from which the URL is\n  // being interpreted\".\n  if ('localhost' == host) host = '';\n\n  if (host) {\n    host = sep + sep + host;\n  }\n\n  // 3.2  Drives, drive letters, mount points, file system root\n  // Drive letters are mapped into the top of a file URI in various ways,\n  // depending on the implementation; some applications substitute\n  // vertical bar (\"|\") for the colon after the drive letter, yielding\n  // \"file:///c|/tmp/test.txt\".  In some cases, the colon is left\n  // unchanged, as in \"file:///c:/tmp/test.txt\".  In other cases, the\n  // colon is simply omitted, as in \"file:///c/tmp/test.txt\".\n  path = path.replace(/^(.+)\\|/, '$1:');\n\n  // for Windows, we need to invert the path separators from what a URI uses\n  if (sep == '\\\\') {\n    path = path.replace(/\\//g, '\\\\');\n  }\n\n  if (/^.+\\:/.test(path)) {\n    // has Windows drive at beginning of path\n  } else {\n    // unix path…\n    path = sep + path;\n  }\n\n  return host + path;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/file-uri-to-path/index.js\n// module id = 107\n// module chunks = 0","var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = null;\n  if (!fs) {\n    // Use SJAX if we are in the browser\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', path, false);\n    xhr.send(null);\n    var contents = null\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      contents = xhr.responseText\n    }\n  } else if (fs.existsSync(path)) {\n    // Otherwise, use the filesystem\n    contents = fs.readFileSync(path, 'utf8');\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = new Buffer(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map) {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame) {\n  if(frame.isNative()) {\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    if (line === 1 && !isInBrowser() && !frame.isEval()) {\n      column -= 62;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    frame = cloneCallSite(frame);\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  return error + stack.map(function(frame) {\n    return '\\n    at ' + wrapCallSite(frame);\n  }).join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      contents = fs.readFileSync(source, 'utf8');\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = require('module');\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map-support/source-map-support.js\n// module id = 108\n// module chunks = 0","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/source-map.js\n// module id = 109\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/base64.js\n// module id = 110\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/mapping-list.js\n// module id = 111\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/source-map-consumer.js\n// module id = 112\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/binary-search.js\n// module id = 113\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/quick-sort.js\n// module id = 114\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/source-map/lib/source-node.js\n// module id = 115\n// module chunks = 0","module.exports = require(\"module\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"module\"\n// module id = 116\n// module chunks = 0","import { BrowserWindow, ipcMain, Menu, app, dialog } from 'electron'\nimport { Emitter, Disposable } from 'event-kit'\nimport { registerWindowStateChangedEvents } from '../lib/window-state'\nimport { MenuEvent } from './menu'\nimport { URLActionType } from '../lib/parse-app-url'\nimport { ILaunchStats } from '../lib/stats'\nimport { menuFromElectronMenu } from '../models/app-menu'\nimport { now } from './now'\n\nlet windowStateKeeper: any | null = null\n\nexport class AppWindow {\n  private window: Electron.BrowserWindow\n  private emitter = new Emitter()\n\n  private _loadTime: number | null = null\n  private _rendererReadyTime: number | null = null\n\n  private minWidth = 960\n  private minHeight = 660\n\n  public constructor() {\n    if (!windowStateKeeper) {\n      // `electron-window-state` requires Electron's `screen` module, which can\n      // only be required after the app has emitted `ready`. So require it\n      // lazily.\n      windowStateKeeper = require('electron-window-state')\n    }\n\n    const savedWindowState = windowStateKeeper({\n      defaultWidth: this.minWidth,\n      defaultHeight: this.minHeight,\n    })\n\n    const windowOptions: Electron.BrowserWindowConstructorOptions = {\n      x: savedWindowState.x,\n      y: savedWindowState.y,\n      width: savedWindowState.width,\n      height: savedWindowState.height,\n      minWidth: this.minWidth,\n      minHeight: this.minHeight,\n      show: false,\n      // This fixes subpixel aliasing on Windows\n      // See https://github.com/atom/atom/commit/683bef5b9d133cb194b476938c77cc07fd05b972\n      backgroundColor: '#fff',\n      webPreferences: {\n        // Disable auxclick event\n        // See https://developers.google.com/web/updates/2016/10/auxclick\n        disableBlinkFeatures: 'Auxclick',\n        // Enable, among other things, the ResizeObserver\n        experimentalFeatures: true,\n      },\n    }\n\n    if (__DARWIN__) {\n      windowOptions.titleBarStyle = 'hidden'\n    } else if (__WIN32__) {\n      windowOptions.frame = false\n    }\n\n    this.window = new BrowserWindow(windowOptions)\n    savedWindowState.manage(this.window)\n\n    let quitting = false\n    app.on('before-quit', () => {\n      quitting = true\n    })\n\n    ipcMain.on('will-quit', (event: Electron.IpcMessageEvent) => {\n      quitting = true\n      event.returnValue = true\n    })\n\n    // on macOS, when the user closes the window we really just hide it. This\n    // lets us activate quickly and keep all our interesting logic in the\n    // renderer.\n    if (__DARWIN__) {\n      this.window.on('close', e => {\n        if (!quitting) {\n          e.preventDefault()\n          Menu.sendActionToFirstResponder('hide:')\n        }\n      })\n    }\n  }\n\n  public load() {\n    let startLoad = 0\n    // We only listen for the first of the loading events to avoid a bug in\n    // Electron/Chromium where they can sometimes fire more than once. See\n    // See\n    // https://github.com/desktop/desktop/pull/513#issuecomment-253028277. This\n    // shouldn't really matter as in production builds loading _should_ only\n    // happen once.\n    this.window.webContents.once('did-start-loading', () => {\n      this._rendererReadyTime = null\n      this._loadTime = null\n\n      startLoad = now()\n    })\n\n    this.window.webContents.once('did-finish-load', () => {\n      if (process.env.NODE_ENV === 'development') {\n        this.window.webContents.openDevTools()\n      }\n\n      this._loadTime = now() - startLoad\n\n      this.maybeEmitDidLoad()\n    })\n\n    this.window.webContents.on('did-finish-load', () => {\n      this.window.webContents.setVisualZoomLevelLimits(1, 1)\n    })\n\n    this.window.webContents.on('did-fail-load', () => {\n      this.window.webContents.openDevTools()\n      this.window.show()\n    })\n\n    // TODO: This should be scoped by the window.\n    ipcMain.once(\n      'renderer-ready',\n      (event: Electron.IpcMessageEvent, readyTime: number) => {\n        this._rendererReadyTime = readyTime\n\n        this.maybeEmitDidLoad()\n      }\n    )\n\n    this.window.on('focus', () => this.window.webContents.send('focus'))\n    this.window.on('blur', () => this.window.webContents.send('blur'))\n\n    registerWindowStateChangedEvents(this.window)\n\n    this.window.loadURL(`file://${__dirname}/index.html`)\n  }\n\n  /**\n   * Emit the `onDidLoad` event if the page has loaded and the renderer has\n   * signalled that it's ready.\n   */\n  private maybeEmitDidLoad() {\n    if (!this.rendererLoaded) {\n      return\n    }\n\n    this.emitter.emit('did-load', null)\n  }\n\n  /** Is the page loaded and has the renderer signalled it's ready? */\n  private get rendererLoaded(): boolean {\n    return !!this.loadTime && !!this.rendererReadyTime\n  }\n\n  public onClose(fn: () => void) {\n    this.window.on('closed', fn)\n  }\n\n  /**\n   * Register a function to call when the window is done loading. At that point\n   * the page has loaded and the renderer has signalled that it is ready.\n   */\n  public onDidLoad(fn: () => void): Disposable {\n    return this.emitter.on('did-load', fn)\n  }\n\n  public isMinimized() {\n    return this.window.isMinimized()\n  }\n\n  /** Is the window currently visible? */\n  public isVisible() {\n    return this.window.isVisible()\n  }\n\n  public restore() {\n    this.window.restore()\n  }\n\n  public focus() {\n    this.window.focus()\n  }\n\n  /** Show the window. */\n  public show() {\n    this.window.show()\n  }\n\n  /** Send the menu event to the renderer. */\n  public sendMenuEvent(name: MenuEvent) {\n    this.show()\n\n    this.window.webContents.send('menu-event', { name })\n  }\n\n  /** Send the URL action to the renderer. */\n  public sendURLAction(action: URLActionType) {\n    this.show()\n\n    this.window.webContents.send('url-action', { action })\n  }\n\n  /** Send the app launch timing stats to the renderer. */\n  public sendLaunchTimingStats(stats: ILaunchStats) {\n    this.window.webContents.send('launch-timing-stats', { stats })\n  }\n\n  /** Send the app menu to the renderer. */\n  public sendAppMenu() {\n    const appMenu = Menu.getApplicationMenu()\n    if (appMenu) {\n      const menu = menuFromElectronMenu(appMenu)\n      this.window.webContents.send('app-menu', { menu })\n    }\n  }\n\n  /** Send a certificate error to the renderer. */\n  public sendCertificateError(\n    certificate: Electron.Certificate,\n    error: string,\n    url: string\n  ) {\n    this.window.webContents.send('certificate-error', {\n      certificate,\n      error,\n      url,\n    })\n  }\n\n  public showCertificateTrustDialog(\n    certificate: Electron.Certificate,\n    message: string\n  ) {\n    // The Electron type definitions don't include `showCertificateTrustDialog`\n    // yet.\n    const d = dialog as any\n    d.showCertificateTrustDialog(\n      this.window,\n      { certificate, message },\n      () => {}\n    )\n  }\n\n  /** Report the exception to the renderer. */\n  public sendException(error: Error) {\n    // `Error` can't be JSONified so it doesn't transport nicely over IPC. So\n    // we'll just manually copy the properties we care about.\n    const friendlyError = {\n      stack: error.stack,\n      message: error.message,\n      name: error.name,\n    }\n    this.window.webContents.send('main-process-exception', friendlyError)\n  }\n\n  /**\n   * Get the time (in milliseconds) spent loading the page.\n   *\n   * This will be `null` until `onDidLoad` is called.\n   */\n  public get loadTime(): number | null {\n    return this._loadTime\n  }\n\n  /**\n   * Get the time (in milliseconds) elapsed from the renderer being loaded to it\n   * signaling it was ready.\n   *\n   * This will be `null` until `onDidLoad` is called.\n   */\n  public get rendererReadyTime(): number | null {\n    return this._rendererReadyTime\n  }\n\n  public destroy() {\n    this.window.destroy()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/app-window.ts","import { assertNever } from '../lib/fatal-error'\n\n/** A type union of all possible types of menu items */\nexport type MenuItem =\n  | IMenuItem\n  | ISubmenuItem\n  | ISeparatorMenuItem\n  | ICheckboxMenuItem\n  | IRadioMenuItem\n\n/** A type union of all types of menu items which can be executed */\nexport type ExecutableMenuItem = IMenuItem | ICheckboxMenuItem | IRadioMenuItem\n\n/**\n * Common properties for all item types except separator.\n * Only useful for declaring the types, not for consumption\n */\ninterface IBaseMenuItem {\n  readonly id: string\n  readonly enabled: boolean\n  readonly visible: boolean\n  readonly label: string\n}\n\n/**\n * An interface describing the properties of a 'normal'\n * menu item, i.e. a clickable item with a label but no\n * other special properties.\n */\nexport interface IMenuItem extends IBaseMenuItem {\n  readonly type: 'menuItem'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n}\n\n/**\n * An interface describing the properties of a\n * submenu menu item, i.e. an item which has an associated\n * submenu which can be expanded to reveal more menu\n * item. Not in itself executable, only a container.\n */\nexport interface ISubmenuItem extends IBaseMenuItem {\n  readonly type: 'submenuItem'\n  readonly menu: IMenu\n  readonly accessKey: string | null\n}\n\n/**\n * An interface describing the properties of a checkbox\n * menu item, i.e. an item which has an associated checked\n * state that can be toggled by executing it.\n */\nexport interface ICheckboxMenuItem extends IBaseMenuItem {\n  readonly type: 'checkbox'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n  readonly checked: boolean\n}\n\n/**\n * An interface describing the properties of a checkbox\n * menu item, i.e. an item which has an associated checked\n * state that is checked or unchecked based on application logic.\n *\n * The radio menu item is probably going to be used in a collection\n * of more radio menu items where the checked item is assigned\n * based on the last executed item in that group.\n */\nexport interface IRadioMenuItem extends IBaseMenuItem {\n  readonly type: 'radio'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n  readonly checked: boolean\n}\n\n/**\n * An interface describing the properties of a separator menu\n * item, i.e. an item which sole purpose is to create separation\n * between menu items. It has no other semantics and is purely\n * a visual hint.\n */\nexport interface ISeparatorMenuItem {\n  readonly id: string\n  readonly type: 'separator'\n  readonly visible: boolean\n}\n\n/**\n * An interface describing a menu.\n *\n * Holds collection of menu items and an indication of which item (if any)\n * in the menu is selected.\n */\nexport interface IMenu {\n  /**\n   * The id of this menu. For the root menu this will be undefined. For all\n   * other menus it will be the same as the id of the submenu item which\n   * owns this menu.\n   *\n   * +---------------------------+\n   * | Root menu (id: undefined) |\n   * +---------------------------+  +--------------------------+\n   * |  File (id File)           +--> File menu (id: File)     |\n   * +---------------------------+  +--------------------------+\n   * |  Edit (id Edit)           |  |  Open (id File.Open)     |\n   * +---------------------------+  +--------------------------+\n   *                                |  Close (id File.Close)   |\n   *                                +--------------------------+\n   */\n  readonly id?: string\n\n  /** Type identifier, used for type narrowing */\n  readonly type: 'menu'\n\n  /** A collection of zero or more menu items */\n  readonly items: ReadonlyArray<MenuItem>\n\n  /** The selected item in the menu or undefined if no item is selected */\n  readonly selectedItem?: MenuItem\n}\n\n/**\n * Gets the accelerator for a given menu item. If the menu item doesn't\n * have an explicitly defined accelerator but does have a defined role\n * the default accelerator (if any) for that particular role will be\n * returned.\n */\nfunction getAccelerator(menuItem: Electron.MenuItem): string | null {\n  if (menuItem.accelerator) {\n    return menuItem.accelerator as string\n  }\n\n  if (menuItem.role) {\n    const unsafeItem = menuItem as any\n    // https://github.com/electron/electron/blob/d4a8a64ba/lib/browser/api/menu-item.js#L62\n    const getDefaultRoleAccelerator = unsafeItem.getDefaultRoleAccelerator\n\n    if (typeof getDefaultRoleAccelerator === 'function') {\n      try {\n        const defaultRoleAccelerator = getDefaultRoleAccelerator.call(menuItem)\n        if (typeof defaultRoleAccelerator === 'string') {\n          return defaultRoleAccelerator\n        }\n      } catch (err) {\n        console.error('Could not retrieve default accelerator', err)\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Return the access key (applicable on Windows) from a menu item label.\n *\n * An access key is a letter or symbol preceded by an ampersand, i.e. in\n * the string \"Check for &updates\" the access key is 'u'. Access keys are\n * case insensitive and are unique per menu.\n */\nfunction getAccessKey(text: string): string | null {\n  const m = text.match(/&([^&])/)\n  return m ? m[1] : null\n}\n\n/**\n * Creates an instance of one of the types in the MenuItem type union based\n * on an Electron MenuItem instance. Will recurse through all sub menus and\n * convert each item.\n */\nfunction menuItemFromElectronMenuItem(menuItem: Electron.MenuItem): MenuItem {\n  // Our menu items always have ids and Electron.MenuItem takes on whatever\n  // properties was defined on the MenuItemOptions template used to create it\n  // but doesn't surface those in the type declaration.\n  const id: string | undefined = (menuItem as any).id\n  if (!id) {\n    throw new Error(`menuItem must specify id: ${menuItem.label}`)\n  }\n  const enabled = menuItem.enabled\n  const visible = menuItem.visible\n  const label = menuItem.label\n  const checked = menuItem.checked\n  const accelerator = getAccelerator(menuItem)\n  const accessKey = getAccessKey(menuItem.label)\n\n  // normal, separator, submenu, checkbox or radio.\n  switch (menuItem.type) {\n    case 'normal':\n      return {\n        id,\n        type: 'menuItem',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        accessKey,\n      }\n    case 'separator':\n      return { id, type: 'separator', visible }\n    case 'submenu':\n      const menu = menuFromElectronMenu(menuItem.submenu as Electron.Menu, id)\n      return {\n        id,\n        type: 'submenuItem',\n        label,\n        enabled,\n        visible,\n        menu,\n        accessKey,\n      }\n    case 'checkbox':\n      return {\n        id,\n        type: 'checkbox',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        checked,\n        accessKey,\n      }\n    case 'radio':\n      return {\n        id,\n        type: 'radio',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        checked,\n        accessKey,\n      }\n    default:\n      return assertNever(\n        menuItem.type,\n        `Unknown menu item type ${menuItem.type}`\n      )\n  }\n}\n/**\n * Creates a IMenu instance based on an Electron Menu instance.\n * Will recurse through all sub menus and convert each item using\n * menuItemFromElectronMenuItem.\n *\n * @param menu - The electron menu instance to convert into an\n *               IMenu instance\n *\n * @param id   - The id of the menu. Menus share their id with\n *               their parent item. The root menu id is undefined.\n */\nexport function menuFromElectronMenu(menu: Electron.Menu, id?: string): IMenu {\n  const items = menu.items.map(menuItemFromElectronMenuItem)\n\n  if (__DEV__) {\n    const seenAccessKeys = new Set<string>()\n\n    for (const item of items) {\n      if (item.visible) {\n        if (itemMayHaveAccessKey(item) && item.accessKey) {\n          if (seenAccessKeys.has(item.accessKey.toLowerCase())) {\n            throw new Error(\n              `Duplicate access key '${item.accessKey}' for item ${item.label}`\n            )\n          } else {\n            seenAccessKeys.add(item.accessKey.toLowerCase())\n          }\n        }\n      }\n    }\n  }\n\n  return { id, type: 'menu', items }\n}\n\n/**\n * Creates a map between MenuItem ids and MenuItems by recursing\n * through all items and all submenus.\n */\nfunction buildIdMap(\n  menu: IMenu,\n  map = new Map<string, MenuItem>()\n): Map<string, MenuItem> {\n  for (const item of menu.items) {\n    map.set(item.id, item)\n    if (item.type === 'submenuItem') {\n      buildIdMap(item.menu, map)\n    }\n  }\n\n  return map\n}\n\n/** Type guard which narrows a MenuItem to one which supports access keys */\nexport function itemMayHaveAccessKey(\n  item: MenuItem\n): item is IMenuItem | ISubmenuItem | ICheckboxMenuItem | IRadioMenuItem {\n  return (\n    item.type === 'menuItem' ||\n    item.type === 'submenuItem' ||\n    item.type === 'checkbox' ||\n    item.type === 'radio'\n  )\n}\n\n/**\n * Returns a value indicating whether or not the given menu item can be\n * selected. Selectable items are non-separator items which are enabled\n * and visible.\n */\nexport function itemIsSelectable(item: MenuItem) {\n  return item.type !== 'separator' && item.enabled && item.visible\n}\n\n/**\n * Attempts to locate a menu item matching the provided access key in a\n * given list of items. The access key comparison is case-insensitive.\n *\n * Note that this function does not take into account whether or not the\n * item is selectable, consumers of this function need to perform that\n * check themselves when applicable.\n */\nexport function findItemByAccessKey(\n  accessKey: string,\n  items: ReadonlyArray<MenuItem>\n): IMenuItem | ISubmenuItem | ICheckboxMenuItem | IRadioMenuItem | null {\n  const lowerCaseAccessKey = accessKey.toLowerCase()\n\n  for (const item of items) {\n    if (itemMayHaveAccessKey(item)) {\n      if (\n        item.accessKey &&\n        item.accessKey.toLowerCase() === lowerCaseAccessKey\n      ) {\n        return item\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * An immutable, transformable object which represents an application menu\n * and its current state (which menus are open, which items are selected).\n *\n * The primary use case for this is for rendering a custom application menu\n * on non-macOS systems. As such some interactions are explicitly made to\n * conform to Windows menu interactions. This includes things like selecting\n * the entire path up until the last selected item. This is necessary since,\n * on Windows, the parent menu item of a menu might not be selected even\n * though the submenu is. This is in order to allow for some delay when\n * moving the cursor from one menu pane to another.\n *\n * In general, however, this object is not platform specific and much of\n * the interactions are defined by the component using it.\n */\nexport class AppMenu {\n  /**\n   * A list of currently open menus with their selected items\n   * in the application menu.\n   *\n   * The semantics around what constitutes an open menu and how\n   * selection works is defined within this class class as well as\n   * in the individual components transforming that state.\n   */\n  public readonly openMenus: ReadonlyArray<IMenu>\n\n  /**\n   * The menu that this instance operates on, taken from an\n   * electron Menu instance and converted into an IMenu model\n   * by menuFromElectronMenu.\n   */\n  private readonly menu: IMenu\n\n  /**\n   * A map between menu item ids and their corresponding MenuItem\n   */\n  private readonly menuItemById: Map<string, MenuItem>\n\n  /**\n   * Static constructor for the initial creation of an AppMenu instance\n   * from an IMenu instance.\n   */\n  public static fromMenu(menu: IMenu): AppMenu {\n    const map = buildIdMap(menu)\n    const openMenus = [menu]\n\n    return new AppMenu(menu, openMenus, map)\n  }\n\n  // Used by static constructors and transformers.\n  private constructor(\n    menu: IMenu,\n    openMenus: ReadonlyArray<IMenu>,\n    menuItemById: Map<string, MenuItem>\n  ) {\n    this.menu = menu\n    this.openMenus = openMenus\n    this.menuItemById = menuItemById\n  }\n\n  /**\n   * Retrieves a menu item by its id.\n   */\n  public getItemById(id: string): MenuItem | undefined {\n    return this.menuItemById.get(id)\n  }\n\n  /**\n   * Merges the current AppMenu state with a new menu while\n   * attempting to maintain selection state.\n   */\n  public withMenu(newMenu: IMenu): AppMenu {\n    const newMap = buildIdMap(newMenu)\n    const newOpenMenus = new Array<IMenu>()\n\n    // Enumerate all currently open menus and attempt to recreate\n    // the openMenus array with the new menu instances\n    for (const openMenu of this.openMenus) {\n      let newOpenMenu: IMenu\n\n      // No id means it's the root menu, simple enough.\n      if (!openMenu.id) {\n        newOpenMenu = newMenu\n      } else {\n        // Menus share id with their parent item\n        const item = newMap.get(openMenu.id)\n\n        if (item && item.type === 'submenuItem') {\n          newOpenMenu = item.menu\n        } else {\n          // This particular menu can't be found in the new menu\n          // structure, we have no choice but to bail here and\n          // not open this particular menu.\n          break\n        }\n      }\n\n      let newSelectedItem: MenuItem | undefined = undefined\n\n      if (openMenu.selectedItem) {\n        newSelectedItem = newMap.get(openMenu.selectedItem.id)\n      }\n\n      newOpenMenus.push({\n        id: newOpenMenu.id,\n        type: 'menu',\n        items: newOpenMenu.items,\n        selectedItem: newSelectedItem,\n      })\n    }\n\n    return new AppMenu(newMenu, newOpenMenus, newMap)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the given submenu open.\n   *\n   * @param submenuItem     - The item which submenu should be appended\n   *                          to the list of open menus.\n   *\n   * @param selectFirstItem - A convenience item for automatically selecting\n   *                          the first item in the newly opened menu.\n   *\n   *                          If false the new menu is opened without a selection.\n   *\n   *                          Defaults to false.\n   */\n  public withOpenedMenu(\n    submenuItem: ISubmenuItem,\n    selectFirstItem = false\n  ): AppMenu {\n    const ourMenuItem = this.menuItemById.get(submenuItem.id)\n\n    if (!ourMenuItem) {\n      return this\n    }\n\n    if (ourMenuItem.type !== 'submenuItem') {\n      throw new Error(\n        `Attempt to open a submenu from an item of wrong type: ${ourMenuItem.type}`\n      )\n    }\n\n    const parentMenuIndex = this.openMenus.findIndex(\n      m => m.items.indexOf(ourMenuItem) !== -1\n    )\n\n    // The parent menu has apparently been closed in between, we could go and\n    // recreate it but it's probably not worth it.\n    if (parentMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, parentMenuIndex + 1)\n\n    if (selectFirstItem) {\n      // First selectable item.\n      const selectedItem = ourMenuItem.menu.items.find(itemIsSelectable)\n      newOpenMenus.push({ ...ourMenuItem.menu, selectedItem })\n    } else {\n      newOpenMenus.push(ourMenuItem.menu)\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the given menu removed from\n   * the list of open menus.\n   *\n   * @param menu - The menu which is to be closed, i.e. removed from the\n   *               list of open menus.\n   */\n  public withClosedMenu(menu: IMenu) {\n    // Root menu is always open and can't be closed\n    if (!menu.id) {\n      return this\n    }\n\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, ourMenuIndex)\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the list of open menus trimmed\n   * to not include any menus below the given menu.\n   *\n   * @param menu - The last menu which is to remain in the list of open\n   *               menus, all menus below this level will be pruned from\n   *               the list of open menus.\n   */\n  public withLastMenu(menu: IMenu) {\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, ourMenuIndex + 1)\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which the given menu item\n   * is selected.\n   *\n   * Additional semantics:\n   *\n   *  All menus leading up to the given menu item will have their\n   *  selection reset in such a fashion that the selection path\n   *  points to the given menu item.\n   *\n   *  All menus after the menu in which the given item resides\n   *  will have their selections cleared.\n   *\n   * @param menuItem - The menu item which is to be selected.\n   */\n  public withSelectedItem(menuItem: MenuItem) {\n    const ourMenuItem = this.menuItemById.get(menuItem.id)\n\n    // The item that someone is trying to select no longer\n    // exists, not much we can do about that.\n    if (!ourMenuItem) {\n      return this\n    }\n\n    const parentMenuIndex = this.openMenus.findIndex(\n      m => m.items.indexOf(ourMenuItem) !== -1\n    )\n\n    // The menu which the selected item belongs to is no longer open,\n    // not much we can do about that.\n    if (parentMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice()\n\n    const parentMenu = newOpenMenus[parentMenuIndex]\n\n    newOpenMenus[parentMenuIndex] = { ...parentMenu, selectedItem: ourMenuItem }\n\n    // All submenus below the active menu should have their selection cleared\n    for (let i = parentMenuIndex + 1; i < newOpenMenus.length; i++) {\n      newOpenMenus[i] = { ...newOpenMenus[i], selectedItem: undefined }\n    }\n\n    // Ensure that the path that lead us to the currently selected menu is\n    // selected. i.e. all menus above the currently active menu should have\n    // their selection reset to point to the currently active menu.\n    for (let i = parentMenuIndex - 1; i >= 0; i--) {\n      const menu = newOpenMenus[i]\n      const childMenu = newOpenMenus[i + 1]\n\n      const selectedItem = menu.items.find(\n        item => item.type === 'submenuItem' && item.id === childMenu.id\n      )\n\n      newOpenMenus[i] = { ...menu, selectedItem }\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which the given menu has had\n   * its selection state cleared.\n   *\n   * Additional semantics:\n   *\n   *  All menus leading up to the given menu item will have their\n   *  selection reset in such a fashion that the selection path\n   *  points to the given menu.\n   *\n   * @param menu - The menu which is to have its selection state\n   *               cleared.\n   */\n  public withDeselectedMenu(menu: IMenu) {\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    // The menu that someone is trying to deselect is no longer open\n    // so no need to worry about selection\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const ourMenu = this.openMenus[ourMenuIndex]\n    const newOpenMenus = this.openMenus.slice()\n\n    newOpenMenus[ourMenuIndex] = { ...ourMenu, selectedItem: undefined }\n\n    // Ensure that the path to the menu without an active selection is\n    // selected. i.e. all menus above should have their selection reset\n    // to point to the menu which no longer has an active selection.\n    for (let i = ourMenuIndex - 1; i >= 0; i--) {\n      const menu = newOpenMenus[i]\n      const childMenu = newOpenMenus[i + 1]\n\n      const selectedItem = menu.items.find(\n        item => item.type === 'submenuItem' && item.id === childMenu.id\n      )\n\n      newOpenMenus[i] = { ...menu, selectedItem }\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which all state\n   * is reset. Resetting means that only the root menu is open and\n   * all selection state is cleared.\n   */\n  public withReset() {\n    return new AppMenu(this.menu, [this.menu], this.menuItemById)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/models/app-menu.ts","'use strict';\n\nvar path = require('path');\nvar electron = require('electron');\nvar jsonfile = require('jsonfile');\nvar mkdirp = require('mkdirp');\nvar deepEqual = require('deep-equal');\n\nmodule.exports = function (options) {\n  var app = electron.app || electron.remote.app;\n  var screen = electron.screen || electron.remote.screen;\n  var state;\n  var winRef;\n  var stateChangeTimer;\n  var eventHandlingDelay = 100;\n  var config = Object.assign({\n    file: 'window-state.json',\n    path: app.getPath('userData'),\n    maximize: true,\n    fullScreen: true\n  }, options);\n  var fullStoreFileName = path.join(config.path, config.file);\n\n  function isNormal(win) {\n    return !win.isMaximized() && !win.isMinimized() && !win.isFullScreen();\n  }\n\n  function hasBounds() {\n    return state &&\n      Number.isInteger(state.x) &&\n      Number.isInteger(state.y) &&\n      Number.isInteger(state.width) && state.width > 0 &&\n      Number.isInteger(state.height) && state.height > 0;\n  }\n\n  function validateState() {\n    var isValid = state && (hasBounds() || state.isMaximized || state.isFullScreen);\n    if (!isValid) {\n      state = null;\n      return;\n    }\n\n    if (hasBounds() && state.displayBounds) {\n      // Check if the display where the window was last open is still available\n      var displayBounds = screen.getDisplayMatching(state).bounds;\n      var sameBounds = deepEqual(state.displayBounds, displayBounds, {strict: true});\n      if (!sameBounds) {\n        if (displayBounds.width < state.displayBounds.width) {\n          if (state.x > displayBounds.width) {\n            state.x = 0;\n          }\n\n          if (state.width > displayBounds.width) {\n            state.width = displayBounds.width;\n          }\n        }\n\n        if (displayBounds.height < state.displayBounds.height) {\n          if (state.y > displayBounds.height) {\n            state.y = 0;\n          }\n\n          if (state.height > displayBounds.height) {\n            state.height = displayBounds.height;\n          }\n        }\n      }\n    }\n  }\n\n  function updateState(win) {\n    win = win || winRef;\n    if (!win) {\n      return;\n    }\n    // don't throw an error when window was closed\n    try {\n      var winBounds = win.getBounds();\n      if (isNormal(win)) {\n        state.x = winBounds.x;\n        state.y = winBounds.y;\n        state.width = winBounds.width;\n        state.height = winBounds.height;\n      }\n      state.isMaximized = win.isMaximized();\n      state.isFullScreen = win.isFullScreen();\n      state.displayBounds = screen.getDisplayMatching(winBounds).bounds;\n    } catch (err) {}\n  }\n\n  function saveState(win) {\n    // Update window state only if it was provided\n    if (win) {\n      updateState(win);\n    }\n\n    // Save state\n    try {\n      mkdirp.sync(path.dirname(fullStoreFileName));\n      jsonfile.writeFileSync(fullStoreFileName, state);\n    } catch (err) {\n      // Don't care\n    }\n  }\n\n  function stateChangeHandler() {\n    // Handles both 'resize' and 'move'\n    clearTimeout(stateChangeTimer);\n    stateChangeTimer = setTimeout(updateState, eventHandlingDelay);\n  }\n\n  function closeHandler() {\n    updateState();\n  }\n\n  function closedHandler() {\n    // Unregister listeners and save state\n    unmanage();\n    saveState();\n  }\n\n  function manage(win) {\n    if (config.maximize && state.isMaximized) {\n      win.maximize();\n    }\n    if (config.fullScreen && state.isFullScreen) {\n      win.setFullScreen(true);\n    }\n    win.on('resize', stateChangeHandler);\n    win.on('move', stateChangeHandler);\n    win.on('close', closeHandler);\n    win.on('closed', closedHandler);\n    winRef = win;\n  }\n\n  function unmanage() {\n    if (winRef) {\n      winRef.removeListener('resize', stateChangeHandler);\n      winRef.removeListener('move', stateChangeHandler);\n      clearTimeout(stateChangeTimer);\n      winRef.removeListener('close', closeHandler);\n      winRef.removeListener('closed', closedHandler);\n      winRef = null;\n    }\n  }\n\n  // Load previous state\n  try {\n    state = jsonfile.readFileSync(fullStoreFileName);\n  } catch (err) {\n    // Don't care\n  }\n\n  // Check state validity\n  validateState();\n\n  // Set state fallback values\n  state = Object.assign({\n    width: config.defaultWidth || 800,\n    height: config.defaultHeight || 600\n  }, state);\n\n  return {\n    get x() { return state.x; },\n    get y() { return state.y; },\n    get width() { return state.width; },\n    get height() { return state.height; },\n    get isMaximized() { return state.isMaximized; },\n    get isFullScreen() { return state.isFullScreen; },\n    saveState: saveState,\n    unmanage: unmanage,\n    manage: manage\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/electron-window-state/index.js\n// module id = 119\n// module chunks = 0","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/mkdirp/index.js\n// module id = 120\n// module chunks = 0","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/deep-equal/index.js\n// module id = 121\n// module chunks = 0","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/deep-equal/lib/keys.js\n// module id = 122\n// module chunks = 0","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/node_modules/deep-equal/lib/is_arguments.js\n// module id = 123\n// module chunks = 0","import { Menu, ipcMain, shell, app } from 'electron'\nimport { ensureItemIds } from './ensure-item-ids'\nimport { MenuEvent } from './menu-event'\nimport { getLogDirectoryPath } from '../../lib/logging/get-log-path'\nimport { mkdirIfNeeded } from '../../lib/file-system'\n\nimport { log } from '../log'\nimport { openDirectorySafe } from '../shell'\n\nconst defaultEditorLabel = __DARWIN__\n  ? 'Open in External Editor'\n  : 'Open in external editor'\nconst defaultShellLabel = __DARWIN__\n  ? 'Open in Terminal'\n  : 'Open in Command Prompt'\n\nexport function buildDefaultMenu(\n  editorLabel: string = defaultEditorLabel,\n  shellLabel: string = defaultShellLabel\n): Electron.Menu {\n  const template = new Array<Electron.MenuItemConstructorOptions>()\n  const separator: Electron.MenuItemConstructorOptions = { type: 'separator' }\n\n  if (__DARWIN__) {\n    template.push({\n      label: 'GitHub Desktop',\n      submenu: [\n        {\n          label: 'About GitHub Desktop',\n          click: emit('show-about'),\n          id: 'about',\n        },\n        separator,\n        {\n          label: 'Preferences…',\n          id: 'preferences',\n          accelerator: 'CmdOrCtrl+,',\n          click: emit('show-preferences'),\n        },\n        separator,\n        {\n          label: 'Install Command Line Tool…',\n          id: 'install-cli',\n          click: emit('install-cli'),\n        },\n        separator,\n        {\n          role: 'services',\n          submenu: [],\n        },\n        separator,\n        { role: 'hide' },\n        { role: 'hideothers' },\n        { role: 'unhide' },\n        separator,\n        { role: 'quit' },\n      ],\n    })\n  }\n\n  const fileMenu: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'File' : '&File',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'New Repository…' : 'New &repository…',\n        id: 'new-repository',\n        click: emit('create-repository'),\n        accelerator: 'CmdOrCtrl+N',\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Add Local Repository…' : 'Add &local repository…',\n        id: 'add-local-repository',\n        accelerator: 'CmdOrCtrl+O',\n        click: emit('add-local-repository'),\n      },\n      {\n        label: __DARWIN__ ? 'Clone Repository…' : 'Clo&ne repository…',\n        id: 'clone-repository',\n        accelerator: 'CmdOrCtrl+Shift+O',\n        click: emit('clone-repository'),\n      },\n    ],\n  }\n\n  if (!__DARWIN__) {\n    const fileItems = fileMenu.submenu as Electron.MenuItemConstructorOptions[]\n\n    fileItems.push(\n      separator,\n      {\n        label: '&Options…',\n        id: 'preferences',\n        accelerator: 'CmdOrCtrl+,',\n        click: emit('show-preferences'),\n      },\n      separator,\n      { role: 'quit' }\n    )\n  }\n\n  template.push(fileMenu)\n\n  template.push({\n    label: __DARWIN__ ? 'Edit' : '&Edit',\n    submenu: [\n      { role: 'undo', label: __DARWIN__ ? 'Undo' : '&Undo' },\n      { role: 'redo', label: __DARWIN__ ? 'Redo' : '&Redo' },\n      separator,\n      { role: 'cut', label: __DARWIN__ ? 'Cut' : 'Cu&t' },\n      { role: 'copy', label: __DARWIN__ ? 'Copy' : '&Copy' },\n      { role: 'paste', label: __DARWIN__ ? 'Paste' : '&Paste' },\n      { role: 'selectall', label: __DARWIN__ ? 'Select All' : 'Select &all' },\n    ],\n  })\n\n  template.push({\n    label: __DARWIN__ ? 'View' : '&View',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'Show Changes' : '&Changes',\n        id: 'show-changes',\n        accelerator: 'CmdOrCtrl+1',\n        click: emit('select-changes'),\n      },\n      {\n        label: __DARWIN__ ? 'Show History' : '&History',\n        id: 'show-history',\n        accelerator: 'CmdOrCtrl+2',\n        click: emit('select-history'),\n      },\n      {\n        label: __DARWIN__ ? 'Show Repository List' : 'Repository &list',\n        id: 'show-repository-list',\n        accelerator: 'CmdOrCtrl+T',\n        click: emit('choose-repository'),\n      },\n      {\n        label: __DARWIN__ ? 'Show Branches List' : '&Branches list',\n        id: 'show-branches-list',\n        accelerator: 'CmdOrCtrl+B',\n        click: emit('show-branches'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Toggle Full Screen' : 'Toggle &full screen',\n        role: 'togglefullscreen',\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Reset Zoom' : 'Reset zoom',\n        accelerator: 'CmdOrCtrl+0',\n        click: zoom(ZoomDirection.Reset),\n      },\n      {\n        label: __DARWIN__ ? 'Zoom In' : 'Zoom in',\n        accelerator: 'CmdOrCtrl+=',\n        click: zoom(ZoomDirection.In),\n      },\n      {\n        label: __DARWIN__ ? 'Zoom Out' : 'Zoom out',\n        accelerator: 'CmdOrCtrl+-',\n        click: zoom(ZoomDirection.Out),\n      },\n      separator,\n      {\n        label: '&Reload',\n        id: 'reload-window',\n        // Ctrl+Alt is interpreted as AltGr on international keyboards and this\n        // can clash with other shortcuts. We should always use Ctrl+Shift for\n        // chorded shortcuts, but this menu item is not a user-facing feature\n        // so we are going to keep this one around and save Ctrl+Shift+R for\n        // a different shortcut in the future...\n        accelerator: 'CmdOrCtrl+Alt+R',\n        click(item: any, focusedWindow: Electron.BrowserWindow) {\n          if (focusedWindow) {\n            focusedWindow.reload()\n          }\n        },\n        visible: __RELEASE_CHANNEL__ === 'development',\n      },\n      {\n        id: 'show-devtools',\n        label: __DARWIN__\n          ? 'Toggle Developer Tools'\n          : '&Toggle developer tools',\n        accelerator: (() => {\n          return __DARWIN__ ? 'Alt+Command+I' : 'Ctrl+Shift+I'\n        })(),\n        click(item: any, focusedWindow: Electron.BrowserWindow) {\n          if (focusedWindow) {\n            focusedWindow.webContents.toggleDevTools()\n          }\n        },\n      },\n    ],\n  })\n\n  template.push({\n    label: __DARWIN__ ? 'Repository' : '&Repository',\n    id: 'repository',\n    submenu: [\n      {\n        id: 'push',\n        label: __DARWIN__ ? 'Push' : 'P&ush',\n        accelerator: 'CmdOrCtrl+P',\n        click: emit('push'),\n      },\n      {\n        id: 'pull',\n        label: __DARWIN__ ? 'Pull' : 'Pu&ll',\n        accelerator: 'CmdOrCtrl+Shift+P',\n        click: emit('pull'),\n      },\n      {\n        label: __DARWIN__ ? 'Remove' : '&Remove',\n        id: 'remove-repository',\n        click: emit('remove-repository'),\n      },\n      separator,\n      {\n        id: 'view-repository-on-github',\n        label: __DARWIN__ ? 'View on GitHub' : '&View on GitHub',\n        accelerator: 'CmdOrCtrl+Shift+G',\n        click: emit('view-repository-on-github'),\n      },\n      {\n        label: shellLabel,\n        id: 'open-in-shell',\n        accelerator: 'Ctrl+`',\n        click: emit('open-in-shell'),\n      },\n      {\n        label: __DARWIN__ ? 'Show in Finder' : 'Show in E&xplorer',\n        id: 'open-working-directory',\n        accelerator: 'CmdOrCtrl+Shift+F',\n        click: emit('open-working-directory'),\n      },\n      {\n        label: editorLabel,\n        id: 'open-external-editor',\n        accelerator: 'CmdOrCtrl+Shift+A',\n        click: emit('open-external-editor'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Repository Settings…' : 'Repository &settings…',\n        id: 'show-repository-settings',\n        click: emit('show-repository-settings'),\n      },\n    ],\n  })\n\n  template.push({\n    label: __DARWIN__ ? 'Branch' : '&Branch',\n    id: 'branch',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'New Branch…' : 'New &branch…',\n        id: 'create-branch',\n        accelerator: 'CmdOrCtrl+Shift+N',\n        click: emit('create-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Rename…' : '&Rename…',\n        id: 'rename-branch',\n        click: emit('rename-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Delete…' : '&Delete…',\n        id: 'delete-branch',\n        click: emit('delete-branch'),\n      },\n      separator,\n      {\n        label: __DARWIN__\n          ? 'Update From Default Branch'\n          : '&Update from default branch',\n        id: 'update-branch',\n        click: emit('update-branch'),\n      },\n      {\n        label: __DARWIN__\n          ? 'Merge Into Current Branch…'\n          : '&Merge into current branch…',\n        id: 'merge-branch',\n        click: emit('merge-branch'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Compare on GitHub' : '&Compare on GitHub',\n        id: 'compare-branch',\n        accelerator: 'CmdOrCtrl+Shift+C',\n        click: emit('compare-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Create Pull Request' : 'Create &pull request',\n        id: 'create-pull-request',\n        accelerator: 'CmdOrCtrl+R',\n        click: emit('create-pull-request'),\n      },\n    ],\n  })\n\n  if (__DARWIN__) {\n    template.push({\n      role: 'window',\n      submenu: [\n        { role: 'minimize' },\n        { role: 'zoom' },\n        { role: 'close' },\n        separator,\n        { role: 'front' },\n      ],\n    })\n  }\n\n  const submitIssueItem: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Report Issue…' : 'Report issue…',\n    click() {\n      shell.openExternal('https://github.com/desktop/desktop/issues/new')\n    },\n  }\n\n  const contactSupportItem: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Contact GitHub Support…' : '&Contact GitHub support…',\n    click() {\n      shell.openExternal(\n        `https://github.com/contact?from_desktop_app=1&app_version=${app.getVersion()}`\n      )\n    },\n  }\n\n  const showUserGuides: Electron.MenuItemConstructorOptions = {\n    label: 'Show User Guides',\n    click() {\n      shell.openExternal('https://help.github.com/desktop/guides/')\n    },\n  }\n\n  const showLogsItem: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Show Logs in Finder' : 'S&how logs in Explorer',\n    click() {\n      const logPath = getLogDirectoryPath()\n      mkdirIfNeeded(logPath)\n        .then(() => {\n          openDirectorySafe(logPath)\n        })\n        .catch(err => {\n          log('error', err.message)\n        })\n    },\n  }\n\n  const helpItems = [\n    submitIssueItem,\n    contactSupportItem,\n    showUserGuides,\n    showLogsItem,\n  ]\n\n  if (__DEV__) {\n    helpItems.push(\n      separator,\n      {\n        label: 'Crash main process…',\n        click() {\n          throw new Error('Boomtown!')\n        },\n      },\n      {\n        label: 'Crash renderer process…',\n        click: emit('boomtown'),\n      }\n    )\n  }\n\n  if (__DARWIN__) {\n    template.push({\n      role: 'help',\n      submenu: helpItems,\n    })\n  } else {\n    template.push({\n      label: '&Help',\n      submenu: [\n        ...helpItems,\n        separator,\n        {\n          label: '&About GitHub Desktop',\n          click: emit('show-about'),\n          id: 'about',\n        },\n      ],\n    })\n  }\n\n  ensureItemIds(template)\n\n  return Menu.buildFromTemplate(template)\n}\n\ntype ClickHandler = (\n  menuItem: Electron.MenuItem,\n  browserWindow: Electron.BrowserWindow,\n  event: Electron.Event\n) => void\n\n/**\n * Utility function returning a Click event handler which, when invoked, emits\n * the provided menu event over IPC.\n */\nfunction emit(name: MenuEvent): ClickHandler {\n  return (menuItem, window) => {\n    if (window) {\n      window.webContents.send('menu-event', { name })\n    } else {\n      ipcMain.emit('menu-event', { name })\n    }\n  }\n}\n\nenum ZoomDirection {\n  Reset,\n  In,\n  Out,\n}\n\n/** The zoom steps that we support, these factors must sorted */\nconst ZoomInFactors = [1, 1.1, 1.25, 1.5, 1.75, 2]\nconst ZoomOutFactors = ZoomInFactors.slice().reverse()\n\n/**\n * Returns the element in the array that's closest to the value parameter. Note\n * that this function will throw if passed an empty array.\n */\nfunction findClosestValue(arr: Array<number>, value: number) {\n  return arr.reduce((previous, current) => {\n    return Math.abs(current - value) < Math.abs(previous - value)\n      ? current\n      : previous\n  })\n}\n\n/**\n * Figure out the next zoom level for the given direction and alert the renderer\n * about a change in zoom factor if necessary.\n */\nfunction zoom(direction: ZoomDirection): ClickHandler {\n  return (menuItem, window) => {\n    if (!window) {\n      return\n    }\n\n    const { webContents } = window\n\n    if (direction === ZoomDirection.Reset) {\n      webContents.setZoomFactor(1)\n      webContents.send('zoom-factor-changed', 1)\n    } else {\n      webContents.getZoomFactor(rawZoom => {\n        const zoomFactors =\n          direction === ZoomDirection.In ? ZoomInFactors : ZoomOutFactors\n\n        // So the values that we get from getZoomFactor are floating point\n        // precision numbers from chromium that don't always round nicely so\n        // we'll have to do a little trick to figure out which of our supported\n        // zoom factors the value is referring to.\n        const currentZoom = findClosestValue(zoomFactors, rawZoom)\n\n        const nextZoomLevel = zoomFactors.find(\n          f =>\n            direction === ZoomDirection.In ? f > currentZoom : f < currentZoom\n        )\n\n        // If we couldn't find a zoom level (likely due to manual manipulation\n        // of the zoom factor in devtools) we'll just snap to the closest valid\n        // factor we've got.\n        const newZoom =\n          nextZoomLevel === undefined ? currentZoom : nextZoomLevel\n\n        webContents.setZoomFactor(newZoom)\n        webContents.send('zoom-factor-changed', newZoom)\n      })\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/menu/build-default-menu.ts","/** Find the menu item with the given ID. */\nexport function findMenuItemByID(\n  menu: Electron.Menu,\n  id: string\n): Electron.MenuItem | null {\n  const items = menu.items\n  for (const item of items) {\n    // The electron type definition doesn't include the `id` field :(\n    if ((item as any).id === id) {\n      return item\n    }\n\n    // We're assuming we're working with an already created menu.\n    const submenu = item.submenu as Electron.Menu\n    if (submenu) {\n      const found = findMenuItemByID(submenu, id)\n      if (found) {\n        return found\n      }\n    }\n  }\n\n  return null\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/menu/find-menu-item.ts","import { Menu } from 'electron'\n\n/**\n * Update the menu to disable all non-essential menu items.\n *\n * Used when the app has detected a non-recoverable error and\n * the ui process has been terminated. Since most of the app\n * menu items require the ui process to work we'll have to\n * disable them.\n */\nexport function setCrashMenu() {\n  const menu = Menu.getApplicationMenu()\n\n  if (!menu) {\n    return\n  }\n\n  for (const topLevelItem of menu.items) {\n    disable(topLevelItem)\n  }\n}\n\nfunction disable(item: Electron.MenuItem) {\n  let anyEnabled = false\n\n  if (item.submenu instanceof Menu) {\n    for (const submenuItem of item.submenu.items) {\n      if (disable(submenuItem)) {\n        anyEnabled = true\n      }\n    }\n  }\n\n  if (anyEnabled || item.role) {\n    return true\n  }\n\n  const id = (item as any).id\n\n  if (id === 'show-devtools' || id === 'reload-window') {\n    return true\n  }\n\n  item.enabled = false\n  return false\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/menu/crash-menu.ts","/* tslint:disable:no-sync-functions */\n\nimport * as ChildProcess from 'child_process'\nimport * as os from 'os'\nimport * as Path from 'path'\n\ntype IndexLookup = {\n  [propName: string]: string\n}\n\n/**\n * The names of any env vars that we shouldn't copy from the shell environment.\n */\nconst BlacklistedNames = new Set(['LOCAL_GIT_DIRECTORY'])\n\n/**\n * Inspect whether the current process needs to be patched to get important\n * environment variables for Desktop to work and integrate with other tools\n * the user may invoke as part of their workflow.\n *\n * This is only applied to macOS installations due to how the application\n * is launched.\n *\n * @param process The process to inspect.\n */\nexport function shellNeedsPatching(process: NodeJS.Process): boolean {\n  return __DARWIN__ && !process.env.PWD\n}\n\ntype ShellResult = {\n  stdout: string\n  error: Error | null\n}\n\n/**\n * Gets a dump of the user's configured shell environment.\n *\n * @returns the output of the `env` command or `null` if there was an error.\n */\nasync function getRawShellEnv(): Promise<string | null> {\n  const shell = getUserShell()\n\n  const promise = new Promise<ShellResult>(resolve => {\n    let child: ChildProcess.ChildProcess | null = null\n    let error: Error | null = null\n    let stdout = ''\n    let done = false\n\n    // ensure we clean up eventually, in case things go bad\n    const cleanup = () => {\n      if (!done && child) {\n        child.kill()\n        done = true\n      }\n    }\n    process.once('exit', cleanup)\n    setTimeout(() => {\n      cleanup()\n    }, 5000)\n\n    const options = {\n      detached: true,\n      stdio: ['ignore', 'pipe', process.stderr],\n    }\n\n    child = ChildProcess.spawn(shell, ['-ilc', 'command env'], options)\n\n    const buffers: Array<Buffer> = []\n\n    child.on('error', (e: Error) => {\n      done = true\n      error = e\n    })\n\n    child.stdout.on('data', (data: Buffer) => {\n      buffers.push(data)\n    })\n\n    child.on('close', (code: number, signal) => {\n      done = true\n      process.removeListener('exit', cleanup)\n      if (buffers.length) {\n        stdout = Buffer.concat(buffers).toString('utf8')\n      }\n\n      resolve({ stdout, error })\n    })\n  })\n\n  const { stdout, error } = await promise\n\n  if (error) {\n    // just swallow the error and move on with everything\n    return null\n  }\n\n  return stdout\n}\n\nfunction getUserShell() {\n  if (process.env.SHELL) {\n    return process.env.SHELL\n  }\n\n  return '/bin/bash'\n}\n\n/**\n * Get the environment variables from the user's current shell and update the\n * current environment.\n *\n * @param updateEnvironment a callback to fire if a valid environment is found\n */\nasync function getEnvironmentFromShell(\n  updateEnvironment: (env: IndexLookup) => void\n): Promise<void> {\n  if (__WIN32__) {\n    return\n  }\n\n  const shellEnvText = await getRawShellEnv()\n  if (!shellEnvText) {\n    return\n  }\n\n  const env: IndexLookup = {}\n\n  for (const line of shellEnvText.split(os.EOL)) {\n    if (line.includes('=')) {\n      const components = line.split('=')\n      if (components.length === 2) {\n        env[components[0]] = components[1]\n      } else {\n        const k = components.shift()\n        const v = components.join('=')\n        if (k) {\n          env[k] = v\n        }\n      }\n    }\n  }\n\n  updateEnvironment(env)\n}\n\n/**\n * Apply new environment variables to the current process, ignoring\n * Node-specific environment variables which need to be preserved.\n *\n * @param env The new environment variables from the user's shell.\n */\nfunction mergeEnvironmentVariables(env: IndexLookup) {\n  for (const key in env) {\n    if (BlacklistedNames.has(key)) {\n      continue\n    }\n\n    process.env[key] = env[key]\n  }\n}\n\n/**\n * Update the current process's environment variables using environment\n * variables from the user's shell, if they can be retrieved successfully.\n */\nexport function updateEnvironmentForProcess(): Promise<void> {\n  return getEnvironmentFromShell(mergeEnvironmentVariables)\n}\n\nconst chcpOutputRegex = /: (\\d{1,}).*/\n\n/**\n * Resolve the active code page from the Windows console. It doesn't support\n * Unicode natively, which is why we have to ask it.\n *\n * Code Page 437 is the character set associated with the original IBM PC, and\n * Code Page 65001 represents UTF-8 character set.\n */\nexport function getActiveCodePage(): Promise<number | null> {\n  if (!__WIN32__) {\n    return Promise.resolve(null)\n  }\n\n  return new Promise<number | null>((resolve, reject) => {\n    const windir = process.env.windir || 'C:\\\\Windows'\n    const path = Path.join(windir, 'System32', 'chcp.com')\n\n    const child = ChildProcess.spawn(path)\n\n    const buffers: Array<Buffer> = []\n    let errorThrown = false\n\n    child.on('error', error => {\n      log.error('unable to resolve active code page', error)\n      errorThrown = true\n    })\n\n    child.stdout.on('data', (data: Buffer) => {\n      buffers.push(data)\n    })\n\n    child.on('close', (code: number, signal) => {\n      if (errorThrown) {\n        resolve(null)\n        return\n      }\n\n      const output = Buffer.concat(buffers).toString('utf8')\n      const result = chcpOutputRegex.exec(output)\n      if (result) {\n        const value = result[1]\n        const parsedInt = parseInt(value, 10)\n        if (isNaN(parsedInt)) {\n          resolve(null)\n        } else {\n          resolve(parsedInt)\n        }\n      } else {\n        log.debug(`regex did not match output: '${output}'`)\n        resolve(null)\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/shell.ts","import * as URL from 'url'\nimport { testForInvalidChars } from './sanitize-branch'\n\nexport interface IOAuthAction {\n  readonly name: 'oauth'\n  readonly code: string\n}\n\nexport interface IOpenRepositoryFromURLAction {\n  readonly name: 'open-repository-from-url'\n\n  /** the remote repository location associated with the \"Open in Desktop\" action */\n  readonly url: string\n\n  /** the optional branch name which should be checked out. use the default branch otherwise. */\n  readonly branch?: string\n\n  /** the pull request number, if pull request originates from a fork of the repository */\n  readonly pr?: string\n\n  /** the file to open after cloning the repository */\n  readonly filepath?: string\n}\n\nexport interface IOpenRepositoryFromPathAction {\n  readonly name: 'open-repository-from-path'\n\n  /** The local path to open. */\n  readonly path: string\n}\n\nexport interface IUnknownAction {\n  readonly name: 'unknown'\n  readonly url: string\n}\n\nexport type URLActionType =\n  | IOAuthAction\n  | IOpenRepositoryFromURLAction\n  | IOpenRepositoryFromPathAction\n  | IUnknownAction\n\nexport function parseAppURL(url: string): URLActionType {\n  const parsedURL = URL.parse(url, true)\n  const hostname = parsedURL.hostname\n  const unknown: IUnknownAction = { name: 'unknown', url }\n  if (!hostname) {\n    return unknown\n  }\n\n  const actionName = hostname.toLowerCase()\n  if (actionName === 'oauth') {\n    return { name: 'oauth', code: parsedURL.query.code }\n  }\n\n  // we require something resembling a URL first\n  // - bail out if it's not defined\n  // - bail out if you only have `/`\n  const pathName = parsedURL.pathname\n  if (!pathName || pathName.length <= 1) {\n    return unknown\n  }\n\n  // Trim the trailing / from the URL\n  const parsedPath = pathName.substr(1)\n\n  if (actionName === 'openrepo') {\n    const probablyAURL = parsedPath\n\n    // suffix the remote URL with `.git`, for backwards compatibility\n    const url = `${probablyAURL}.git`\n\n    const queryString = parsedURL.query\n\n    const pr = queryString.pr\n    const branch = queryString.branch\n    const filepath = queryString.filepath\n\n    if (pr) {\n      // if anything other than a number is used for the PR value, exit\n      if (!/^\\d+$/.test(pr)) {\n        return unknown\n      }\n\n      // we also expect the branch for a forked PR to be a given ref format\n      if (!/^pr\\/\\d+$/.test(branch)) {\n        return unknown\n      }\n    }\n\n    if (branch) {\n      if (testForInvalidChars(branch)) {\n        return unknown\n      }\n    }\n\n    return {\n      name: 'open-repository-from-url',\n      url,\n      branch,\n      pr,\n      filepath,\n    }\n  }\n\n  if (actionName === 'openlocalrepo') {\n    return {\n      name: 'open-repository-from-path',\n      path: decodeURIComponent(parsedPath),\n    }\n  }\n\n  return unknown\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/parse-app-url.ts","// See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n// ASCII Control chars and space, DEL, ~ ^ : ? * [ \\\n// | \" < and > is technically a valid refname but not on Windows\n// the magic sequence @{, consecutive dots, leading and trailing dot, ref ending in .lock\nconst invalidCharacterRegex = /[\\x00-\\x20\\x7F~^:?*\\[\\\\|\"\"<>]|@{|\\.\\.+|^\\.|\\.$|\\.lock$|\\/$/g\n\n/** Sanitize a proposed branch name by replacing illegal characters. */\nexport function sanitizedBranchName(name: string): string {\n  return name\n    .replace(invalidCharacterRegex, '-')\n    .replace(/--+/g, '-')\n    .replace(/^-/g, '')\n}\n\n/** Validate a branch does not contain any invalid characters */\nexport function testForInvalidChars(name: string): boolean {\n  return invalidCharacterRegex.test(name)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/sanitize-branch.ts","import * as ChildProcess from 'child_process'\nimport * as Path from 'path'\nimport * as Os from 'os'\nimport { pathExists, mkdirIfNeeded, writeFile } from '../lib/file-system'\n\nconst appFolder = Path.resolve(process.execPath, '..')\nconst rootAppDir = Path.resolve(appFolder, '..')\nconst updateDotExe = Path.resolve(Path.join(rootAppDir, 'Update.exe'))\nconst exeName = Path.basename(process.execPath)\n\n// A lot of this code was cargo-culted from our Atom comrades:\n// https://github.com/atom/atom/blob/7c9f39e3f1d05ee423e0093e6b83f042ce11c90a/src/main-process/squirrel-update.coffee.\n\n/**\n * Handle Squirrel.Windows app lifecycle events.\n *\n * Returns a promise which will resolve when the work is done.\n */\nexport function handleSquirrelEvent(eventName: string): Promise<void> | null {\n  switch (eventName) {\n    case '--squirrel-install':\n      return handleInstalled()\n\n    case '--squirrel-updated':\n      return handleUpdated()\n\n    case '--squirrel-uninstall':\n      return handleUninstall()\n\n    case '--squirrel-obsolete':\n      return Promise.resolve()\n  }\n\n  return null\n}\n\nasync function handleInstalled(): Promise<void> {\n  await createShortcut(['StartMenu', 'Desktop'])\n  await installCLI()\n}\n\nasync function handleUpdated(): Promise<void> {\n  await updateShortcut()\n  await installCLI()\n}\n\nasync function installCLI(): Promise<void> {\n  const binPath = getBinPath()\n  await mkdirIfNeeded(binPath)\n  await writeBatchScriptCLITrampoline(binPath)\n  await writeShellScriptCLITrampoline(binPath)\n  const paths = await getPathSegments()\n  if (paths.indexOf(binPath) < 0) {\n    await setPathSegments([...paths, binPath])\n  }\n}\n\n/**\n * Get the path for the `bin` directory which exists in our `AppData` but\n * outside path which includes the installed app version.\n */\nfunction getBinPath(): string {\n  return Path.resolve(process.execPath, '../../bin')\n}\n\nfunction resolveVersionedPath(binPath: string, relativePath: string): string {\n  const appFolder = Path.resolve(process.execPath, '..')\n  return Path.relative(binPath, Path.join(appFolder, relativePath))\n}\n\n/**\n * Here's the problem: our app's path contains its version number. So each time\n * we update, the path to our app changes. So it's Real Hard to add our path\n * directly to `Path`. We'd have to detect and remove stale entries, etc.\n *\n * So instead, we write a trampoline out to a fixed path, still inside our\n * `AppData` directory but outside the version-specific path. That trampoline\n * just launches the current version's CLI tool. Then, whenever we update, we\n * rewrite the trampoline to point to the new, version-specific path. Bingo\n * bango Bob's your uncle.\n */\nasync function writeBatchScriptCLITrampoline(binPath: string): Promise<void> {\n  const versionedPath = resolveVersionedPath(\n    binPath,\n    'resources/app/static/github.bat'\n  )\n\n  const trampoline = `@echo off\\n\"%~dp0\\\\${versionedPath}\" %*`\n  const trampolinePath = Path.join(binPath, 'github.bat')\n\n  return writeFile(trampolinePath, trampoline)\n}\n\nasync function writeShellScriptCLITrampoline(binPath: string): Promise<void> {\n  const versionedPath = resolveVersionedPath(\n    binPath,\n    'resources/app/static/github.sh'\n  )\n\n  const trampoline = `#!/usr/bin/env bash\n  DIR=\"$( cd \"$( dirname \"\\$\\{BASH_SOURCE[0]\\}\" )\" && pwd )\"\n  sh \"$DIR/${versionedPath}\" \"$@\"`\n  const trampolinePath = Path.join(binPath, 'github')\n\n  return writeFile(trampolinePath, trampoline, { encoding: 'utf8', mode: 755 })\n}\n\n/** Spawn the Squirrel.Windows `Update.exe` with a command. */\nasync function spawnSquirrelUpdate(\n  commands: ReadonlyArray<string>\n): Promise<void> {\n  await spawn(updateDotExe, commands)\n}\n\ntype ShortcutLocations = ReadonlyArray<'StartMenu' | 'Desktop'>\n\nfunction createShortcut(locations: ShortcutLocations): Promise<void> {\n  return spawnSquirrelUpdate([\n    '--createShortcut',\n    exeName,\n    '-l',\n    locations.join(','),\n  ])\n}\n\nasync function handleUninstall(): Promise<void> {\n  await removeShortcut()\n\n  const paths = await getPathSegments()\n  const binPath = getBinPath()\n  const pathsWithoutBinPath = paths.filter(p => p !== binPath)\n  return setPathSegments(pathsWithoutBinPath)\n}\n\nfunction removeShortcut(): Promise<void> {\n  return spawnSquirrelUpdate(['--removeShortcut', exeName])\n}\n\nasync function updateShortcut(): Promise<void> {\n  const homeDirectory = Os.homedir()\n  if (homeDirectory) {\n    const desktopShortcutPath = Path.join(\n      homeDirectory,\n      'Desktop',\n      'GitHub Desktop.lnk'\n    )\n    const exists = await pathExists(desktopShortcutPath)\n    const locations: ShortcutLocations = exists\n      ? ['StartMenu', 'Desktop']\n      : ['StartMenu']\n    return createShortcut(locations)\n  } else {\n    return createShortcut(['StartMenu', 'Desktop'])\n  }\n}\n\n/** Get the path segments in the user's `Path`. */\nasync function getPathSegments(): Promise<ReadonlyArray<string>> {\n  let powershellPath: string\n  const systemRoot = process.env['SystemRoot']\n  if (systemRoot) {\n    const system32Path = Path.join(process.env.SystemRoot, 'System32')\n    powershellPath = Path.join(\n      system32Path,\n      'WindowsPowerShell',\n      'v1.0',\n      'powershell.exe'\n    )\n  } else {\n    powershellPath = 'powershell.exe'\n  }\n\n  const args = [\n    '-noprofile',\n    '-ExecutionPolicy',\n    'RemoteSigned',\n    '-command',\n    // Set encoding and execute the command, capture the output, and return it\n    // via .NET's console in order to have consistent UTF-8 encoding.\n    // See http://stackoverflow.com/questions/22349139/utf-8-output-from-powershell\n    // to address https://github.com/atom/atom/issues/5063\n    `\n      [Console]::OutputEncoding=[System.Text.Encoding]::UTF8\n      $output=[environment]::GetEnvironmentVariable('Path', 'User')\n      [Console]::WriteLine($output)\n    `,\n  ]\n\n  const stdout = await spawn(powershellPath, args)\n  const pathOutput = stdout.replace(/^\\s+|\\s+$/g, '')\n  return pathOutput.split(/;+/).filter(segment => segment.length)\n}\n\n/** Set the user's `Path`. */\nasync function setPathSegments(paths: ReadonlyArray<string>): Promise<void> {\n  let setxPath: string\n  const systemRoot = process.env['SystemRoot']\n  if (systemRoot) {\n    const system32Path = Path.join(systemRoot, 'System32')\n    setxPath = Path.join(system32Path, 'setx.exe')\n  } else {\n    setxPath = 'setx.exe'\n  }\n\n  await spawn(setxPath, ['Path', paths.join(';')])\n}\n\n/** Spawn a command with arguments and capture its output. */\nfunction spawn(command: string, args: ReadonlyArray<string>): Promise<string> {\n  try {\n    const child = ChildProcess.spawn(command, args as string[])\n    return new Promise<string>((resolve, reject) => {\n      let stdout = ''\n      child.stdout.on('data', data => {\n        stdout += data\n      })\n\n      child.on('close', code => {\n        if (code === 0) {\n          resolve(stdout)\n        } else {\n          reject(new Error(`Command \"${command} ${args}\" failed: \"${stdout}\"`))\n        }\n      })\n\n      child.on('error', (err: Error) => {\n        reject(err)\n      })\n\n      // This is necessary if using Powershell 2 on Windows 7 to get the events\n      // to raise.\n      // See http://stackoverflow.com/questions/9155289/calling-powershell-from-nodejs\n      child.stdin.end()\n    })\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/squirrel-updater.ts","import { app, net } from 'electron'\n\nconst ErrorEndpoint = 'https://central.github.com/api/desktop/exception'\n\n/** Report the error to Central. */\nexport async function reportError(\n  error: Error,\n  extra?: { [key: string]: string }\n) {\n  if (__DEV__) {\n    return\n  }\n\n  const data = new Map<string, string>()\n\n  data.set('name', error.name)\n  data.set('message', error.message)\n\n  if (error.stack) {\n    data.set('stack', error.stack)\n  }\n\n  data.set('platform', process.platform)\n  data.set('sha', __SHA__)\n  data.set('version', app.getVersion())\n\n  if (extra) {\n    for (const key of Object.keys(extra)) {\n      data.set(key, extra[key])\n    }\n  }\n\n  const requestOptions: Electron.RequestOptions = {\n    method: 'POST',\n    url: ErrorEndpoint,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n  }\n\n  const body = [...data.entries()]\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(value)}`\n    )\n    .join('&')\n\n  try {\n    await new Promise<void>((resolve, reject) => {\n      const request = net.request(requestOptions)\n\n      request.on('response', response => {\n        if (response.statusCode === 200) {\n          resolve()\n        } else {\n          reject(\n            `Got ${response.statusCode} - ${response.statusMessage} from central`\n          )\n        }\n      })\n\n      request.on('error', reject)\n\n      request.end(body)\n    })\n    log.info('Error report submitted')\n  } catch (e) {\n    log.error('Failed submitting error report', error)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/exception-reporting.ts","import { app, dialog } from 'electron'\nimport { setCrashMenu } from './menu'\nimport { formatError } from '../lib/logging/format-error'\nimport { CrashWindow } from './crash-window'\n\nlet hasReportedUncaughtException = false\n\n/** Show the uncaught exception UI. */\nexport function showUncaughtException(isLaunchError: boolean, error: Error) {\n  log.error(formatError(error))\n\n  if (hasReportedUncaughtException) {\n    return\n  }\n\n  hasReportedUncaughtException = true\n\n  setCrashMenu()\n\n  const crashWindow = new CrashWindow(\n    isLaunchError ? 'launch' : 'generic',\n    error\n  )\n\n  crashWindow.onDidLoad(() => {\n    crashWindow.show()\n  })\n\n  crashWindow.onFailedToLoad(() => {\n    dialog.showMessageBox(\n      {\n        type: 'error',\n        title: __DARWIN__ ? `Unrecoverable Error` : 'Unrecoverable error',\n        message:\n          `GitHub Desktop has encountered an unrecoverable error and will need to restart.\\n\\n` +\n          `This has been reported to the team, but if you encounter this repeatedly please report ` +\n          `this issue to the GitHub Desktop issue tracker.\\n\\n${error.stack ||\n            error.message}`,\n      },\n      response => {\n        if (!__DEV__) {\n          app.relaunch()\n        }\n        app.quit()\n      }\n    )\n  })\n\n  crashWindow.onClose(() => {\n    if (!__DEV__) {\n      app.relaunch()\n    }\n    app.quit()\n  })\n\n  crashWindow.load()\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/show-uncaught-exception.ts","import { BrowserWindow, ipcMain } from 'electron'\nimport { Emitter, Disposable } from 'event-kit'\nimport { ICrashDetails, ErrorType } from '../crash/shared'\nimport { registerWindowStateChangedEvents } from '../lib/window-state'\n\nconst minWidth = 600\nconst minHeight = 500\n\n/**\n * A wrapper around the BrowserWindow instance for our crash process.\n *\n * The crash process is responsible for presenting the user with an\n * error after the main process or any renderer process has crashed due\n * to an uncaught exception or when the main renderer has failed to load.\n */\nexport class CrashWindow {\n  private readonly window: Electron.BrowserWindow\n  private readonly emitter = new Emitter()\n  private readonly errorType: ErrorType\n  private readonly error: Error\n\n  private hasFinishedLoading = false\n  private hasSentReadyEvent = false\n\n  public constructor(errorType: ErrorType, error: Error) {\n    const windowOptions: Electron.BrowserWindowConstructorOptions = {\n      width: minWidth,\n      height: minHeight,\n      minWidth: minWidth,\n      minHeight: minHeight,\n      show: false,\n      // This fixes subpixel aliasing on Windows\n      // See https://github.com/atom/atom/commit/683bef5b9d133cb194b476938c77cc07fd05b972\n      backgroundColor: '#fff',\n      webPreferences: {\n        // Disable auxclick event\n        // See https://developers.google.com/web/updates/2016/10/auxclick\n        disableBlinkFeatures: 'Auxclick',\n        // Explicitly disable experimental features for the crash process\n        // since, theoretically it might be these features that caused the\n        // the crash in the first place. As of writing we don't use any\n        // components that relies on experimental features in the crash\n        // process but our components which relies on ResizeObserver should\n        // be able to degrade gracefully.\n        experimentalFeatures: false,\n      },\n    }\n\n    if (__DARWIN__) {\n      windowOptions.titleBarStyle = 'hidden'\n    } else if (__WIN32__) {\n      windowOptions.frame = false\n    }\n\n    this.window = new BrowserWindow(windowOptions)\n    this.error = error\n    this.errorType = errorType\n  }\n\n  public load() {\n    log.debug('Starting crash process')\n\n    // We only listen for the first of the loading events to avoid a bug in\n    // Electron/Chromium where they can sometimes fire more than once. See\n    // See\n    // https://github.com/desktop/desktop/pull/513#issuecomment-253028277. This\n    // shouldn't really matter as in production builds loading _should_ only\n    // happen once.\n    this.window.webContents.once('did-start-loading', () => {\n      log.debug('Crash process in startup')\n    })\n\n    this.window.webContents.once('did-finish-load', () => {\n      log.debug('Crash process started')\n      if (process.env.NODE_ENV === 'development') {\n        this.window.webContents.openDevTools()\n      }\n\n      this.hasFinishedLoading = true\n      this.maybeEmitDidLoad()\n    })\n\n    this.window.webContents.on('did-finish-load', () => {\n      this.window.webContents.setVisualZoomLevelLimits(1, 1)\n    })\n\n    this.window.webContents.on('did-fail-load', () => {\n      log.error('Crash process failed to load')\n      if (__DEV__) {\n        this.window.webContents.openDevTools()\n        this.window.show()\n      } else {\n        this.emitter.emit('did-fail-load', null)\n      }\n    })\n\n    ipcMain.on('crash-ready', (event: Electron.IpcMessageEvent) => {\n      log.debug(`Crash process is ready`)\n\n      this.hasSentReadyEvent = true\n\n      this.sendError()\n      this.maybeEmitDidLoad()\n    })\n\n    ipcMain.on('crash-quit', (event: Electron.IpcMessageEvent) => {\n      log.debug('Got quit signal from crash process')\n      this.window.close()\n    })\n\n    registerWindowStateChangedEvents(this.window)\n\n    this.window.loadURL(`file://${__dirname}/crash.html`)\n  }\n\n  /**\n   * Emit the `onDidLoad` event if the page has loaded and the renderer has\n   * signalled that it's ready.\n   */\n  private maybeEmitDidLoad() {\n    if (this.hasFinishedLoading && this.hasSentReadyEvent) {\n      this.emitter.emit('did-load', null)\n    }\n  }\n\n  public onClose(fn: () => void) {\n    this.window.on('closed', fn)\n  }\n\n  public onFailedToLoad(fn: () => void) {\n    this.emitter.on('did-fail-load', fn)\n  }\n\n  /**\n   * Register a function to call when the window is done loading. At that point\n   * the page has loaded and the renderer has signalled that it is ready.\n   */\n  public onDidLoad(fn: () => void): Disposable {\n    return this.emitter.on('did-load', fn)\n  }\n\n  public focus() {\n    this.window.focus()\n  }\n\n  /** Show the window. */\n  public show() {\n    log.debug('Showing crash process window')\n    this.window.show()\n  }\n\n  /** Report the error to the renderer. */\n  private sendError() {\n    // `Error` can't be JSONified so it doesn't transport nicely over IPC. So\n    // we'll just manually copy the properties we care about.\n    const friendlyError = {\n      stack: this.error.stack,\n      message: this.error.message,\n      name: this.error.name,\n    }\n\n    const details: ICrashDetails = {\n      type: this.errorType,\n      error: friendlyError,\n    }\n\n    this.window.webContents.send('error', details)\n  }\n\n  public destroy() {\n    this.window.destroy()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/main-process/crash-window.ts"],"sourceRoot":""}